<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chiechie&#39;s Cosmos</title>
  
  <subtitle>Set your course by the stars, not by the lights of passing ships. —— Omar Bradley</subtitle>
  <link href="https://chiechie.github.io/atom.xml" rel="self"/>
  
  <link href="https://chiechie.github.io/"/>
  <updated>2021-05-28T05:31:24.321Z</updated>
  <id>https://chiechie.github.io/</id>
  
  <author>
    <name>Chiechie</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>about_leishe</title>
    <link href="https://chiechie.github.io/2021/05/28/about-leishe/"/>
    <id>https://chiechie.github.io/2021/05/28/about-leishe/</id>
    <published>2021-05-28T05:31:24.000Z</published>
    <updated>2021-05-28T05:31:24.321Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    
      
      
    <summary type="html">
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>rf3-gym</title>
    <link href="https://chiechie.github.io/2021/05/27/AI/reinforcement_learning/rf3-gym/"/>
    <id>https://chiechie.github.io/2021/05/27/AI/reinforcement_learning/rf3-gym/</id>
    <published>2021-05-27T12:33:14.000Z</published>
    <updated>2021-05-27T12:33:14.756Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    
      
      
    <summary type="html">
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>道德经1-反者道之动, 弱者道之用</title>
    <link href="https://chiechie.github.io/2021/05/26/reading_notes/daodejing1/"/>
    <id>https://chiechie.github.io/2021/05/26/reading_notes/daodejing1/</id>
    <published>2021-05-26T01:23:01.000Z</published>
    <updated>2021-05-26T02:33:51.506Z</updated>
    
    <content type="html"><![CDATA[<p>守弱：如婴儿般的柔和与可塑。</p><p>任何属性，操性，仁则都有其正负两面，也就是阴与阳。而属性明显曰「强」，属性混沌曰「弱」。如果根据一己之经验，认为一种属性，操性，仁则只有好处，没有缺陷，而拼命发展，必致「阴」「阳」失调而进入危境。</p><p>二十三章:「希言自然。故飘风不终朝，骤雨不终日。孰为此者?天地。天地尚不能久，而况于人乎。」</p><p>以飘风骤雨为天候中「阴」「阳」不调之例子。这就隐喻到「雷厉风行」，偏执一「仁」一「义」之治事方法是不能长久的;无论在当事人看来他的「政治理想」是多么完美或吸引人。</p><p>五十五章:「含德之厚，比于赤子……知和曰常，知常曰明。益生曰祥。心使气曰强。物壮则老，谓之不道，不道早巳。」</p><p>以婴儿为「合乎自然」的例子，也就是阴阳调和之例子。婴儿柔和，乃负阴抱阳之象，合于大道。但人一旦成长启智之后，就慢慢的开始过分发展某种属性，操性，或仁则，其原因可是功利的，也可是欲望驱使的。而过分发展某种属性之结果就是「老」。</p><p>三十章:「……果而勿矜，果而勿伐，果而勿骄。果而不得已，果而勿强。物壮则老，是谓不道，不道早巳。」</p><p>人之「老」在躯体也在头脑，最大的特征在失去思想之柔韧与变通---这些都是过分发展某一属性之「果」。人会变得过于执着固定事物，或过于刚猛，或过于退怯;百象皆有，不一而足;總之，都不合道。从老子之道来看就是失去「负阴抱阳」之特性。</p><p>十一章： 三十辐共一毂，当其无，有车之用。埏埴以为器，当其无，有器之用。凿户牖以为室，当其无，有室之用。故有之以为利，无之以为用。</p><p>任何器具、房室、或机械要发生作用，都要有一「容纳」其他事物之「空间」，老子以此「空间」喻道之「无」，而容万物之性使万物发生作用。</p><p>四十章:「反者道之动;弱者道之用。天下万物生于有，有生于无」。</p><p>王弼的诠释:「高以下为基，贵以贱为本，有以无为用，此其反也，动皆知其所无，则物通矣」。「此其反也，动皆知其所无(道之本体)」一段有双关之意，即「相反相成」与「返于道之本体[无]」。「动皆知其所无」指要明白大道之运作，一定要对万事万物追溯至「无」之起源处。</p><p>这个道理对古之君王重要，对于一般人或短时间却不尽然。一般人在一时空下可有某一操性，或行某一仁则而畅通无阻，甚至终生得志。但这只是从一人或一团体来看;对整体国家来说则大不相同。毫无疑问的，治道要讲求整体国家之长治久安，所以明了[弱者道之用]是必要的</p><blockquote><p>对做平台也很重要。</p></blockquote><h2 id="参考">参考</h2><ol type="1"><li><a href="https://www.aisixiang.com/data/37674.html">反者道之动, 弱者道之用”之詮釋</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;守弱：如婴儿般的柔和与可塑。&lt;/p&gt;
&lt;p&gt;任何属性，操性，仁则都有其正负两面，也就是阴与阳。而属性明显曰「强」，属性混沌曰「弱」。如果根据一己之经验，认为一种属性，操性，仁则只有好处，没有缺陷，而拼命发展，必致「阴」「阳」失调而进入危境。&lt;/p&gt;
&lt;p&gt;二十三章:「希言自</summary>
      
    
    
    
    <category term="阅读" scheme="https://chiechie.github.io/categories/%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="哲学" scheme="https://chiechie.github.io/tags/%E5%93%B2%E5%AD%A6/"/>
    
    <category term="道家" scheme="https://chiechie.github.io/tags/%E9%81%93%E5%AE%B6/"/>
    
    <category term="道德经" scheme="https://chiechie.github.io/tags/%E9%81%93%E5%BE%B7%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>风控领域的图挖掘场景</title>
    <link href="https://chiechie.github.io/2021/05/24/technology/visualize-graph/"/>
    <id>https://chiechie.github.io/2021/05/24/technology/visualize-graph/</id>
    <published>2021-05-24T01:08:21.000Z</published>
    <updated>2021-05-26T01:18:16.313Z</updated>
    
    <content type="html"><![CDATA[<h1 id="几个场景">几个场景</h1><h2 id="攻防对抗">攻防对抗</h2><p>一般都会有下述风控规则：</p><ul><li>7天内在注册账户数超过**的设备号</li><li>1天内某IP关联超过xx个账户</li></ul><p>虽然规则简单，但由于实时性和贴近业务的特点，可以拦截不少黑产, 但也会造成一定误杀，特别是IP类的规则。</p><p>同时因为风控是攻防对抗的过程，黑产也会升级，比如通过伪造设备、LBS、频繁更换IP等手段尽可能伪装成一个真人，隐蔽聚集性等显性特征，绕过风控规则。</p><p>相应风控技术也在进化，如使用设备指纹、IP画像、验证码对抗等。</p><h2 id="基于关联关系识别团伙">基于关联关系识别团伙</h2><p>可以定义设备-账户的Graph如下：</p><ul><li>节点：账户 + 设备</li><li>边：近xx天账户与设备出现在同一事件中，则它们之间有一条边。</li></ul><p>识别方法：</p><ul><li>无监督方法：通过「连通子图算法」识别出一个个连通的社区，如果社区规模较大，可能背后业务含义是黑产控制一批账户。定义社区规模为score，通过调节阈值来控制误杀、召回。</li><li>有监督方法-传统：等价为节点分类问题，通过提取节点业务特征、拓扑特征、所属社区特征，训练一个分类器去预测。</li><li>有监督方法-图神经网络：将节点业务特征X与网络拓扑结构A作为输入学习函数，用于对未知数据的预测.相比规则来说，此类方法不仅用到了更复杂的关系，同时也考虑了节点业务和拓扑特征。故防控能力会更强一些。</li></ul><h2 id="基于相似度识别团伙">基于相似度识别团伙</h2><p>如果黑产成功避开设备指纹、聚集性规则等风控措施，把自己伪装成一个真人，如何检测？——只要作案了，总会留下蛛丝马迹。</p><ul><li>垃圾文本：比如留下了垃圾文本，那么利用文本之间相似度（Jaccard、semi-hash）构建账户之间相似关系，然后使用图分割+连通子图查找技术识别，具体可<a href="https://zhuanlan.zhihu.com/p/23385044">参考这里</a></li><li>行为相似度：facebook针对刷量的行为，通过计算账户之间行为度来构建graph，<a href="https://zhuanlan.zhihu.com/p/58334765">详见这里</a>.此类方法最大问题是, 两两节点相似度计算性能问题。一般会做下约束，如限制在某个事件场景下、限制在某段事件内以及如何分段计算+合并，并且往往是通过spark分布式计算。</li></ul><h2 id="基于共享特征识别团伙">基于共享特征识别团伙</h2><p>因为黑产控制大量的账户通过软件进行攻击，而不是手工操作，故这些账户某些共同属性上会有Pattern。</p><p>大概的解题思路是“搜集证据”，将共享的某特征/字段作为，判断证据强弱，如共享设备是强证据，可以仅凭此条直接断案。 但是像共用某品牌手机是弱证据，需要多个弱证据结合一起断案。</p><p>再抽象一点是有点像「层次社区划分算法」：</p><ol type="1"><li>定义证据：通过业务经验定义共享特征集，不通场景特征集应该是不同的。</li><li>找证据：分别对每个/每组特征进行聚类/社区划分算法，得到一个个簇.</li><li>组合证据：将2得到的簇作为节点，簇之间共有账户数作为连边，构建graph，再进一步划分得到最终的社区，每个社区中的节点共享多个特征。</li></ol><h1 id="总结">总结</h1><ol type="1"><li>上述三种类型方法的主要区别在于graph的不同，在整个图挖掘体系中最核心也最难一点在于，如何将业务经验抽象成Graph。</li><li>社区发现算法以图分割+连通子图查找为主，一方面可解释强，另外可以通过调节阈值权衡召回和误差，以满足运营人员需要。这也是 "拿算法适配业务，而不是业务适配算法"的工作准则。</li></ol><h1 id="参考">参考</h1><ol type="1"><li><a href="https://scikit-network.readthedocs.io/en/latest/">scikit-network的doc</a></li><li><a href="https://www.zhihu.com/search?type=content&amp;q=%E5%9B%BE%E6%8C%96%E6%8E%98">zhihu-风控</a></li><li><a href="https://zhuanlan.zhihu.com/p/62750137">GCN</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;几个场景&quot;&gt;几个场景&lt;/h1&gt;
&lt;h2 id=&quot;攻防对抗&quot;&gt;攻防对抗&lt;/h2&gt;
&lt;p&gt;一般都会有下述风控规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;7天内在注册账户数超过**的设备号&lt;/li&gt;
&lt;li&gt;1天内某IP关联超过xx个账户&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;虽然规则简单</summary>
      
    
    
    
    <category term="技术" scheme="https://chiechie.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="图数据" scheme="https://chiechie.github.io/tags/%E5%9B%BE%E6%95%B0%E6%8D%AE/"/>
    
    <category term="图挖掘" scheme="https://chiechie.github.io/tags/%E5%9B%BE%E6%8C%96%E6%8E%98/"/>
    
    <category term="连通子图算法" scheme="https://chiechie.github.io/tags/%E8%BF%9E%E9%80%9A%E5%AD%90%E5%9B%BE%E7%AE%97%E6%B3%95/"/>
    
    <category term="层次社区划分算法" scheme="https://chiechie.github.io/tags/%E5%B1%82%E6%AC%A1%E7%A4%BE%E5%8C%BA%E5%88%92%E5%88%86%E7%AE%97%E6%B3%95/"/>
    
    <category term="社区发现算法" scheme="https://chiechie.github.io/tags/%E7%A4%BE%E5%8C%BA%E5%8F%91%E7%8E%B0%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>随机游走</title>
    <link href="https://chiechie.github.io/2021/05/23/AI/cause-effect/randomwalking/"/>
    <id>https://chiechie.github.io/2021/05/23/AI/cause-effect/randomwalking/</id>
    <published>2021-05-23T04:52:46.000Z</published>
    <updated>2021-05-24T01:56:27.155Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍">介绍</h2><p>已知因果图时，随机游走可以用来做因果推断。</p><p>原理是，基于因果关系，构建概率转移矩阵，通过模拟故障传播路径，得到故障根因。</p><h2 id="随机游走算法-详细">随机游走算法-详细</h2><ul><li>Step 1. 生成一个关系图G. <span class="math inline">\(e_{ij} = 1\)</span> 表示节点i是节点j的原因（之一）</li><li>Step 2. 计算转移矩阵Q:<ol type="1"><li>向前游走：从result节点到 the cause节点.理论上，跟异常节点越相关的节点，就越有可能是根因. 也就是说 <span class="math inline">\(Q_{ij} = R(v_{abnormal}, v_j)\)</span>, <span class="math inline">\(R(v_{abnormal}, v_j)\)</span>表示异常节点<span class="math inline">\(v_{abnormal}\)</span> 和 $ v_j$之间的相关系数, and <span class="math inline">\(e_{ji} = 1\)</span></li><li>向后游走：从cause节点到result节点. 为了避免算法陷入跟异常不相关或者低相关的节点，随机游走允许从cause节点跳出到result节点。 如果 <span class="math inline">\(e_{j i} \in E\)</span>且 <span class="math inline">\(e_{ij} \notin E\)</span>, 那么 <span class="math display">\[Q_{ji} =\rho R\left(v_{abnormal}, v_{i}\right),\rho \in[0,1]\]</span>.</li><li>维持原状：如果一个节点，它的邻居们都跟异常节点的相关性很低，这个节点很有可能就是根因了，所以游走者应该停留在这里， <span class="math display">\[Q_{i i}=\max \left[ 0, R\left(v_{abnormal}, v_{i}\right)- \max _{k: e_{k i} \in E} R\left(v_{abnormal}, v_{k}\right) \right]\]</span></li></ol></li><li>Step 3. 对行做归一化，得到转移概率矩阵 <span class="math display">\[\bar{Q}_{i j}=\frac{Q_{i j}}{\sum_{j} Q_{i j}}\]</span></li><li>Step 4. 在G上面随机游走，使转移概率<span class="math inline">\(\bar{Q}\)</span></li></ul><p>采用类似pagerank的方法，得到每个节点的得分。</p><h2 id="参考">参考</h2><ol start="4" type="1"><li><a href="https://netman.aiops.org/wp-content/uploads/2020/06/%E5%AD%9F%E5%AA%9B.pdf">Page3,4 -paper</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;介绍&quot;&gt;介绍&lt;/h2&gt;
&lt;p&gt;已知因果图时，随机游走可以用来做因果推断。&lt;/p&gt;
&lt;p&gt;原理是，基于因果关系，构建概率转移矩阵，通过模拟故障传播路径，得到故障根因。&lt;/p&gt;
&lt;h2 id=&quot;随机游走算法-详细&quot;&gt;随机游走算法-详细&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;St</summary>
      
    
    
    
    <category term="技术" scheme="https://chiechie.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="贝叶斯" scheme="https://chiechie.github.io/tags/%E8%B4%9D%E5%8F%B6%E6%96%AF/"/>
    
    <category term="AIOps" scheme="https://chiechie.github.io/tags/AIOps/"/>
    
    <category term="根因分析" scheme="https://chiechie.github.io/tags/%E6%A0%B9%E5%9B%A0%E5%88%86%E6%9E%90/"/>
    
    <category term="因果分析" scheme="https://chiechie.github.io/tags/%E5%9B%A0%E6%9E%9C%E5%88%86%E6%9E%90/"/>
    
    <category term="因果推断" scheme="https://chiechie.github.io/tags/%E5%9B%A0%E6%9E%9C%E6%8E%A8%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>PageRank算法</title>
    <link href="https://chiechie.github.io/2021/05/22/technology/pagerank/"/>
    <id>https://chiechie.github.io/2021/05/22/technology/pagerank/</id>
    <published>2021-05-22T10:07:11.000Z</published>
    <updated>2021-05-24T01:56:27.164Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近需要对图数据进行分析，了解下PageRank的原理</p><p>BTW, PageRank还可以做社区划分？</p></blockquote><h2 id="总结一下">总结一下</h2><p>pagerank: 假设，网上冲浪的人都是漫无目的的人，他们在网页一个链接接一个链接点下去，但是，整个互联网的节点，最终流量可能的分布能达到一个稳态。 也就是说，随机分布于各网页的流量经过次数足够多的转移之后，会达到一个稳定的状态，这个也代表每个网页的信息度。</p><p>基于这个假设，可以构建一个模型， <span class="math display">\[V_n = M ^n * V_0\]</span></p><p>一般来说，可以拿到网页之间调用拓扑，经过转换，可以将这个拓扑变为概率转移矩阵M，最终算出稳定态的V_n</p><p>给定点之间的连接关系，输出每个节点的分数，</p><p>补充下，最naive的方法存在终止点问题，也就是说，一个网站它不链接任何别的网站，或者一个微服务，它不调用其他任何微服务 按照上面的思路很可能出现一种情况，最终的流量全到这个自大狂网页那里去了，所以有一个改进的思路，假设冲浪着有一点点聪明，他并不是一味的接受灌输的链接，而是有一定概率，主动跳出去，到达一个新的站点，这个方式可以用下面的式子建模：</p><p><span class="math display">\[V_n = d * M * V_{n-1} + (1-d) * e \]</span></p><p>e = [1/n,...1/n]</p><p>d表示按照当前页面推荐的链接继续点下去的概率 1-d表示从当前网页跳出来，主动输入一个新网页重新开始的概率</p><h2 id="代码">代码</h2><p>用代码验证一下，理解没有问题</p><p>https://github.com/chiechie/BasicAlgo/blob/main/pagerank.py</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ground truth</span><br><span class="line"> [[0.25419178], [0.13803151], [0.13803151], [0.20599017], [0.26375504]]</span><br><span class="line">result</span><br><span class="line"> [0.25419178 0.13803151 0.13803151 0.20599017 0.26375504]</span><br></pre></td></tr></table></figure><h2 id="参考">参考</h2><ol type="1"><li><a href="https://blog.csdn.net/gamer_gyt/article/details/47443877">pagerank-csdn</a></li><li><a href="https://scikit-network.readthedocs.io/en/latest/tutorials/ranking/pagerank.html">scikit-network-pagerank</a></li><li><a href="https://zh.wikipedia.org/wiki/PageRank">wiki-PageRank</a></li><li>https://blog.csdn.net/google19890102/article/details/48660239</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;最近需要对图数据进行分析，了解下PageRank的原理&lt;/p&gt;
&lt;p&gt;BTW, PageRank还可以做社区划分？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;总结一下&quot;&gt;总结一下&lt;/h2&gt;
&lt;p&gt;pagerank: 假设，网上冲浪的人都是</summary>
      
    
    
    
    <category term="技术" scheme="https://chiechie.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="图算法" scheme="https://chiechie.github.io/tags/%E5%9B%BE%E7%AE%97%E6%B3%95/"/>
    
    <category term="拓扑数据" scheme="https://chiechie.github.io/tags/%E6%8B%93%E6%89%91%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>chapter2.1.5 基于拓扑的根因定位-MicroCause</title>
    <link href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-2_1_6-topo-rca-MicroCause/"/>
    <id>https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-2_1_6-topo-rca-MicroCause/</id>
    <published>2021-05-21T14:43:57.000Z</published>
    <updated>2021-05-28T13:39:33.530Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录">目录</h2><ul><li><a href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-0-summary/">chapter0 概览</a></li><li><a href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-1-event-generate/">chapter1 故障发现</a><ul><li><a href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-1_1-kpi-detector/">chapter1.1 单指标异常检测</a></li><li><a href="https://chiechie.github.io/2021/03/04/AI/AIOps/AIOps-1_2-fault-prediction/">chapter1.3 故障预测</a></li><li><a href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-1_4-kpi-correlation/">chapter1.4 指标异常关联</a></li><li><a href="https://chiechie.github.io/2021/02/19/AI/AIOps/AIOps-1_5-log-analysis/">chapter1.5 日志聚类</a><ul><li><a href="https://chiechie.github.io/2021/03/04/AI/AIOps/AIOps-1_5_1-log-analysis_logmine/">chapter1.5.1 使用logmine加强版做日志聚类</a></li><li><a href="https://chiechie.github.io/2021/03/04/AI/AIOps/AIOps-1_5_2-log-analysis_meituan/">chapter1.5.2 美团日志聚类</a></li></ul></li></ul></li><li><a href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-2-event-analysis/">chapter2 故障定位</a><ul><li><a href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-2_1-topo-rca/">chapter2.1 微服务系统的故障定位</a><ul><li><a href="https://chiechie.github.io/2021/03/02/AI/AIOps/AIOps-2_1_1-topo-rca-causeinfer-notes1/">chapter2.1.1 CauseInfer1</a></li><li><a href="https://chiechie.github.io/2021/03/03/AI/AIOps/AIOps-2_1_2-topo-rca-causeinfer-notes2/">chapter2.1.2 CauseInfer2</a></li><li><a href="https://chiechie.github.io/2021/03/10/AI/AIOps/AIOps-2_1_3-topo-rca-aiops2020/">chapter2.1.3 AIOps挑战赛2020-获奖方案分享</a></li><li><a href="https://chiechie.github.io/2021/03/09/AI/AIOps/AIOps-2_1_4-topo-rca-aiops2021/">chapter2.1.4 AIOps挑战赛2021-demo方案</a></li><li><a href="https://chiechie.github.io/2021/03/10/AI/AIOps/AIOps-2_1_5-topo-rca-cnsoftbei2020/">chapter2.1.5 N-Softbei2020比赛</a></li><li><a href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-2_1_6-topo-rca-MicroCause">chapter2.1.6 MicroCause</a></li></ul></li><li><a href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-2_2-multi-dimensional-rca/">chapter2.2 多维下钻根因定位</a>: 暂无</li><li><a href="https://chiechie.github.io/2021/03/15/AI/AIOps/AIOps-2_3-trace_rca/">chapter2.3 调用链根因分析</a></li><li><a href="https://chiechie.github.io/2021/04/14/AI/AIOps/AIOps-2_4-metric_event_correlation/">chapter2.4 时间序列关联性分析</a></li></ul></li><li>chapter3 故障恢复</li></ul><blockquote><p>清华阿里合作paper《基于因果分析的微服务内根因定位》, Localizing Failure Root Causes in a Microservice through Causality Inferenc</p><p><strong>MicroCause</strong>，可以定位到导致微服务故障的根因指标，原理是，先使用路径条件时间序列算法（PCTS）挖掘时间序列之间的因果关系，然后使用随机游走方法（TCORW）来推断因果。TCORW方法综合分析了因果关系，指标异常程度和优先级信息。</p><p>在86个实际故障实例中，MicroCause给出的top 5根因的准确性（AC @ 5）为98.7％。</p></blockquote><h2 id="背景介绍">背景介绍</h2><p>在微服务架构中，一个「应用程序」往往被分解为多个「微服务」。例如，图1展示了，在淘宝购物时，完成用户下单操作需要调用多个微服务。当前针对微服务系统的故障根因问题，学术界已有一些成熟的工作。这些工作主要是通过学习故障如何在微服务之间传播，并找到根因的微服务，例如，图1中Address微服务是导致支付异常的根因。但是，更进一步的根因信息尚不得而知，也就是说是什么导致这个微服务故障？运维人员还是没法明确知道下一步要怎么响应故障。</p><p><img src="./image-20200622132926186.png" /></p><p>图1：在线购物平台中，当接收到用户下单指令后，Order Creation微服务，将调用Inventory，Discount Coupon，Freight，Address这几个微服务来完成用户下单的需求。</p><p>怎么进一步定位微服务故障根因？ 上游组件，下游组件，部署环境。</p><p>对于一个微服务来说，通常有上游组件（例如，微服务，中间件）调用它，并且它可以调用某些下游组件（例如，微服务，中间件）。如图2所示，用户在淘宝下了一个订单后，”Order Creation“微服务将调用“Discount Coupon”微服务查看可用的优惠券，“Discount Coupon”微服务将调用“Inventory”微服务，针对不同的库存计算不同的优惠金额。此外，微服务通常部署在一个或多个容器或虚拟机。</p><figure><img src="./image-20200622132951991.png" alt="图2：““Discount Coupon”微服务实现细节" /><figcaption aria-hidden="true">图2：““Discount Coupon”微服务实现细节</figcaption></figure><p>对每个微服务需要配置监控指标（如图2所示），包括用户可感知的KPI，上游组件相关的指标，下游组件相关的指标，与部署环境相关的指标（例如CPU）。当KPI异常时，通常表示微服务故障，</p><p>运维人员通常会配置一系列监控指标以持续监视每个微服务的性能（如图2所示）。这些指标包括用户可感知的指标KPI，例如用户响应时间(RT)和指标Metrics. Metrics包括与上游组件相关的指标（例如，Web用户的每秒查询（QPS）），下游组件相关指标（例如中间件的RT），与部署环境相关的指标（例如CPU）。</p><p>当KPI异常时表示微服务故障，到底是组件异常还是部署环境异常，可通过观察指标是否异常得到。</p><p>因此，微服务故障的根本原因可以用异常metrics表示。例如，如图2中，由Web RT异常标明的微服务故障是由Web QPS异常引起的。</p><p>因此在该问题中，我们将针对一个微服务故障实例，给出N个metrics，作为故障的Top N根因。通常一个故障实例由三部分信息组成：异常的KPI，异常的微服务ID和异常时间点。</p><h2 id="已有方法">已有方法</h2><p>如表1中所示，目前已有的解决方法主要是利用微服务之间的故障传播关系（cross），通常分为两个阶段：</p><ol type="1"><li>构造依赖关系（relationship learning）：适用pc算法学习微服务之间依赖关系，或者采用系统工具获取依赖关系</li><li>推断根因（rcf）：通过随机游走等基于相关性的方法推断根本原因。</li></ol><figure><img src="./image-20200622133032479.png" alt="表1：微服务系统中已有解决方法" /><figcaption aria-hidden="true">表1：微服务系统中已有解决方法</figcaption></figure><h2 id="研究挑战">研究挑战</h2><p>针对本问题的研究，主要有以下两个挑战：</p><h3 id="挑战一没有现成的方法学习时序间的因果关系">挑战一：没有现成的方法学习时序间的因果关系</h3><p>总结一下：已有的pc算法是基于iid的假设，不能捕捉延迟的因果关系，所以不适合指标因果图构建。</p><p>已有的方法，要解决的问题比较简单，即只用分析微服务间的因果关系，相应的解决方案要么通过系统工具获取依赖关系，要么通过pc算法学习因果关系。</p><p>但是现在，要解决的为问题更有挑战性，除了微服务之间的因果，还想知道一个微服务的指标之间的因果。 所以，提出了一种PC加强版因果挖掘的方法--PCTS。</p><p>PC算法假设不同时刻，指标之间的因果关系是独立的， 以下图为例，PC算法假设17：17和17：18之间，4个指标的因果关系是独立</p><p>但是，时序不是符合这个假设的，经常会有时间差， 以下图为例，如17:17分Web QPS会影响17:18的Web RT</p><p><img src="./img.png" alt="图3：四个时间序列的因果关系图" /> 图中的每一个节点代表了时间序列的某一个时间点，两个节点之间的箭头，标明了两个时间点的数据之间的因果关系</p><p>所以PC算法，学习不到延迟的因果关系</p><h3 id="挑战二因果推断还要考虑指标本身含义">挑战二：因果推断还要考虑指标本身含义</h3><p>做因果推断，除了从数据出发，考虑指标异常相关性，还要考虑指标本身的含义。同一类别指标比不同类别的相关更强。</p><p>现在看一个不失一般性的故障案例：web请求次数过多导致的的响应时间变长</p><figure><img src="./image-20200622132951991.png" alt="图2：Discount Coupon微服务的实现细节" /><figcaption aria-hidden="true">图2：Discount Coupon微服务的实现细节</figcaption></figure><p>以图2为例， 从数据上看，微服务的KPI异常了，也就是Web RT异常了。</p><p>现在把上下游的metric全部load过来， 使用随机游走的方法，分析到的根因是Middleware1 Consumer RT。</p><p><img src="./img_1.png" alt="图4：微服务中的4个监控指标" /> 其中Web RT是KPI，Web QPS, Middleware1 Consumer RT和JVM FGC Time是metrics。</p><p>但实际上，对这个故障实例，根本原因应是上游组件的指标Web QPS。</p><p>随机游走的视野太狭隘了，还应该考虑指标本身含义，同一类别指标比不同类别的相关更强。 也就是说Web RT和Web QPS的相关性更强，和Middleware1 Consumer RT的相关性更弱</p><h2 id="架构设计">架构设计</h2><p>MicroCause的架构图如下（图5），</p><figure><img src="./image-20200622134206479.png" alt="图5:MicroCause架构图" /><figcaption aria-hidden="true">图5:MicroCause架构图</figcaption></figure><ul><li>stage1-指标监控：当KPI异常时，MicroCause将被激活，将故障前数小时的监控指标将用作MicroCause的输入。</li><li>stage2-构建因果图：生成故障因果图&amp;异常检测，可并行<ul><li>使用PCTS算法，从故障kpi和相关指标学习出该故障的故障因果图，</li><li>将故障前数小时的监控指标对metrics做异常检测，并生成异常事件序列。</li></ul></li><li>stage3-因果推断：使用TCORW，输出N个可能的根原。</li></ul><h3 id="故障因果图学习">故障因果图学习</h3><p>针对挑战一，使用PCTS算法学习基于指标的故障因果图。该算法算法分为两步:</p><ol type="1"><li><p>第一步，得到每个时刻指标之间的因果图<span class="math inline">\(G_C\)</span>，基于PC算法的改进，该算法用于学习时间序列的因果图。该算法的结果如图3所示。但是由于我们需要利用指标之间的因果关系进行根因定位，我们对于改进的PC算法的结果进行了调整。 <img src="./img.png" alt="图3：四个时间序列的因果关系图- G_C" /></p></li><li><p>第二步，将<span class="math inline">\(G_C\)</span>转化为节点为指标的因果图<span class="math inline">\(G_{FCG}\)</span>，这样才能做根因定位。理论上，如果<span class="math inline">\(G_C\)</span>中时序A和时序B的时间点中存在一条边，那么<span class="math inline">\(G_{FCG}\)</span>中, 时列A到时序B就有一条边。</p><figure><img src="./image-20200622140031849.png" alt="图8：针对故障实例A,基于PCTS算法生成的因果图" /><figcaption aria-hidden="true">图8：针对故障实例A,基于PCTS算法生成的因果图</figcaption></figure><figure><img src="./image-20200622135001778.png" alt="图6：四个指标间的故障因果图-G_FCG" /><figcaption aria-hidden="true">图6：四个指标间的故障因果图-G_FCG</figcaption></figure></li></ol><h3 id="异常检测">异常检测</h3><p>由于需要对KPI和指标进行异常检测，这里采用的方法是SPOT，可以检测徒增突降。</p><p><span class="math display">\[\eta_{\max}^{i}=\max _{k \in O} \frac{| M_{k}^{i}-\phi_{M_{k}^{i}}|}{\phi_{M^{i}}}\]</span></p><p>其中是时间序列 在时刻的值，是时间序列 在时刻SPOT拟合的阈值。</p><h3 id="面向时间因果的随机游走tcorw">面向时间因果的随机游走(TCORW)</h3><p>总结一下 先构建一个指标(潜在根因得分) = 随机游走的根因概率 + 指标的异常程度 相关指标分为3层，每一层找出top2的两个指标，一起得到6个 按照时间排序，得到前3个或者5个输出</p><p>TCORW算法主要分为三步：</p><ul><li>面向因果的随机游走，</li><li>潜在根因得分</li><li>根因排序</li></ul><h4 id="随机游走">随机游走</h4><p>这一步我们主要利用监控指标之间的因果关系进行分析。首先我们利用模块一中生成的故障因果图进行随机游走。不同于传统的随机游走算法，在此算法中，我们利用偏相关系数（Partial Correlation)来计算转移概率矩阵。与Pearson相关性不同的是，和异常KPI因果性更强的metric指标将具有更高的偏相关系数，而Pearson相关性更注重两个指标之间的相关性。因此和异常KPI因果性更强的metric将在随机游走中获得更高的访问次数。</p><h4 id="潜在根因得分">潜在根因得分</h4><p>这一步中我们利用，随机游走的结果和指标的异常程度对于异常的metric计算潜在根因得分，计算方式如下所示：</p><p><span class="math display">\[\gamma_{i}=\lambda \bar{c}_{i}+(1-\lambda) \bar{\eta}_{\max }^{i}\]</span></p><p>其中是归一化后的随机游走访问次数，是归一化后的异常程度，作为参数，将用于控制着两部分的贡献比例。</p><h4 id="根因排序">根因排序</h4><p>在这一步中，我们首先利用指标间可能的故障传播关系，将指标分为三个级别Level1，Level2，Level3。</p><p>如表2所示，当Level1和Level2中的指标同时发生异常时，我们认为Level1中的指标更有可能是根因。</p><figure><img src="./image-20200622135235013.png" alt="表2：指标分级" /><figcaption aria-hidden="true">表2：指标分级</figcaption></figure><p>基于指标分级信息，指标的异常时间和指标的潜在异常得分我们设计了如下算法给出最后的根因排序。 <img src="./image-20200622135254320.png" /></p><h2 id="数据集和评估指标">数据集和评估指标</h2><p>在此工作中，从2019年9月份到2020年1月份，我们一直某大型在线购物平台中监控超过400种微服务状态。我们收集了86**个真实的在线故障实例作为评估数据集。根据过去的根因分析工作，我们使用AC@k和avg<span class="citation" data-cites="k评估算法给出的Top">@k评估算法给出的Top</span> K个根因的准确性。</p><p><span class="math display">\[ AC@ k=\frac{1}{|A|} \sum_{a \in A}\frac{\sum_{i&lt; k} R^{a}[i] \in V_{r c}^{a}}{\min (k,|\mathrm{V^a}|)} \]</span></p><p><span class="math display">\[A v g @ k=\frac{1}{k} \sum_{1 \leq j \leq k} A C @ j\]</span></p><h2 id="案例分析">案例分析</h2><p>CauseInfer[INFOCOM14]中提到，使用PC算法来学习基于时间序列的因果图时容易生成的孤立子图。在那篇论文中，作者使用领域知识来弥补这一缺陷。 在我们的工作中，同样观察到了这种现象。从图7中，由PC生成的因果图可以看出，异常KPI与根因之间没有路径。</p><p><img src="./image-20200622140008064.png" /> 图7：针对故障实例A,基于PC算法生成的因果图</p><p>但是PCTS可解决这个问题，因为它可以表达时序之间的延迟因果关系（图8）。</p><figure><img src="./image-20200622140031849.png" alt="图8：针对故障实例A,基于PCTS算法生成的因果图" /><figcaption aria-hidden="true">图8：针对故障实例A,基于PCTS算法生成的因果图</figcaption></figure><h2 id="参考">参考</h2><ol type="1"><li><a href="https://wemp.app/posts/6013f2da-c11a-4f6f-b393-2b631c45172a">清华阿里AIOps新作：基于因果分析的微服务内根因定位</a></li><li><a href="https://netman.aiops.org/wp-content/uploads/2020/06/%E5%AD%9F%E5%AA%9B.pdf">causeinfer--paper</a></li><li><a href=""></a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;目录&quot;&gt;目录&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-0-summary/&quot;&gt;chapter0 概览&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;htt</summary>
      
    
    
    
    <category term="AIOps" scheme="https://chiechie.github.io/categories/AIOps/"/>
    
    
    <category term="图数据" scheme="https://chiechie.github.io/tags/%E5%9B%BE%E6%95%B0%E6%8D%AE/"/>
    
    <category term="AIOps" scheme="https://chiechie.github.io/tags/AIOps/"/>
    
    <category term="根因分析" scheme="https://chiechie.github.io/tags/%E6%A0%B9%E5%9B%A0%E5%88%86%E6%9E%90/"/>
    
    <category term="微服务" scheme="https://chiechie.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="因果分析" scheme="https://chiechie.github.io/tags/%E5%9B%A0%E6%9E%9C%E5%88%86%E6%9E%90/"/>
    
    <category term="因果推断" scheme="https://chiechie.github.io/tags/%E5%9B%A0%E6%9E%9C%E6%8E%A8%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>chapter1.4 指标异常关联</title>
    <link href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-1_4-kpi-correlation/"/>
    <id>https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-1_4-kpi-correlation/</id>
    <published>2021-05-21T14:32:17.000Z</published>
    <updated>2021-05-28T13:39:33.559Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录">目录</h2><ul><li><a href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-0-summary/">chapter0 概览</a></li><li><a href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-1-event-generate/">chapter1 故障发现</a><ul><li><a href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-1_1-kpi-detector/">chapter1.1 单指标异常检测</a></li><li><a href="https://chiechie.github.io/2021/03/04/AI/AIOps/AIOps-1_2-fault-prediction/">chapter1.3 故障预测</a></li><li><a href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-1_4-kpi-correlation/">chapter1.4 指标异常关联</a></li><li><a href="https://chiechie.github.io/2021/02/19/AI/AIOps/AIOps-1_5-log-analysis/">chapter1.5 日志聚类</a><ul><li><a href="https://chiechie.github.io/2021/03/04/AI/AIOps/AIOps-1_5_1-log-analysis_logmine/">chapter1.5.1 使用logmine加强版做日志聚类</a></li><li><a href="https://chiechie.github.io/2021/03/04/AI/AIOps/AIOps-1_5_2-log-analysis_meituan/">chapter1.5.2 美团日志聚类</a></li></ul></li></ul></li><li><a href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-2-event-analysis/">chapter2 故障定位</a><ul><li><a href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-2_1-topo-rca/">chapter2.1 微服务系统的故障定位</a><ul><li><a href="https://chiechie.github.io/2021/03/02/AI/AIOps/AIOps-2_1_1-topo-rca-causeinfer-notes1/">chapter2.1.1 CauseInfer1</a></li><li><a href="https://chiechie.github.io/2021/03/03/AI/AIOps/AIOps-2_1_2-topo-rca-causeinfer-notes2/">chapter2.1.2 CauseInfer2</a></li><li><a href="https://chiechie.github.io/2021/03/10/AI/AIOps/AIOps-2_1_3-topo-rca-aiops2020/">chapter2.1.3 AIOps挑战赛2020-获奖方案分享</a></li><li><a href="https://chiechie.github.io/2021/03/09/AI/AIOps/AIOps-2_1_4-topo-rca-aiops2021/">chapter2.1.4 AIOps挑战赛2021-demo方案</a></li><li><a href="https://chiechie.github.io/2021/03/10/AI/AIOps/AIOps-2_1_5-topo-rca-cnsoftbei2020/">chapter2.1.5 N-Softbei2020比赛</a></li><li><a href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-2_1_6-topo-rca-MicroCause">chapter2.1.6 MicroCause</a></li></ul></li><li><a href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-2_2-multi-dimensional-rca/">chapter2.2 多维下钻根因定位</a>: 暂无</li><li><a href="https://chiechie.github.io/2021/03/15/AI/AIOps/AIOps-2_3-trace_rca/">chapter2.3 调用链根因分析</a></li><li><a href="https://chiechie.github.io/2021/04/14/AI/AIOps/AIOps-2_4-metric_event_correlation/">chapter2.4 时间序列关联性分析</a></li></ul></li><li>chapter3 故障恢复</li></ul><p>《KPI波动关联分析助力故障排查-CoFlux》是清华和阿里巴巴公司的最新AIOps合作成果。 CoFlux挖掘KPI之间的异常波动关联，从而帮助运维人员进行故障排查，具体的，波动关联关系结果可以在以下三个方面帮助进行故障排查：报警压缩、推荐TOP-N的可能原因、构建异常波动传播链。该工作对应的论文《</p><h2 id="背景">背景</h2><p>为了对互联网公司的各项服务进行管理，运维人员通常会监控收集成千上万的关键性能指标KPI（Key Performance Indicator），这些KPI（例如服务请求数量、服务请求成功率等）的形式多为时间序列。</p><p>在实际的运维管理工作中，由于各种原因（例如网络中断、恶意攻击等），公司的服务中断不可避免。当服务发生故障时，与故障原因相关的许多KPI数据也会出现异常的波动，而且这些波动也会传递到其他有业务关联或者模块调用关系的KPI，形成报警风暴。报警风暴产生的报警邮件和短信会使得运维人员很头大，因为其中的大量报警都是冗余的，只有少数的报警需要运维人员去关注和解决。此外，发生异常波动的KPI交织在一起，也使得故障排查工作费时费力非常困难。如果可以自动挖掘KPI之间的异常波动关系，就可以帮助运维人员进行更加高效智能地进行故障排查。</p><figure><img src="https://mmbiz.qpic.cn/mmbiz_png/RVMJ0J4z0LzxCnAk4d5fhVM1Gib6rgkCZH8bficj36KtuKiczrZHcqq6NQunbIkMowVN1w0Njyvv3z9AjvsfmD2VA/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h2 id="问题描述">问题描述</h2><figure><img src="https://mmbiz.qpic.cn/mmbiz_png/RVMJ0J4z0LzxCnAk4d5fhVM1Gib6rgkCZH8bficj36KtuKiczrZHcqq6NQunbIkMowVN1w0Njyvv3z9AjvsfmD2VA/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="https://mmbiz.qpic.cn/mmbiz_jpg/RVMJ0J4z0LzxCnAk4d5fhVM1Gib6rgkCZ2oGk0FGldica8CEhhF4yZOTtia9a5mDcpiaP7H1uLj83VKqbfoKVBLXSA/640?wx_fmt=jpeg&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>图1 时间序列，预测序列，波动特征序列</p><p>​ 对于一个时间序列<span class="math inline">\(S = [*s**1**, s**2* *,…, s**m*]\)</span>，<em>si</em>是KPI S在时刻i的数据，m是KPI的长度。对于单一KPI，在数据采集和预处理时要求相邻时刻数据间的时间间隔相同。对于两个KPI，如果时间间隔不同，可以取两个KPI时间间隔的最小公倍数作为公共的时间间隔。KPI S的预测序列P = [*p**1, p2, …, pm*]，<em>pi</em>是<em>si</em>的预测值。因此，一个KPI的预测误差序列F = [*f**1, f2, …, fm*]，<em>fi = si</em> – *p**i*。对于一个KPI，正常的部分是比较准确容易的被预测出来，但是异常波动部分通常都是由一些不可预见的突发因素导致的，很难被预测。因此，预测误差可以很好的用来表示KPI的波动特征，CoFlux使用KPI的预测误差序列来表示该KPI的波动特征。图1 展示了一个时间序列，预测序列，波动特征序列的实例。此外，用于得到预测序列的预测模型以及对应的参数即为特征检测器。</p><figure><img src="https://mmbiz.qpic.cn/mmbiz_jpg/RVMJ0J4z0LzxCnAk4d5fhVM1Gib6rgkCZND6kn9hTDotgLwYhlsUKo8dy8YT6cxv1tic71w6ibSZl3ykZPNIXrsaw/640?wx_fmt=jpeg&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>图2 （左）6个KPI，（右）KPI对应的波动特征曲线</p><p>​ CoFlux的目的是挖掘两个KPI之间的波动关联关系，这种波动关联关系可以帮助进行故障排查。具体的，这种关系包括三个具体问题：1. 两个KPI的波动是否相关？如果相关，2. 波动的先后顺序如何（同时发生或者某根曲线的波动先发生）？3. 波动的方向是否一致（波动方向一致或者相反）？</p><p>​ 利用原始的KPI曲线来判断波动关联关系比较困难，我们可以借助KPI的波动特征曲线。如果两个KPI的波动特征曲线相关（即波动同时发生或者发生时有一定的相位差），那么原始的两个KPI的波动相关。图2展示了6根KPI及其对应的波动特征曲线。从图2中可以看出，<em>K1</em>和<em>K2</em>、<em>K3</em>波动相关，但是与<em>K4</em>波动无关；<em>K1</em>的波动先于<em>K2</em>和<em>K3</em>发生，且波动方向相反；<em>K2</em>和<em>K3</em>的波动同时发生，且波动方向相同。</p><h2 id="挑战">挑战</h2><figure><img src="https://mmbiz.qpic.cn/mmbiz_png/RVMJ0J4z0LzxCnAk4d5fhVM1Gib6rgkCZH8bficj36KtuKiczrZHcqq6NQunbIkMowVN1w0Njyvv3z9AjvsfmD2VA/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>​ 分析判断KPI的波动关联关系，主要有以下三个挑战：</p><p>​ \1. KPI曲线数据众多且曲线特征各异（例如不同的周期性、平稳性、趋势等），因此，没有通用的方法可以对所有的KPI进行波动特征提取。</p><p>​ \2. 基于异常检测结果的波动关联关系分析不合适。基于异常检测的方式需要挑选合适的异常检测算法并进行异常的定义（异常的阈值等），并且二分类的异常结果也比波动特征的信息量要少很多。</p><p>​ \3. 波动关联关系复杂。正如在问题描述中所说，两个KPI间的波动可能有不同的先后顺序以及波动方向，这给判断波动关联关系时带来了更大的挑战。</p><figure><img src="https://mmbiz.qpic.cn/mmbiz_png/RVMJ0J4z0LzxCnAk4d5fhVM1Gib6rgkCZH8bficj36KtuKiczrZHcqq6NQunbIkMowVN1w0Njyvv3z9AjvsfmD2VA/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h2 id="方法">方法</h2><figure><img src="" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>图3 CoFlux方法架构图</p><p>​ CoFlux的输入是两根KPI曲线，输出结果是波动关联关系：两个KPI是否波动相关，如果相关，同时输出波动的先后顺序和波动的方向。算法整体分为两个大的部分：特征工程和相关性测量。</p><p>​ 特征工程的目的是为KPI找到合适的特征检测器，由于不同KPI有不同的特征，单一的特征检测器无法适用于所有的KPI。因此，我们基于两个直观假设：如果可以提供足够多的特征检测算法，那么，1.对于任何一个KPI，总有一个算法可以为该KPI提取到合适的波动特征。2.如果两个KPI波动相关，至少有来自两个KPI的波动特征也相关。相关性测量的目的是根据特征工程得到波动特征计算得到相关性结果。接下来，我们具体介绍特征工程和相关性测量。</p><p><strong>第一步，特征工程</strong>。特征工程主要包括两个步骤，特征提取、特征放大。</p><p>特征提取：如表1，特征提取主要包含了我们预选取的预测模型及参数，总计一共有86个检测器，因此对于一个KPI，我们可以得到86个波动特征。</p><p>表1 CoFlux中的预测模型和检测器</p><p>[img]</p><p>​ 特征放大：一个KPI大部分时间范围内都是正常的，没有很大波动，只有随机的噪声。只有当服务受到影响时，才会产生波动。因此，波动的数量是远远小于正常数据的。为了削弱噪声的影响，我们采用改进版的激励函数：一个KPI的波动程度越大，波动特征也就会被放大的越大，这样就使得我们的波动特征更具区别度，对最后的相关性判断也更有帮助。</p><figure><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>​ <strong>第二步，相关性判断</strong>。对两个KPI的波动特征进行相关性判断时，需要考虑到KPI波动的轻微形变以及相位差。因此，我们挑选Cross-Correlation来测量两个波动特征的相关性结果。</p><figure><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h2 id="实验">实验</h2><figure><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>​ 实验部分包括了两个数据集：数据集1：波动相关的两个KPI的原始曲线数据特征不同；数据集2：波动相关的两个KPI的原始数据曲线特征相似。由于没有专门的处理波动关联分析的算法，我们选取了已有的五种关联分析工作以及变种（一共有7种方法）作为对比算法，表2展示了CoFlux方法和对比算法在两个数据集上的结果。结果表明CoFlux在两个数据集上都比其他的算法效果要更好，且在三个问题上的F1-score分别大于0.84，0.92，和0.95。</p><p>表2 CoFlux和对比方法在两个数据集的结果</p><figure><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>接下来介绍CoFlux在故障排查工作中的应用实例。</p><p>报警压缩：对于大量的KPI，我们首先利用CoFlux计算所有KPI的两两之间的波动相关程度，然后使用K-means进行聚类（K可以使用轮廓系数方法选择）。每一类内的KPI可以当成一个报警簇，在报警的时候当成一个整体进行报警。图4展示了CoFlux利用24根KPI的波动相关结果聚成3类报警簇的实例。</p><figure><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>图4 报警压缩实例热度图表示</p><p>推荐TOPN的可能原因：如图5，对于任一KPI X，我们可以通过CoFlux找到该KPI的TOPN相关的KPI曲线。在进行故障排查时，运维人员可以优先检查这TOPN的曲线来对KPI X进行快速异常分析。</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img" />图5 推荐TOPN的可能原因实例</p><p>​ 构建异常波动传播链：我们可以利用KPI之间的波动传播关系来构建异常波动传播链，这个异常波动传播链可以反映不同KPI之间的波动是如何关联在一起的。图6 展示了CoFlux在数据库服务上自动构建波动传播链的实例，相比较人工的方式，CoFlux在不需要专家领域知识的情况下可以自动准确的构建异常波动传播链。</p><figure><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>图6 （左）人工构建的异常波动传播链；（右）根据CoFlux自动构建的异常波动传播链</p><figure><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h2 id="结论">结论</h2><figure><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>利用KPI的波动特征进行关联分析对于故障排查是非常有用的，本文是服务运维管理领域第一篇定义研究这种波动关联分析的工作。未来的工作计划是采用深度学习的方法更加准确的提取KPI的波动特征。更多细节可以点击“阅读原文”进行阅读。</p><h2 id="参考">参考</h2><ol type="1"><li>CoFlux: Robustly Correlating KPIs by Fluctuations for Service Troubleshooting》发表在IWQoS 2019。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;目录&quot;&gt;目录&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-0-summary/&quot;&gt;chapter0 概览&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;htt</summary>
      
    
    
    
    <category term="AIOps" scheme="https://chiechie.github.io/categories/AIOps/"/>
    
    
    <category term="AIOps" scheme="https://chiechie.github.io/tags/AIOps/"/>
    
    <category term="异常检测" scheme="https://chiechie.github.io/tags/%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B/"/>
    
    <category term="异常分类" scheme="https://chiechie.github.io/tags/%E5%BC%82%E5%B8%B8%E5%88%86%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>chapter1.1 单指标异常检测</title>
    <link href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-1_1-kpi-detector/"/>
    <id>https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-1_1-kpi-detector/</id>
    <published>2021-05-21T08:37:13.000Z</published>
    <updated>2021-05-28T13:39:33.536Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录">目录</h2><ul><li><a href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-0-summary/">chapter0 概览</a></li><li><a href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-1-event-generate/">chapter1 故障发现</a><ul><li><a href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-1_1-kpi-detector/">chapter1.1 单指标异常检测</a></li><li><a href="https://chiechie.github.io/2021/03/04/AI/AIOps/AIOps-1_2-fault-prediction/">chapter1.3 故障预测</a></li><li><a href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-1_4-kpi-correlation/">chapter1.4 指标异常关联</a></li><li><a href="https://chiechie.github.io/2021/02/19/AI/AIOps/AIOps-1_5-log-analysis/">chapter1.5 日志聚类</a><ul><li><a href="https://chiechie.github.io/2021/03/04/AI/AIOps/AIOps-1_5_1-log-analysis_logmine/">chapter1.5.1 使用logmine加强版做日志聚类</a></li><li><a href="https://chiechie.github.io/2021/03/04/AI/AIOps/AIOps-1_5_2-log-analysis_meituan/">chapter1.5.2 美团日志聚类</a></li></ul></li></ul></li><li><a href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-2-event-analysis/">chapter2 故障定位</a><ul><li><a href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-2_1-topo-rca/">chapter2.1 微服务系统的故障定位</a><ul><li><a href="https://chiechie.github.io/2021/03/02/AI/AIOps/AIOps-2_1_1-topo-rca-causeinfer-notes1/">chapter2.1.1 CauseInfer1</a></li><li><a href="https://chiechie.github.io/2021/03/03/AI/AIOps/AIOps-2_1_2-topo-rca-causeinfer-notes2/">chapter2.1.2 CauseInfer2</a></li><li><a href="https://chiechie.github.io/2021/03/10/AI/AIOps/AIOps-2_1_3-topo-rca-aiops2020/">chapter2.1.3 AIOps挑战赛2020-获奖方案分享</a></li><li><a href="https://chiechie.github.io/2021/03/09/AI/AIOps/AIOps-2_1_4-topo-rca-aiops2021/">chapter2.1.4 AIOps挑战赛2021-demo方案</a></li><li><a href="https://chiechie.github.io/2021/03/10/AI/AIOps/AIOps-2_1_5-topo-rca-cnsoftbei2020/">chapter2.1.5 N-Softbei2020比赛</a></li><li><a href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-2_1_6-topo-rca-MicroCause">chapter2.1.6 MicroCause</a></li></ul></li><li><a href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-2_2-multi-dimensional-rca/">chapter2.2 多维下钻根因定位</a>: 暂无</li><li><a href="https://chiechie.github.io/2021/03/15/AI/AIOps/AIOps-2_3-trace_rca/">chapter2.3 调用链根因分析</a></li><li><a href="https://chiechie.github.io/2021/04/14/AI/AIOps/AIOps-2_4-metric_event_correlation/">chapter2.4 时间序列关联性分析</a></li></ul></li><li>chapter3 故障恢复</li></ul><h1 id="异常检测相关问题和技术的综述">异常检测相关问题和技术的综述</h1><h2 id="异常检测的难点">异常检测的难点</h2><h3 id="业务共性">业务共性</h3><ul><li>历史数据有中断—使用正常数据填充</li><li>不同业务曲线对告警的敏感度不一样</li><li>新接进来业务，历史数据太少</li><li>新接业务没有故障</li></ul><h3 id="某些业务特有">某些业务特有</h3><ul><li>整体趋势变化：比如游戏在线人数进入开学季之后会持续走低，业务觉得很正常，不要告警（一般算法都要告警）。</li><li>定时任务日志数：周期性凸起，业务说不要告（但是一般的算法都会告）</li><li>无规律指标的异常识别：常见于刚上线的大区，不稳定。</li><li>周期性毛刺点并且间隔不固定：数据质量问题。</li><li>稀疏数据：比如成交数据，商品只在某个固定时间上架。</li></ul><h2 id="异常分类">异常分类</h2><p>有几类异常：全局异常，条件异常</p><h3 id="全局异常">全局异常</h3><ul><li>全局异常点有点像黑天鹅事件，过去没发生过的。</li></ul><p><img src="./global_anomalie.png" /></p><h3 id="条件异常">条件异常</h3><p>条件异常(contextual or conditional anomalies)：value deviates quite a lot from the rest of the data points，举2个例子：</p><ol type="1"><li>办公室出现了一个穿西装打领带的人，跟我们格格不入，但是放到另外一个context中，比如房屋中介行业很正常</li><li>凌晨销量突然升高</li></ol><p><img src="./img.png" /></p><h3 id="联合异常">联合异常</h3><figure><img src="./img78.png" alt="img.png" /><figcaption aria-hidden="true">img.png</figcaption></figure><p>每一个点不是异常的（既非 contextual 也非 global），但是一起出现就异常了，例如</p><ol type="1"><li>一个小区中，有人去医院很正常，但是整个小区的人同时去医院就不正常了。</li><li>投放广告时，预算增加，曝光和点击同时上升是很正常的。但是曝光增加，点击却下降（市场营销策略失灵--glitch）就意味着有问题，可能是广告中心设置了一个空的广告位，或者将广告曝光给了错误的用户。 <img src="./img0890.png" alt="img.png" /></li></ol><h2 id="用户在使用过程中的疑问">用户在使用过程中的疑问</h2><h3 id="模型开发者">模型开发者</h3><p>模型开发者关心的是</p><ul><li>为什么告警？<ul><li>告警时，知道特征有什么变化，在模型输出的时候，把特征也带上</li></ul></li><li>屏蔽周期性的告警</li></ul><h3 id="模型应用者">模型应用者</h3><p>模型服务的使用者关心的是</p><ul><li>应用时的阈值的修改记录在哪看？</li><li>当前模型是不是最新版本？</li><li>为什么告警？<ul><li>模型开发者需要在输出中加入告警描述字段</li><li>可视化saas，对告警的决策逻辑进行解释，eg上下界</li></ul></li><li>这么多模型，我该选择哪一个？</li><li>业务相关的需求：<ul><li>屏蔽周期性的告警。</li></ul></li></ul><p>[TOC]</p><h1 id="时序异常检测">时序异常检测</h1><p>时序异常检测就是对时间序列数据监测出异常的模式。</p><p>但是，很难用一些策略去构建一个通用的异常检测服务，因为监控指标各异（正常模式各异），异常各异（异常类型多种）。其中，比较难识别的几种曲线和异常如下：</p><h2 id="应用案例">应用案例</h2><h3 id="历史数据有中断缺失">1.历史数据有中断缺失</h3><p>指标：在线数据由于数据质量有中断缺失 正常模式： 历史数据有缺失 检测策略：先使用正常数据填充再检测。</p><figure><img src="../_image/image-20190114173717116.png" alt="image-20190114173717116" /><figcaption aria-hidden="true">image-20190114173717116</figcaption></figure><h3 id="整体趋势变化趋势漂移是正常模式">2.整体趋势变化：趋势漂移是正常模式。</h3><p>指标： 游戏收入 正常模式：游戏收入在开学季趋势漂移（正常模式很奇怪）。 检测策略：学习并且剔除这个趋势漂移。</p><figure><img src="../_image/image-20190114173747851.png" alt="image-20190114173747851" /><figcaption aria-hidden="true">image-20190114173747851</figcaption></figure><h3 id="指标-定时任务日志数">3.指标： 定时任务日志数</h3><p>正常模式：周期性有数据。（正常模式很奇怪） 检测策略：检测规律行为数据缺失</p><figure><img src="../_image/image-20190114174212541.png" alt="image-20190114174212541" /><figcaption aria-hidden="true">image-20190114174212541</figcaption></figure><h3 id="合理范围的突变异常">4.合理范围的突变异常。</h3><p>指标：登录在线等周期性曲线 正常模式：趋势呈周期性 检测策略：检测突变点。</p><figure><img src="../_image/image-20190114181500368.png" alt="image-20190114181500368" /><figcaption aria-hidden="true">image-20190114181500368</figcaption></figure><h3 id="无规律指标识别">5.无规律指标识别。</h3><p>指标：毫无规律指标 正常模式：在一定统计范围内波动 异常检测策略：相对历史分布的极端异常值。</p><figure><img src="../_image/image-20190114181832710.png" alt="image-20190114181832710" /><figcaption aria-hidden="true">image-20190114181832710</figcaption></figure><h3 id="周期性毛刺点-且周期间隔不明显">6.周期性毛刺点-且周期间隔不明显</h3><p>指标：跑批数据 正常模式：周期性毛刺点，但是周期间隔不明显，可能会有偏移（正常模式很奇怪）。 检测策略：使用高斯核函数拟合分布极值？</p><ol type="1"><li>使用dtw去衡量两个窗口的距离，兼容偏差。</li><li>在历史数据中使用滚动窗口的方法，找到一个最近的窗口。</li></ol><figure><img src="/Users/stellazhao/Library/Application%20Support/typora-user-images/image-20190114182211015.png" alt="image-20190114182211015" /><figcaption aria-hidden="true">image-20190114182211015</figcaption></figure><h3 id="周期性跌零数据">7. 周期性跌零数据</h3><p>指标：银行的业务数据 正常模式：周期性跌零，周期性有数据</p><figure><img src="../_image/image-20190114182435743.png" alt="image-20190114182435743" /><figcaption aria-hidden="true">image-20190114182435743</figcaption></figure><p>如何获取曲线的关键特征：</p><ol type="1"><li>周期性： autocorrelation</li><li>周期offset：高斯核函数拟合分布极值</li><li>趋势判断：指数滑动平均</li><li>分析数据极值: 假设检验。</li></ol><figure><img src="../_image/image-20190114190407015.png" alt="image-20190114190407015" /><figcaption aria-hidden="true">image-20190114190407015</figcaption></figure><p>一些架构调研</p><figure><img src="../_image/image-20190703200024522.png" alt="image-20190703200024522" /><figcaption aria-hidden="true">image-20190703200024522</figcaption></figure><figure><img src="../_image/image-20190703200138721.png" alt="image-20190703200138721" /><figcaption aria-hidden="true">image-20190703200138721</figcaption></figure><figure><img src="../_image/image-20190703203239703.png" alt="image-20190703203239703" /><figcaption aria-hidden="true">image-20190703203239703</figcaption></figure><figure><img src="../_image/image-20190703203352352.png" alt="image-20190703203352352" /><figcaption aria-hidden="true">image-20190703203352352</figcaption></figure><h2 id="难点1周期性陡增降引起的误告">难点1：周期性陡增/降引起的误告</h2><p>业务活动特性导致的周期性陡增和陡降怎么避免误告？</p><ol type="1"><li><p>在时间上去收敛</p></li><li><p>使用特征去做模式识别（余弦相似度，比较两两之间的余弦距离），下面用的方法是用余弦相似度去刻画勾勾的形状，但是实时检测的时候，勾勾还没来要怎么做，历史数据里面的勾勾有偏移怎么办？</p></li></ol><p>余弦相似度比欧式距离这种好的地方。。在于可以解决时间上出现偏移的问题。</p><ol type="1"><li><img src="../_image/ali周期性陡降.png" title="fig:" alt="企业微信截图_6db7bb33-160d-471b-a483-05cdc207bc43" /></li></ol><h2 id="总结">总结</h2><p>时序异常检测的难点在于，每一个时刻的异常情况都是context-based，但是这个context非常不好描述。</p><p>这个context需要包含的信息有：</p><ul><li><p>用来刻画该曲线的正常模式的特征（包含是否有趋势周期性，是否有随时间波动的方差， 是否波动剧烈）----（特征选择：这些特征，来描述“异常/正常行为”</p></li><li><p>用来判断该时刻是否异常的参考信息。（特征计算）</p></li></ul><h2 id="曲线平滑对参数极为敏感">曲线平滑对参数极为敏感</h2><h1 id="开发流程">开发流程</h1><figure><img src="../_image/image-20190521143942651.png" alt="image-20190521143942651" /><figcaption aria-hidden="true">image-20190521143942651</figcaption></figure><p>注入的异常为</p><p>由于曲线的毛刺比较多，这里使用局部加权回归的方法。</p><p>但是该方法对参数极为敏感，</p><p>不合适的参数如下：(frac=0.0252, it=2)</p><figure><img src="../_image/image-20190522144016678.png" alt="image-20190522144016678" /><figcaption aria-hidden="true">image-20190522144016678</figcaption></figure><p>合适的参数(frac=0.2, it=2)</p><figure><img src="../_image/image-20190522144141723.png" alt="image-20190522144141723" /><figcaption aria-hidden="true">image-20190522144141723</figcaption></figure><hr /><p>timestamp,dim1,dim2,dim3,dim4,dim5 2018-10-03 17:25:00,16,0,0,0,0</p><p>mcts跑出来的结果</p><p>{"1538558700": [[8.946669749442899, [[0, 0, 0, 0, 3]]]]}</p><h2 id="参考资料">参考资料</h2><ol type="1"><li>https://www.youtube.com/watch?v=pXGqDiE4N0I</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;目录&quot;&gt;目录&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-0-summary/&quot;&gt;chapter0 概览&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;htt</summary>
      
    
    
    
    <category term="AIOps" scheme="https://chiechie.github.io/categories/AIOps/"/>
    
    
    <category term="AIOps" scheme="https://chiechie.github.io/tags/AIOps/"/>
    
    <category term="异常检测" scheme="https://chiechie.github.io/tags/%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B/"/>
    
    <category term="异常分类" scheme="https://chiechie.github.io/tags/%E5%BC%82%E5%B8%B8%E5%88%86%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>chapter2.2 多维下钻根因定位</title>
    <link href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-2_2-multi-dimensional-rca/"/>
    <id>https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-2_2-multi-dimensional-rca/</id>
    <published>2021-05-21T08:05:42.000Z</published>
    <updated>2021-05-28T13:39:33.510Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录">目录</h2><ul><li><a href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-0-summary/">chapter0 概览</a></li><li><a href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-1-event-generate/">chapter1 故障发现</a><ul><li><a href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-1_1-kpi-detector/">chapter1.1 单指标异常检测</a></li><li><a href="https://chiechie.github.io/2021/03/04/AI/AIOps/AIOps-1_2-fault-prediction/">chapter1.3 故障预测</a></li><li><a href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-1_4-kpi-correlation/">chapter1.4 指标异常关联</a></li><li><a href="https://chiechie.github.io/2021/02/19/AI/AIOps/AIOps-1_5-log-analysis/">chapter1.5 日志聚类</a><ul><li><a href="https://chiechie.github.io/2021/03/04/AI/AIOps/AIOps-1_5_1-log-analysis_logmine/">chapter1.5.1 使用logmine加强版做日志聚类</a></li><li><a href="https://chiechie.github.io/2021/03/04/AI/AIOps/AIOps-1_5_2-log-analysis_meituan/">chapter1.5.2 美团日志聚类</a></li></ul></li></ul></li><li><a href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-2-event-analysis/">chapter2 故障定位</a><ul><li><a href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-2_1-topo-rca/">chapter2.1 微服务系统的故障定位</a><ul><li><a href="https://chiechie.github.io/2021/03/02/AI/AIOps/AIOps-2_1_1-topo-rca-causeinfer-notes1/">chapter2.1.1 CauseInfer1</a></li><li><a href="https://chiechie.github.io/2021/03/03/AI/AIOps/AIOps-2_1_2-topo-rca-causeinfer-notes2/">chapter2.1.2 CauseInfer2</a></li><li><a href="https://chiechie.github.io/2021/03/10/AI/AIOps/AIOps-2_1_3-topo-rca-aiops2020/">chapter2.1.3 AIOps挑战赛2020-获奖方案分享</a></li><li><a href="https://chiechie.github.io/2021/03/09/AI/AIOps/AIOps-2_1_4-topo-rca-aiops2021/">chapter2.1.4 AIOps挑战赛2021-demo方案</a></li><li><a href="https://chiechie.github.io/2021/03/10/AI/AIOps/AIOps-2_1_5-topo-rca-cnsoftbei2020/">chapter2.1.5 N-Softbei2020比赛</a></li><li><a href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-2_1_6-topo-rca-MicroCause">chapter2.1.6 MicroCause</a></li></ul></li><li><a href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-2_2-multi-dimensional-rca/">chapter2.2 多维下钻根因定位</a>: 暂无</li><li><a href="https://chiechie.github.io/2021/03/15/AI/AIOps/AIOps-2_3-trace_rca/">chapter2.3 调用链根因分析</a></li><li><a href="https://chiechie.github.io/2021/04/14/AI/AIOps/AIOps-2_4-metric_event_correlation/">chapter2.4 时间序列关联性分析</a></li></ul></li><li>chapter3 故障恢复</li></ul><h1 id="数据分析">数据分析</h1><p>比赛提供了两份数据集 Anomalytime_data_test1.csv: 异常时刻</p><p>2019AIOps_data_test1/*.csv：多维度指标</p><ul><li><p>异常时刻：</p><p>有200个异常时刻，即16个小时的异常。</p></li><li><p>多维指标数据：</p></li></ul><p>测试数据集从2018-09-15 00:00:00,到 2018-09-28 23:55:00，频率为5分钟一条数据，供14天 多维时序：有5个维度 dim1 147 dim2 13 dim3 9 dim4 35 dim5 5</p><p>LEAF的个数，即layer 5的elements个数：</p><ul><li>理论上：按照所有维度值的遍历，理论上应该有212 5760条曲线</li><li>实际上：每天最细粒度有3 0011条曲线</li></ul><p>（paper中做实验的数据LEAF有21600个）</p><p>layer1(<span class="math inline">\(C^1_5 = 5​\)</span>)</p><p>layer2(<span class="math inline">\(C^2_5 = 10\)</span>)</p><p>layer3(<span class="math inline">\(C^3_5 = 10\)</span>)</p><p>layer4((<span class="math inline">\(C^4_5 =5\)</span>个cubics) <span class="math inline">\(B_{H,I,J,K}\)</span>, ...</p><p>layer5 <span class="math inline">\(B_{H,I,J,K,L}\)</span></p><p>处理非均衡样本</p><ol type="1"><li><p>分类问题</p></li><li><p>回归:</p><ol type="1"><li><p>直接使用z_score（异常分值）当成目标</p></li><li><p>使用z_score * 贡献度当目标</p><p>2优于1，why？因为我的z_Score已经除了贡献度的导数</p></li></ol><figure><img src="../_image/多维度分析.png" alt="企业微信截图_15560959535368" /><figcaption aria-hidden="true">企业微信截图_15560959535368</figcaption></figure></li><li><p>异常注入，需满足条件： 异常值引起了整体kpi的异常，</p></li><li><p>什么指标可以刻画某个维度为根因的概率？</p></li></ol><h2 id="百度的方案">百度的方案：</h2><p>参考人工定位过程中的分析思路，提取了两个特征，用来描述某维度是否为根因：</p><ol type="1"><li><p><strong>贡献度，</strong>即该维度PVLost与总PVLost的比例。（这个我们也有）</p></li><li><p><strong>一致度，</strong>即构成该维度的子维度的异常程度的相似度。子维度的异常程度的一致度可通过各子维度异常程度间的变异系数衡量，变异系数越小，则异常程度越一致。(如何衡量小？绝对值还是相对值?)</p><p><a href="https://zhuanlan.zhihu.com/p/48926992" class="uri">https://zhuanlan.zhihu.com/p/48926992</a></p></li></ol><p>[TOC]</p><h1 id="问题描述">问题描述</h1><p><a href="http://iops.ai/competition_detail/?competition_id=8&amp;flag=1" class="uri">http://iops.ai/competition_detail/?competition_id=8&amp;flag=1</a></p><p>在运维场景中对监控指标的多个维度进行根因定位。具体来说，当某个总指标（如总流量）发生异常时，需要快速准确地定位到是哪个交叉维度的细粒度指标（如“省份=北京 &amp; 运营商=联通”的流量）的异常导致的，以便尽快做进一步的修复止损操作。图示如下：</p><h1 id="算法框架">算法框架</h1><p>调研hotspot，整体算法框架如下：</p><figure><img src="../_image/image-20190322210515877.png" alt="image-20190322210515877" /><figcaption aria-hidden="true">image-20190322210515877</figcaption></figure><ul><li>对KPI使用N-sigma进行实时异常检测，如果异常进入2</li><li>开始定位： for layer=1到layer= L:<ul><li>for cuboid in layer=l 的cuboids:</li></ul><ol type="1"><li>剪枝：cuboid l中如果的element的属性值，没有出现在l-1(上一层的Bset中)，那就把elements去掉，剪掉之后生成备选的elements给2用。</li><li>mcts：使用蒙特卡洛搜索树寻找最有可能是根因的维度组合<span class="math inline">\(B_{set}\)</span>，这里的reward function = potential score（potential score表示该维度为故障根因的概率)： for 迭代次数(即蒙特卡洛数的深度) 从1 到 100： 1.select; .... 返回ps最大的维度</li><li>如果potential score超过指定PS或者迭代时长超过给定值或者所有维度都遍历过了，迭代终止，返回ps最大的维度值。</li></ol></li></ul><h1 id="符号说明">符号说明</h1><figure><img src="../_image/image-20190322211056826.png" alt="image-20190322211056826" /><figcaption aria-hidden="true">image-20190322211056826</figcaption></figure><p><span class="math inline">\(e_i\)</span>: $e=(p, i, d, c) $，表示多个属性值的组合，是有具体的取值的.<img src="/Users/stellazhao/Library/Application%20Support/typora-user-images/image-20190322212044105.png" alt="image-20190322212044105" /></p><p><span class="math inline">\(v(e_i)\)</span>:某个维度上指标的实际值。</p><p><span class="math inline">\(f(e_i)\)</span>:某个维度上指标的预测值。</p><p>cuboids:粒度可以任意细，任意粗 $ {B_{P}, B_{P, I}, B_{P, I, D}, }$ layer1，layer2，。。。layer3的解释如下 <img src="../_image/image-20190322220603157.png" alt="image-20190322220603157" /></p><p>data cube: 多维的时序数据</p><p>ps: 衡量一组<span class="math inline">\(S=\{e_i\}\)</span>是根因的概率。</p><p>e的后继结点：<span class="math inline">\(\operatorname{Desc}(e)=\left\{e^{\prime} | e^{\prime} \text { is a descendant of } e\right\}\)</span></p><p>e的后继LEAF结点：<span class="math inline">\(\operatorname{Desc}^{\prime} (e)=\left\{e^{\prime} | e^{\prime} \left(p^{\prime},i^{\prime}, d^{\prime}, c^{\prime}\right) \in L E A F, e^{\prime} \in \operatorname{Desc}(e) \right\}\)</span></p><p>为什么要单独定义LEAF维度？因为它具有可加性，加起来等于它的父节点,如下</p><p><span class="math inline">\(\begin{array}{c}{v(e)=\sum\limits_{e^{\prime} \in D e s c^{\prime}(e)} v\left(e^{\prime}\right)} \\ {\text { e.g. }} \\ {v(\text { Bei jing }, *, *, *)=\sum\limits_{j, k, h} v\left(\text {Beijing}, i_{j}, d_{k}, c_{h}\right),} \\ {\text { Total } P V=v(*, *, *, *)=\sum\limits_{i, j, k, h} v\left(p_{i}, i_{j}, d_{k}, c_{h}\right)}\end{array}\)</span></p><h1 id="ripple-effect">ripple effect</h1><h1 id="potential-score">potential score</h1><h2 id="potential-score的计算公式">potential score的计算公式</h2><ul><li><p>ps的计算公式如下</p><p><span class="math inline">\(\text { Potential Score }=\max \left(1-\frac{d(\vec{v}, \vec{a})}{d(\vec{v}, \vec{f})}, 0\right)\)</span></p><ul><li>a表示某维度确为根因的假设下，LEAF的预期值</li><li>v表示LEAF的真实值</li><li>f表示LEAF的预期值，跟疑似维度无关</li></ul><p>原理就是：比较在疑似故障这个假设下，LEAF相对真实值的区别，跟没有这个假设的前提下，LEAF相对真实值的区别。这两个区别越大，越说明这个假设是显著的。</p><p>强行令他大于0，是因为想取到0~1 之间的值，当成概率。</p></li><li><p>potential score指标计算公式基于的假设是：如果某个维度是故障的根因，那么在这个维度上的kpi的变化率 跟 它 的所有后代维度（descendant）的实际变化率应该是一致的。所以可以使用某个维度的kpi变化率减去后代的kpi变化率，基于这个difference的值算根因概率potential score，这个差值越大，根因概率越小，反之亦然。</p></li><li><p>这个绝对变化是 预测值（历史均值f）和实际值(v）的差(delta)。</p></li></ul><h2 id="potential-score计算步骤示例">potential score计算步骤示例</h2><p>假设现在最细粒度的LEAF维度有如下6个取值</p><p><span class="math inline">\(\vec{y}\)</span>=[(Beijing;Mobile);(Shanghai;Mobile);</p><p>(Guangdong;Mobile); (Bei jing;Unicom);</p><p>(Shanghai;Unicom); (Guangdong;Unicom)].</p><p>那么</p><p><span class="math inline">\(\vec f = (20;15;10;10;25;20)\)</span>,</p><p><span class="math inline">\(\vec v= (14;9;10;7;)\)</span></p><p>对于cuboid--<span class="math inline">\(B_p\)</span>,它包含3个属性值（elements）:</p><p>[(Beijing;*);(Shanghai; *);(Guangdong;*)]</p><p>所以<span class="math inline">\(B_p\)</span>的所有子集有7个，上面3个ele的排列组合：</p><p><span class="math inline">\(S_{p 1}=\{(B e i j i n g, *)\}\)</span>,</p><p>$ S_{p 2}={(, *)}$</p><p>....</p><p><span class="math inline">\(S_{p 7}=\{(\text {Beijing}, *), \quad \text { (Shanghai,*) },(\text {Guangdong,*}) \}\)</span></p><figure><img src="../_image/image-20190322212356628.png" alt="image-20190322212356628" /><figcaption aria-hidden="true">image-20190322212356628</figcaption></figure><ul><li><p>注：上图中箭头左边是预测值(<span class="math inline">\(\vec{f}\)</span>)，右边的是真实值(<span class="math inline">\(\vec v\)</span>)</p><p>现在以<span class="math inline">\(S_{p1}=\{(B e i j i n g, *)\}\)</span>,$为例，算它的根因概率（ps），步骤如下</p></li></ul><p>（1）如果<span class="math inline">\(S_{p1}\)</span>是故障根因，受其影响，最细维度（LEAF）的预测值为：</p><ul><li><p>(a)<span class="math inline">\(S\)</span>不是LEAF</p><ul><li><p><span class="math inline">\(y_i\)</span> 不属于<span class="math inline">\(D e s c^{\prime}(S)\)</span>（非leaf后继）</p><p><span class="math inline">\(a\left(y_{i}\right)=f\left(y_{i}\right)\)</span></p></li><li><p><span class="math inline">\(y_i\)</span> 属于<span class="math inline">\(D e s c^{\prime}(S)\)</span>(leaf后继)</p><p><span class="math inline">\(a\left(y_{i}^{\prime}\right)=f\left(y_{i}^{\prime}\right)-h(x) \times \frac{f\left(y_{i}^{\prime}\right)}{f(x)},(f(x) \neq 0)\)</span></p></li></ul></li><li><p>(b)<span class="math inline">\(S\)</span>是LEAF:</p><ul><li><p><span class="math inline">\(y_i\)</span> 不属于S， <span class="math inline">\(a(y_i)= f(y_i)\)</span></p></li><li><p><span class="math inline">\(y_i\)</span> 属于S，$ a(y_i)= v(y_i)$</p></li></ul></li></ul><p><span class="math inline">\(\vec{a}\left(S_{p 1}\right)=(14,15,10,7,25,20)\)</span></p><ol start="2" type="1"><li>最细维度（LEAF）对应的真实值为:</li></ol><p><span class="math inline">\(\vec{v}=\left[v\left(y_{1}\right), v\left(y_{2}\right), v\left(y_{3}\right), \ldots, v\left(y_{n}\right)\right]\)</span></p><ol start="3" type="1"><li>不管<span class="math inline">\(S_{p1}\)</span>是不是故障根因，最细维度（LEAF）上面的预测值为:</li></ol><p><span class="math inline">\(\vec{f}=\left[f\left(y_{1}\right), f\left(y_{2}\right), f\left(y_{3}\right), \ldots, f\left(y_{n}\right)\right]\)</span></p><h1 id="蒙特卡洛树搜索">蒙特卡洛树搜索</h1><h2 id="符号说明-1">符号说明</h2><p>s： 状态，表示每个cubic中的elemments的集合,如<span class="math inline">\(s\{e_1, e_2, ...\}\)</span></p><p><span class="math inline">\(A(s)\)</span>: 表示状态=s时的所有action集合，值就是其中1个element。表示在s选定之后，还可以往里面加入的elements，这个直接用该cuboid的所有terminal-node。</p><p><span class="math inline">\(N(s)\)</span>: 表示s被访问的次数，s就是维度集合</p><p><span class="math inline">\(N(s;a)\)</span>: 表示边(s;a) 被访问的次数</p><p><span class="math inline">\(Q(s, a)\)</span>: 表示action function，取<span class="math inline">\(s^{\prime}\)</span>的ps和<span class="math inline">\(s^{\prime}\)</span>后继节点的ps的较大值。</p><p><span class="math inline">\(Q(s, a)=\max _{u \in\left\{s^{\prime}\right\} \cup \operatorname{descendent}\left(s^{\prime}\right)} p s(S(u))\)</span></p><p>蒙特卡洛搜索树是强化学习框架下的一种数值算法。</p><p>##执行步骤</p><p>1）选择（selection）：根据当前的s和Q选取最优的action</p><p><span class="math inline">\(a=\underset{a \in A(s)}{\arg \max }\left\{Q(s, a)+C \sqrt{\frac{\ln N(s)}{N(s, a)}}\right\}\)</span></p><p>上式中C(*)表示exploration， 左边的Q表示。</p><p>Upper Confidence Bounds（UCB）</p><p>初始状态N(S, A)=0，怎么办？对这些未被访问的(s,a),赋予一定的访问概率R</p><p><span class="math display">\[R=1-Q\left(s, a_{\max }\right)\]</span>, ---（没懂，为什么Q越大，概率越小）</p><p><span class="math inline">\(a_{max} = \arg\max \limits_{a \in A(s) \cap N(s, a)=0} Q(s, a)\)</span></p><p>selection起始于根节点，终于LEAF节点,这个值得是维度组合的叶子节点，如<span class="math inline">\(\{e_1, \dots, e_{12}\}\)</span></p><p>（错误：注意，终止于LEAF的维度值，而不是树的叶子节点）。</p><figure><img src="../_image/image-20190325133227795.png" alt="image-20190325133227795" /><figcaption aria-hidden="true">image-20190325133227795</figcaption></figure><ol start="2" type="1"><li>expand：起于上一部选定的分支，终于其子节点。在里面加一个ele。</li></ol><figure><img src="../_image/image-20190325133205483.png" alt="image-20190325133205483" /><figcaption aria-hidden="true">image-20190325133205483</figcaption></figure><p>3）evaluation：计算2)<span class="math inline">\(s&#39;\)</span>的ps，Q，和N</p><figure><img src="../_image/image-20190325133147984.png" alt="image-20190325133147984" /><figcaption aria-hidden="true">image-20190325133147984</figcaption></figure><ol start="4" type="1"><li>反向传播（Backpropagation）：更新</li></ol><p>从树的根节点到<span class="math inline">\(s&#39;\)</span>的路径中，更新经过节点的Q和N。</p><p>注意：只有当子节点的Q &gt; 父节点的Q时，我们采取更新父节点的Q</p><figure><img src="../_image/image-20190325133126318.png" alt="image-20190325133126318" /><figcaption aria-hidden="true">image-20190325133126318</figcaption></figure><p>MCTS 将在每个迭代过程（也就是1到4）中增加一个子节点。不过，要注意其实根据不同的应用这里也可以在每个迭代过程中增加超过一个子节点。</p><p>对每个cubic使用MTCS，迭代终止，如果以下条件之一满足：</p><p>1）<span class="math display">\[B S e t=S\]</span> if <span class="math display">\[ p s(S) \geqslant P T\]</span></p><ol start="2" type="1"><li>集合中所有可能的节点（维度值）都已经expanded完了</li></ol><p>3）迭代时长超过给定值（根据经验人工确定）</p><h1 id="层次剪枝">层次剪枝</h1><p>为了进一步减少搜索空间 ，HotSpot使用了层次剪枝的策略。</p><p>这里剪枝不是剪的蒙特卡洛搜索树，是剪的原始的action空间。</p><p>基本原理是：</p><p>由于MTCS是一层一层搜索的cuboids的，在搜索lay较小的cubics，例如（layer=1的<span class="math inline">\(B_p\)</span>）</p><p>就可以剪掉一些ps较小的elements，因为这些elements的后继节点也不太可能是根因。</p><h2 id="符号说明-2">符号说明</h2><p><span class="math display">\[B S e t_{l, B}\]</span>: 使用MCTS对layer=l的cubic B, 算出来的ps最大的Set。</p><p>hotspot剪枝的策略：对每层l中的elements不在<span class="math display">\[B S e t_{l, B}\]</span>, 剪掉。这个策略跟关联规则挖掘中的Apriori Principle很像，叫层次剪枝这个名字是因为利用到了layer的信息。</p><h2 id="示例">示例</h2><figure><img src="../_image/image-20190325135442670.png" alt="image-20190325135442670" /><figcaption aria-hidden="true">image-20190325135442670</figcaption></figure><p>假设第一层的维度MCTS搜索出来的结果： <span class="math display">\[B S e t_{1, B_{P}}=\{(F u j i a n, *),(\text {Jiangsu}, *)\}\]</span>并且<span class="math display">\[ps(B S e t_{l, B_P})=0.5\]</span></p><p><span class="math display">\[B S e t_{1, B_{I}}=\{(*,Mobile),(*, \text {Unicom})\}\]</span>并且<span class="math display">\[ps(B S e t_{l, B_I})=0.32\]</span></p><p>现在MCTS要去搜索第二层了</p><p>就把 (Zhe jiang; Unicom) 和 (Zhe jiang;Unicom)这两个elements给剪掉了，因为他们的父节点 (Zhe jiang;)不在第一层维度的BSets里面，因此，第二层维度，我们只搜索剩下的4个elements，看哪种组合最优可能是根因的维度集合。</p><p>上面的剪枝将蒙特卡洛搜索树的action空间从63减少到了15 (<span class="math inline">\(2^6- 1\)</span> 到 <span class="math inline">\(2^4 - 1\)</span>).</p><p>然后使用蒙特卡洛搜索树搜到得分最高的set，即根因维度</p><p><span class="math display">\[R S e t=B \operatorname{Set}_{2, B_{P, I}}=\{(\text { Fujian, Mobile), (Jiangsu, Unicom) }\}\]</span>且<span class="math display">\[ps(B \operatorname{Set}_{2, B_{P, I}})=1\]</span></p><hr /><p>没想明白</p><ol type="1"><li>要训练集干嘛？</li></ol><figure><img src="../_image/image-20190412193557043.png" alt="image-20190412193557043" /><figcaption aria-hidden="true">image-20190412193557043</figcaption></figure><p>训练集用来当做历史数据，训练一个生成模型，对测试数据进行异常检测。</p><p>2.为什么要注入异常？</p><p>真实中故障很少发生，并且故障根因大部分都比较简单，不会出现多层，多个elemnts是根因的情况。</p><p>那我们研究这些极端情况就缺少样本了，所以需要人工构造。</p><h1 id="技术方案">技术方案</h1><h2 id="整体框架">整体框架</h2><p>1.在训练集上使用ripple effect 注入异常，训练模型（用hotspot跑一下）。~~</p><p>（问题：维度里面的‘unknown’是代表缺失还是汇总‘*’,先默认是缺失）</p><ol type="1"><li>数据清洗，把维度值里面的‘unknown’清除。</li><li>在测试集上，直接使用算法进行根因定位,<ol type="1"><li>样本量太大了，先使用两天的数据跑一下，2018-09-15 00:00:00 到 2018-09-16 23:55:00</li><li>异常检测就使用3-sigma策略，</li></ol></li></ol><ul><li><p><del>对KPI使用N-sigma进行实时异常检测，如果异常进入2</del>（读取给定的label列）</p></li><li><p>开始定位： for layer=1到layer= L:</p><p>​ for cuboid in layer=l 的cuboids:</p><p>如果l&gt;=2, 剪枝：cuboid l中如果的element的属性值，没有出现在l-1(上一层的Bset中)，那就把elements去掉，剪掉之后生成备选的elements给2用。</p><p>否则，直接进入下面：</p><ol type="1"><li><p>mcts：使用蒙特卡洛树搜索寻找最有可能是根因的维度组合<span class="math inline">\(B_{set}\)</span>，这里的reward function = potential score（potential score表示该维度为故障根因的概率)：</p></li><li><p><span class="math inline">\(Q(s, a)=\max _{u \in\left\{s^{\prime}\right\} \cup \operatorname{descendent}\left(s^{\prime}\right)} p s(S(u))\)</span>，初始值就是ps(S(s))</p></li><li><p><span class="math inline">\(a=\underset{a \in A(s)}{\arg \max }\left\{Q(s, a)+C \sqrt{\frac{\ln N(s)}{N(s, a)}}\right\}\)</span></p></li><li><p><span class="math inline">\(a_{max} = \arg\max \limits_{a \in A(s) \cap N(s, a)=0} Q(s, a)\)</span></p></li><li><p>for 迭代次数(即蒙特卡洛树的深度？？) 从1 到 100：</p><ul><li>select：从根节点出发，逐层选择最优的action，深度遍历。</li></ul><p>​ a. 当所有子节点都被访问过，那么根据QCB选择最优的action，并且state跳到子节点（探索和利用），进入下一层select</p><p>​ b. 如果存在一部分没有被访问过的子节点，那么以概率R = 1 - max(Q) 访问未被访问过的子节点中Q值最大的那个</p><ul><li><p>如果选到的action刚好对应着没有被访问过的子节点，select终止</p></li><li><p>如果选到的action还是已经访问过的节点，那么select继续，进入下一层select</p></li></ul><p><span class="math display">\[R=1-Q\left(s, a_{\max }\right)\]</span>, ---（没懂，为什么Q越大，概率越小）</p><p><span class="math inline">\(a_{max} = \arg\max \limits_{a \in A(s) \cap N(s, a)=0} Q(s, a)\)</span></p><p>如果state</p><ol type="1"><li><p>游走到了leaf_node(没有子节点)，那么select终止</p></li><li><p>游走到了某个没有被访问过的节点（即b中的概率选择），那么select终止</p><p>（【原始的mcts】select返回的是node + action</p><p>【hotspot的mcts】seletc返回的是node ）</p></li></ol><ul><li><p>expand：</p><p>【原始的mcts】 将上一步选定的action 和 state对应的node，作为输入，构造mcts的新的node，也就是上一步的node的子节点。</p><p>【hotspot的用法】上一步只选定node ，作为本步的输入，然后从validElementsSets中选择一个ps得分最高的element作为扩展（expand）的edge</p></li><li><p>evaluation(快完成了): 根据expand 中输出的edge，初始化一个新的节点s'，并且计算ps, Q和N</p></li><li><p>backup: 更新s‘的所有父节点的Q和N(对父节点来说，后继节点集合变大了，对应着，它自己的Qvalue也要更新了)</p><p><span class="math inline">\(Q(s, a)=\max _{u \in\left\{s^{\prime}\right\} \cup \operatorname{descendent}\left(s^{\prime}\right)} p s(S(u))\)</span></p></li></ul><p>返回ps最大的维度</p></li><li><p>如果potential score超过指定PS或者迭代时长超过给定值或者所有维度都遍历过了，迭代终止，返回ps最大的维度值。</p></li></ol></li></ul><h2 id="实验记录">实验记录</h2><figure><img src="../image-20190330182941694.png" alt="image-20190330182941694" /><figcaption aria-hidden="true">image-20190330182941694</figcaption></figure><h2 id="一些细节问题">一些细节问题</h2><p>1.关于多维时序存储的问题，需要每一层的维度值对应的时序值都存一遍吗？</p><p>存最细粒度的，需要的时候再算？</p><p>答案：可以，异常时刻少，提前算好各种维度值对应的时序数据不现实（维度组合很大很大），并且大部分有可能白算了 （被剪枝掉了）。</p><p>2.selection里面具体的逻辑是怎样的？</p><figure><img src="../_image/image-20190401212315297.png" alt="image-20190401212315297" /><figcaption aria-hidden="true">image-20190401212315297</figcaption></figure><ol start="3" type="1"><li><p>mcts多轮迭代是不是都是从根节点的初始状态开始的？</p><ul><li><p>不是的，是从根节点的最新状态开始的，迭代始终在维护的是一颗树。每一次迭代，实际上是在构造树的分支，更新叶子节点，以及更新树的所有节点的visit和Qvalue</p></li><li><p>从代码上看，通过保存node，而node会指向parent和children，实际上是保存下来了整棵树的，所以每次迭代，都是基于之前访问记录和Q_value的计算结果上进行的。</p></li></ul></li><li><p>node在什么时候会更新visits和Q_value？unvisited nodes为什么会有Q_value？</p><ol type="1"><li>单个element组成的set的Q_value是有初始值的，</li><li>多个elemnts组成的set的Q_value在evaluation处才会被计算？（不确定）</li><li>selection的第一层循环完成（找到一条直达叶子节点的路径），才更新这条路径上的node的visits。</li></ol></li><li><p>leaf node指的是什么?</p><p>by 作者：</p><p>​ leaf node指的是当前状态（搜索树）下的叶子节点，并不是指的围棋的最后一步。</p><figure><img src="/Users/stellazhao/tencent_workplace/gitlab/dataming/algorithm_doc/process-model/_image/image-20190403150404040.png" alt="image-20190403150404040" /><figcaption aria-hidden="true">image-20190403150404040</figcaption></figure></li></ol><figure><img src="/Users/stellazhao/tencent_workplace/gitlab/dataming/algorithm_doc/process-model/_image/image-20190403150626303.png" alt="image-20190403150626303" /><figcaption aria-hidden="true">image-20190403150626303</figcaption></figure><p>只是应该是当前树上的叶子节点而已。因为要不停的迭代，这里只是阐述一次迭代中的 四步</p><ol start="6" type="1"><li><p>计算ps的效率太低，怎样提升？</p><ol type="1"><li><p>设计缓存机制，给定的属性值组合（LEAF和非LEA）时，提升真实值和预测值的计算效率。</p><ul class="task-list"><li><input type="checkbox" disabled="" checked="" />LEAF: LEAF的真实值和预测值使用频率高，任何属性值的ps都要基于这两个值，==所以把它当成全局变量存在内存中。==</li><li><input type="checkbox" disabled="" />非LEAF:满足可加性（待定）。</li></ul></li><li><p>在计算ps时，LEAF中包含一些无效的属性值（即真实数据中不存在属性值对应的记录）：（4月11日）</p><ol type="1"><li><ul class="task-list"><li><input type="checkbox" disabled="" checked="" />这些LEAF的真实值和预测值都为0，se==t在这些LEAF上的a, v, f 都为置为0==在value上设置就好了，再就是计算a_value，直接置为0</li></ul><p><span class="math inline">\(a\left(y_{i}^{\prime}\right)=f\left(y_{i}^{\prime}\right)-h(x) \times \frac{f\left(y_{i}^{\prime}\right)}{f(x)},(f(x) \neq 0)\)</span></p><p><span class="math display">\[\text { Potential Score }=\max \left(1-\frac{d(\vec{v}, \vec{a})}{d(\vec{v}, \vec{f})}, 0\right)\]</span></p></li></ol></li></ol></li><li><p>怎样在小数据集上先跑通实验验证效果？</p><ul class="task-list"><li><input type="checkbox" disabled="" checked="" />==将dim_dict先设置为3个维度(已经完成)。</li></ul></li><li><p>在mcts第二次迭代的时候，使用ucb挑选子节点，发现已经被访问过的子节点，其父节点的访问次数为0，</p><p>这说明在第四步-反向传播（Backpropagation）：更新从树的根节点到<span class="math inline">\(s&#39;\)</span>的路径中，经过节点的Q和N。==这里更新N没有生效。==</p><ul class="task-list"><li><input type="checkbox" disabled="" checked="" />需要再review一下。(重新看着文章理了一遍框架已经解决，)</li></ul></li></ol><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UCB = c.wins + sqrt(<span class="number">2</span>*log(self.visits)/c.visits)</span><br></pre></td></tr></table></figure></p><p>9.发现state，在新加进来action之后，state非常奇怪，混杂了几种类型的数据（一个tuple，一个unicode）</p><figure><img src="../_image/image-20190410162449504.png" alt="image-20190410162449504" /><figcaption aria-hidden="true">image-20190410162449504</figcaption></figure><ul class="task-list"><li><input type="checkbox" disabled="" checked="" />==于是，1.考虑对维度值构建索引：==</li></ul><p>满足：</p><ol type="1"><li><p>无序</p></li><li><p>同时包含dim和value的信息</p><p>方案：</p><p>“<em>&amp;r01&amp;e1&amp;e&amp;</em>”</p><ol start="2" type="1"><li><ul class="task-list"><li><input type="checkbox" disabled="" checked="" />==对维度值集合构建索引？==这也要考虑一个无序的问题</li></ul>--不用索引，就是维度值索引的list</li></ol></li></ol><p>10.在evaluation里面addchild时发现action为None，说明上面一步（expand）返回了一个None过来。</p><figure><img src="../_image/image-20190410201934530.png" alt="image-20190410201934530" /><figcaption aria-hidden="true">image-20190410201934530</figcaption></figure><p>解决方法：</p><p>在select后面加上了一个break条件：如果该节点已经是叶子节点了</p><p>11。发现返回的BSet的Qvalue是1.0？</p><p>沿着数据处理流，回溯</p><p>Qvalue是1.0--- 》进而观察到ps算的有问题--&gt; 进而发现v和f都是0，。。。---&gt;所有的LEAF都是无效LEAF， 确实取值就是0</p><p>12.【已解决】发现在evaluation里面，计算新node的Q_value时，日志打印出在算一个不存在的维度值(</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*&amp;*&amp;*&amp;*&amp;i01&amp;*&amp;*&amp;*&amp;*</span><br></pre></td></tr></table></figure><p>)的ps.</p><p>什么原因呢？</p><p>因为传进去的self.state是1个list，里面有两个元素， [u'i02&amp;<em>&amp;</em>&amp;<em>&amp;</em>', u'i01&amp;<em>&amp;</em>&amp;<em>&amp;</em>']，在算list的时候，合成1个维度算了。</p><p>思考：这个state表示的是什么？</p><p>应该是从根节点到该节点，所有的边（element）的集合，S.</p><p>那这个新的复合的element，怎么算ps呢？</p><ul class="task-list"><li><input type="checkbox" disabled="" checked="" />==--也当成一个新的element算，value的计算方式要重写==(4月11日，完成)</li></ul><figure><img src="../_image/image-20190410221024023.png" alt="image-20190410221024023" /><figcaption aria-hidden="true">image-20190410221024023</figcaption></figure><p>13 发现对一个layer里一个cuboid的一个element计算ps，花费了大量的时间（算了快1个小时？时间主要耗费在计算a_vector上，无效的LEAF太多）</p><p>[工程]优化方案：</p><ul class="task-list"><li><p><input type="checkbox" disabled="" />1.pandas ---&gt; modin.pandas(在 04上装了一下，但是提示报错, 好烦，不想弄了)</p></li><li><p><input type="checkbox" disabled="" checked="" />2.==使用多进程，算a_value（使用10个核？），但是预期只能提升10倍==。（周末搞一搞）</p></li><li><p><input type="checkbox" disabled="" checked="" />3.将LEAF_value再砍少一点，==valid LEAF在告警时刻做过滤（搞了，现在算一个element的ps要10分钟）==</p><p>做个试验：本来的valid LEAF 有767592个，如果是在报警的时刻做一下过滤，可以减少到3056个；（缩小了100倍，靠谱，可以搞一搞）</p></li></ul><ol start="4" type="1"><li>看了一下文章，优化方向有：</li></ol><ul class="task-list"><li><p><input type="checkbox" disabled="" checked="" />1.mcts中对termina-node的定义，文中是把n设置成了5，==先取2试一试==</p></li><li><p><input type="checkbox" disabled="" checked="" />2.mcts中对迭代次数的定义M，从5到15，==先取5试一试==</p></li><li><p><input type="checkbox" disabled="" checked="" />3.mcts的精度要求PT, 取的0.75，==先取0.6试一试==</p></li><li><p><input type="checkbox" disabled="" checked="" />4.搜索cuboids的层次可以再定义小一点，现在考虑的是2。（但是竞赛中给的故障数据应该是注入的，所以这个改小了应该会极大的降低准确率。）</p><figure><img src="../_image/image-20190415172954161.png" alt="image-20190415172954161" /><figcaption aria-hidden="true">image-20190415172954161</figcaption></figure></li></ul><ol start="5" type="1"><li>mcts重写一遍，按照mcts-survey-master</li></ol><figure><img src="../_image/image-20190412200517988.png" alt="image-20190412200517988" /><figcaption aria-hidden="true">image-20190412200517988</figcaption></figure><ul><li>现在的问题还是跑不动 <code>&#123;       "dim1":[           "i06",           "i38",           "i46",           "i14",           "i02"       ],       "dim2":[           "e08",           "e10"       ],       "dim3":[           "c1",           "c5"       ],       "dim4":[           "p19",           "p10",           "p35"       ],       "dim5":[           "l3",           "l4"       ]   &#125;</code></li></ul><p>15.做层次剪枝的时候，是在每一层的所有cuboid里面取最大的Qvalue对应的一个维度值吗？</p><p>不是哦，每一个cuboid都要保留一组最好的element</p><p>16。代码运行的太慢了？根因在哪里？怎么解决？</p><figure><img src="/Users/stellazhao/Library/Application%20Support/typora-user-images/image-20190417124043016.png" alt="image-20190417124043016" /><figcaption aria-hidden="true">image-20190417124043016</figcaption></figure><p>1.箭头表示调用关系，由调用者指向被调用者；</p><p>2.矩形的左上角显示模块或者函数的名称，右上角显示被调用的次数；</p><p>3.矩形中间显示运行时间和时间百分比</p><p>发现60%的时间都在计算中间数据。</p><p>第一版优化：将getcache和setcache重写，初始化从磁盘载入，后面存内存。</p><p>dataframe在切片的时候，只保留之后的结果， 由60s变成了30s</p><figure><img src="../_image/image-20190417124515665.png" alt="image-20190417124515665" /><figcaption aria-hidden="true">image-20190417124515665</figcaption></figure><p>第二版优化（关键优化）</p><p>将dim的value映射成整数，而后每次计算ps只需要花费6s。</p><p>后面的优化：</p><ol type="1"><li><p>可以看到有一些故障时刻挑选出来的qvalue并不高。</p><p>很有可能的原因是，small_dict_json里面没有包含这些维度的信息。</p><p>后面的解决方案：</p><p>新生成一份small_dict_json</p></li></ol><h2 id="遍历layer1-到layer5的cuboids">遍历layer1 到layer5的cuboids</h2><p>layer1，cuboids-<span class="math inline">\(B_{DIM3}\)</span> <span class="math inline">\(B_{DIM3}\)</span>有 9个elements， <span class="math inline">\(B_{DIM3}\)</span>的集合有<span class="math inline">\(2^9 - 1\)</span>个： <span class="math display">\[S_{dim3,1}=\{(C1, *)\}\]</span> <span class="math display">\[S_{dim3,2}=\{(C2, *)\}\]</span> <span class="math display">\[S_{dim3,3}=\{(C3, *)\}\]</span> <span class="math display">\[...\]</span> <span class="math display">\[S_{dim3,8}=\{(C8, *)\}\]</span> <span class="math display">\[S_{dim3,9}=\{(C1, *), (C2, *)\}\]</span> <span class="math display">\[...\]</span></p><p>而LEAF的elements个数为2125760个（实际远小于这个数，有很多无效的叶子节点。） LEAF的elements长这样 <span class="math display">\[y_{1}=\{(i51, e01, c1,p01, l1)\}\]</span> <span class="math display">\[y_{2}=\{(i49, e01, c1,p01, l1)\}\]</span> <span class="math display">\[...\]</span></p><p>先计算单个elemets组成的集合, 也就是(<span class="math inline">\(S_{dim3,1}\)</span>~ <span class="math inline">\(S_{dim3,8}\)</span>)的ps得分：</p><p>根据hotspot给的计算公式</p><ul><li><p>(a)<span class="math inline">\(S\)</span>不是LEAF</p><ul><li><p><span class="math inline">\(y_i\)</span> 不属于<span class="math inline">\(D e s c^{\prime}(S)\)</span>（非leaf后继）</p><p><span class="math inline">\(a\left(y_{i}\right)=f\left(y_{i}\right)\)</span></p></li><li><p><span class="math inline">\(y_i\)</span> 属于<span class="math inline">\(D e s c^{\prime}(S)\)</span>(leaf后继)</p><p><span class="math inline">\(a\left(y_{i}^{\prime}\right)=f\left(y_{i}^{\prime}\right)-h(x) \times \frac{f\left(y_{i}^{\prime}\right)}{f(x)},(f(x) \neq 0)\)</span></p></li></ul></li><li><p>(b)<span class="math inline">\(S\)</span>是LEAF:</p><ul><li><span class="math inline">\(y_i\)</span> 不属于S， <span class="math inline">\(a(y_i)= f(y_i)\)</span></li><li><span class="math inline">\(y_i\)</span> 属于S，$ a(y_i)= v(y_i)$</li></ul></li></ul><p>可以算出来a</p><p>接下来算ps-score</p><p><span class="math inline">\(\text { Potential Score }=\max \left(1-\frac{d(\vec{v}, \vec{a})}{d(\vec{v}, \vec{f})}, 0\right)\)</span></p><p>每一个</p><figure><img src="../_image/Screenshot-2019-01-22-at-12.48.45-PM.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h2 id="模型的评估指标">模型的评估指标</h2><h3 id="准确性">准确性</h3><p>评估准确性的指标是F-score,该指标是准确率（Precision）和召回率(Recall)综合体现。具体计算如下所示： F-score =(2 ∗ Precision ∗ Recall)/(Precision+ Recall)，其中： Precision ＝ TP / (TP + FP)， Recall = TP / (TP + FN)。</p><p>每个异常时刻都有一个真正的根因集合，记为S<em>，该集合中包含一个或多个属性值组合，参赛队伍的算法输出结果 记为S。对于S</em>中的每一个元素，S中包含其中一个，则算一次true positive （TP），遗漏一个算一次false negative （FN），多出一个S*中不存在的，记一次false positive （FP）。计算出所有异常时刻总的TP、FP、FN，最后得出F-score。</p><h3 id="实时性">实时性</h3><p>决赛阶段除了对结果准确性的考量，还有对实时性的要求；注意预赛阶段不考察实时性。</p><p>实时性的要求方法是：测试数据模拟实时数据，每隔固定时间间隔生成新的数据及该时刻是否异常的信息，参赛者程序需在发生异常后的规定时间内提交该时刻的结果。如，t时刻有异常，则需在t+Δt（如Δt为1分钟）内提交t时刻的定位结果，超出时间则结果无效。</p><h3 id="提交结果">提交结果</h3><p>1 提交结果必须为csv文件, 文件名必须为英文。</p><p>2 csv文件格式示例： timestamp,set 1501475700,a1&amp;b2;a3&amp;b4 1501475760,a1&amp;b2&amp;x3;a4&amp;b5&amp;x6</p><p>注意：提交csv文件 header 必须为：timestamp,set</p><p>这里就是200行时间戳ddd</p><p>3 结果文件中的timestamp列必须与“问题描述”中 表3 中的异常时刻一一对应。</p><p>使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thresh_EEP = <span class="number">0.01</span></span><br><span class="line">Thresh_EP = <span class="number">0.70</span></span><br></pre></td></tr></table></figure><p>找到的根因结果：</p><p>(1539376500, ([[0, 8, 0, 0, 0], [0, 4, 0, 0, 0]], 0.1084257376888971, 0.706533377277869))</p><p>但是使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thresh_EEP &#x3D; 0.00001</span><br><span class="line">Thresh_EP &#x3D; 0.90</span><br></pre></td></tr></table></figure><p>找到的根因结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">28</span>, <span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">29</span>, <span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">19</span>, <span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">15</span>, <span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">21</span>, <span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">11</span>, <span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">13</span>, <span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">17</span>, <span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">22</span>, <span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">24</span>, <span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">18</span>, <span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">14</span>, <span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>]]</span><br></pre></td></tr></table></figure><p>在tableu上分析</p><p>[0,4,0,29,0]自己很异常，并且孩子们都很异常，疑似根因，）</p><figure><img src="../_image/image-20190525161238775.png" alt="image-20190525161238775" /><figcaption aria-hidden="true">image-20190525161238775</figcaption></figure><p>换一个</p><p>[0,4,0,28,0], 异常贡献不到100，这个就不用考虑了</p><figure><img src="../_image/image-20190525161119701.png" alt="image-20190525161119701" /><figcaption aria-hidden="true">image-20190525161119701</figcaption></figure><p>1539567000000</p><figure><img src="../_image/image-20190525211118347.png" alt="image-20190525211118347" /><figcaption aria-hidden="true">image-20190525211118347</figcaption></figure><figure><img src="../_image/image-20190525211508867.png" alt="image-20190525211508867" /><figcaption aria-hidden="true">image-20190525211508867</figcaption></figure><figure><img src="../_image/image-20190525211624239.png" alt="image-20190525211624239" /><figcaption aria-hidden="true">image-20190525211624239</figcaption></figure><p>1540539600000</p><figure><img src="/Users/stellazhao/Library/Application%20Support/typora-user-images/image-20190525213427775.png" alt="image-20190525213427775" /><figcaption aria-hidden="true">image-20190525213427775</figcaption></figure><figure><img src="/Users/stellazhao/Library/Application%20Support/typora-user-images/image-20190525213705573.png" alt="image-20190525213705573" /><figcaption aria-hidden="true">image-20190525213705573</figcaption></figure><figure><img src="/Users/stellazhao/Library/Application%20Support/typora-user-images/image-20190525213819017.png" alt="image-20190525213819017" /><figcaption aria-hidden="true">image-20190525213819017</figcaption></figure><h2 id="代码地址">代码地址</h2><ol type="1"><li>https://github.com/chiechie/ADminer</li></ol><h2 id="参考">参考</h2><ol type="1"><li><a href="https://netman.aiops.org/wp-content/uploads/2018/12/sunyq_IEEEAccess2018_HotSpot.pdf">Yongqian Sun, Youjian Zhao, Ya su, et al., “HotSpot:Anomaly Localization for Additive KPIs withMulti-Dimensional Attributes”, IEEE Access, 2018</a></li><li><a href="https://mp.weixin.qq.com/s/Kj309bzifIv4j80nZbGVZw">2</a></li><li><a href="智能运维%20%7C%20百度多维度数据分析实战">智能运维 | 百度多维度数据分析实战</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;目录&quot;&gt;目录&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-0-summary/&quot;&gt;chapter0 概览&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;htt</summary>
      
    
    
    
    <category term="AIOps" scheme="https://chiechie.github.io/categories/AIOps/"/>
    
    
    <category term="AIOps" scheme="https://chiechie.github.io/tags/AIOps/"/>
    
    <category term="根因分析" scheme="https://chiechie.github.io/tags/%E6%A0%B9%E5%9B%A0%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>chapter2.1 对IT系统进行根因定位</title>
    <link href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-2_1-topo-rca/"/>
    <id>https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-2_1-topo-rca/</id>
    <published>2021-05-21T08:05:13.000Z</published>
    <updated>2021-05-28T13:39:33.545Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录">目录</h2><ul><li><a href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-0-summary/">chapter0 概览</a></li><li><a href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-1-event-generate/">chapter1 故障发现</a><ul><li><a href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-1_1-kpi-detector/">chapter1.1 单指标异常检测</a></li><li><a href="https://chiechie.github.io/2021/03/04/AI/AIOps/AIOps-1_2-fault-prediction/">chapter1.3 故障预测</a></li><li><a href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-1_4-kpi-correlation/">chapter1.4 指标异常关联</a></li><li><a href="https://chiechie.github.io/2021/02/19/AI/AIOps/AIOps-1_5-log-analysis/">chapter1.5 日志聚类</a><ul><li><a href="https://chiechie.github.io/2021/03/04/AI/AIOps/AIOps-1_5_1-log-analysis_logmine/">chapter1.5.1 使用logmine加强版做日志聚类</a></li><li><a href="https://chiechie.github.io/2021/03/04/AI/AIOps/AIOps-1_5_2-log-analysis_meituan/">chapter1.5.2 美团日志聚类</a></li></ul></li></ul></li><li><a href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-2-event-analysis/">chapter2 故障定位</a><ul><li><a href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-2_1-topo-rca/">chapter2.1 微服务系统的故障定位</a><ul><li><a href="https://chiechie.github.io/2021/03/02/AI/AIOps/AIOps-2_1_1-topo-rca-causeinfer-notes1/">chapter2.1.1 CauseInfer1</a></li><li><a href="https://chiechie.github.io/2021/03/03/AI/AIOps/AIOps-2_1_2-topo-rca-causeinfer-notes2/">chapter2.1.2 CauseInfer2</a></li><li><a href="https://chiechie.github.io/2021/03/10/AI/AIOps/AIOps-2_1_3-topo-rca-aiops2020/">chapter2.1.3 AIOps挑战赛2020-获奖方案分享</a></li><li><a href="https://chiechie.github.io/2021/03/09/AI/AIOps/AIOps-2_1_4-topo-rca-aiops2021/">chapter2.1.4 AIOps挑战赛2021-demo方案</a></li><li><a href="https://chiechie.github.io/2021/03/10/AI/AIOps/AIOps-2_1_5-topo-rca-cnsoftbei2020/">chapter2.1.5 N-Softbei2020比赛</a></li><li><a href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-2_1_6-topo-rca-MicroCause">chapter2.1.6 MicroCause</a></li></ul></li><li><a href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-2_2-multi-dimensional-rca/">chapter2.2 多维下钻根因定位</a>: 暂无</li><li><a href="https://chiechie.github.io/2021/03/15/AI/AIOps/AIOps-2_3-trace_rca/">chapter2.3 调用链根因分析</a></li><li><a href="https://chiechie.github.io/2021/04/14/AI/AIOps/AIOps-2_4-metric_event_correlation/">chapter2.4 时间序列关联性分析</a></li></ul></li><li>chapter3 故障恢复</li></ul><h1 id="总结">总结</h1><ol type="1"><li>对于一个微服务系统进行根因分析，主要要解决两个问题，导致故障的根因微服务是哪个？以及导致微服务异常的根因指标是哪个？</li><li>对于第一个问题-导致故障的根因是哪个微服务。还可进一步细分为两种情况：有微服务调用关系和没有服务间的调用关系<ol type="1"><li>有微服务调用关系，这个关系可能是通过系统工具获取比如causeinfer，也可以是手动配置比如cmdb，使用随机游走的方法推断根因。</li><li>没有微服务调用关系，需要通过基于分析的方法去学习关联关系，比如PC算法，PCTS算法，基于时间滞后的关联分析方法，然后使用随机游走方法推断根因。</li></ol></li><li>对于第二个问题-导致微服务异常的根因指标，实际上跟问题1.2是同一个问题，只是加载元数据的时候（关联指标），需要提供上下游组件的指标，以及部署的机器的信息，也可以使用同一套方案。</li><li>总的来说，做故障定位是从粗力度到细力度，先定位根因的微服务，然后再定位导致微服务异常的指标（可能是上下游，也可能是其所在的机器）</li></ol><h1 id="问题分析-和-方案设计">问题分析 和 方案设计</h1><p>一个IT系统包括机器，网络，应用。一个系统中任何一个组成部分都有可能出现故障，从而导致系统瘫痪。 为了减少故障带来的损失，我们需要提前制定预案，即哪些表象对应这哪些故障，从而在故障发生时候，能快速地根据表现识别出故症结所在，进而进行故障处理。</p><p>下面对这个解决方案进行说明。</p><h2 id="因果图-故障传播图">因果图-故障传播图</h2><p>从表象推断出故障症结，可以表达为一个因果推断的需求，即「由果推因」。</p><p>从众多的监控指标，日志信息，事件信息，归纳出导致这些现象出现的原因。</p><p>先分别看故障出现在这三层会出现什么表现（演绎），以及用什么方法去根据表象推断根因（归纳）</p><ul><li>应用之间在逻辑上存在调用关系，应用可能存在一台机器上，也可能是跨机器甚至跨网络。</li><li>应用是部署在机器上的，应用之间的调用关系，实际上会映射为机器之间的网络连接关系。</li><li>应用层故障：如果某个服务异常了，那么所有依赖它的服务的响应时长都会变长。举个例子，如果某个服务b 调用服务a，现在服务a异常了（比如某个操作系统死机了，或者mysql的请求堵塞了）， 就会表现出<ul><li>b服务的响应时间变长；a服务的响应时间变长</li><li>b服务的响应时间进行下钻分析，可以发现b服务依赖的其他服务的响应时间没有异常，只有依赖a服务的响应变长了。</li><li>对a服务的响应进行下钻分析，发现a服务依赖的所有的服务响应时常都是正常的。</li><li>如果服务c 要 调用服务b，然后这个调用并没有用到服务a，服务b的反应就是正常的。 总结一下，每一个服务的健康度是一个量化指标，被调用的成功率，如果成功率低，说明这个服务自身可能异常，也有是依赖服务异常导致。</li></ul></li><li>主机故障：如果某台机器故障，那么部署在这台机器上的所有应用都危险了，进而间接影响到，调用这些应用的调用方，即导致应用的点异常，以及间接导致边异常。</li><li>网络故障：网络故障比如网络设备（网线，机房，交换机，路由器）故障，会导致数据在传输过程中丢失，进而影响到两个跨机器的应用之间的调用，即导致 边异常。</li></ul><p>画一个图表示一下</p><figure><img src="./shougap.png" alt="图1-应用/主机/网络三种故障导致的结果" /><figcaption aria-hidden="true">图1-应用/主机/网络三种故障导致的结果</figcaption></figure><h2 id="根因定位方案工作流图">根因定位方案&amp;工作流图</h2><figure><img src="./workflow.png" alt="image-20210316150746837" /><figcaption aria-hidden="true">image-20210316150746837</figcaption></figure><p><a href="https://docs.qq.com/flowchart/DVGJiQ0NXc2Z3dGVq">流程图-腾讯文档</a></p><h2 id="关于事件的定义">关于事件的定义</h2><p>事件的定义确定了rca的定位能力的颗粒度。 事件定义的粒度越粗糙，定位到的根因就越粗糙，起到的作用就越少。</p><p>粗糙的事件描述只能定位到粗糙的根因。 事件详细到指标的描述，件可以定位到机器的指标根因。 事件详细到指标的描述，件可以定位到细粒度的根因，</p><p>怎么定义一个事件？ 使用 [机器ip, 服务名称, 事件类型/指标名称]</p><h2 id="要用到那些数据">要用到那些数据？</h2><p>要用到的数据包括：日志，指标，事件以及拓扑数据</p><p>但是每条日志/指标/事件，一定是跟一个实体绑定的（某个主机或者某个主机的某个应用）。</p><p>先定位到有问题的实体，然后下钻分析，该实体的哪个指标为根因。</p><p>如何确定一个实体是健康还是异常？两个思路：</p><ul><li>定义应用/中间件的通用的SLO指标，比如调用成功率，调用耗时。</li><li>定义每个应用/中间件最适合的SLO指标，如db最关心锁个数，是否关闭监听。</li></ul><p>此外，还需要用到调用拓扑数据，即服务之间的相互调用关系，或者服务所部署的机器之间的关系，最终得到一个精确的方案。</p><h2 id="构造因果图">构造因果图</h2><p>先要确定这个因果图的skeleton，有哪些节点，什么方向。 构建因果图的skeleton：基于服务调用关系以及其他的先验，基于数据分析因果关系，提取最大子图。 因果图长什么样子： <img src="AIOps-21-topo-rca/yinguotu.png" alt="因果图.png" /></p><p>构建因果图（causality graph）是一个核心技术点。</p><ul><li><p>因果图是一个两层分层的图（two layered hierarchical causality graph）</p><ul><li>较高的层是粗粒度的信息，表示每台机器上每个服务间的依赖关系，也叫服务依赖图（Service Dependency Graph），用于定位到服务级别的cause。</li><li>较低的层是细粒度的信息，表示系统指标组成的细粒度因果关系，也叫指标因果图（Metric Causality Graph），用于定位到指标。</li></ul></li><li><p>构造「服务依赖图」分为两步（就是调用关系）：第一步通过采集器获取边是否存在；第二步通过分析两个服务间的通信延迟相关性（traffic lag correlation）来进一步确定边的方向。</p></li><li><p>构造「指标因果图」：使用人工经验+PC算法。</p><blockquote><p>pc算法是一种发现因果关系的算法，在满足一定的假设前提下，使用的基于统计的方法，推导出因果关系。</p></blockquote></li></ul><h2 id="使用因果图进行推断">使用因果图进行推断</h2><p>当前端的服务可用性指标（SLO）出现异常，就会触发根因分析</p><p>一边定位调用链中的异常服务，一边下钻</p><ul><li>首先：找到异常的服务</li><li>其次：找到服务所在的机器，搜集性能指标，对指标因果图进行深度优先搜索 ，推断本地是哪个指标导致服务性能问题。</li><li>问题： 如果问题是别人造成的，就去找别人的问题：如果根因指标是依赖服务的SLO（注意，用到了调用链关系），这个推断就会继续，传播到远程的依赖的服务。 一直追本溯源，一直到最底层的被调用方，即物理层。</li></ul><p>先定位调用链中异常服务，最后下钻</p><ul><li>定位到有故障的服务</li><li>再去下钻分析，指标层面的故障</li></ul><p>有两种方法: pagerank, 深度优先遍历</p><h3 id="pagerank">PageRank</h3><h1 id="验证方案的可行性">验证方案的可行性</h1><h2 id="调用链路根因分析">1. 调用链路根因分析</h2><figure><img src="./trace_rca.png" alt="调用链路做根因分析.png" /><figcaption aria-hidden="true">调用链路做根因分析.png</figcaption></figure><h2 id="aiops挑战赛">2 AIOps挑战赛</h2><ol type="1"><li>AIOps挑战赛2020-获奖方案分案</li><li>AIOps挑战赛2021-demo方案</li></ol><h1 id="参考资料">参考资料</h1><ol type="1"><li><a href="https://zhuanlan.zhihu.com/p/88173582">知乎-关于因果推断</a></li><li><a href="http://www.stat.cmu.edu/~larry/=sml/Causation.pdf">根因推断的英文原文</a></li><li><a href="http://iops.ai/competition_detail/?competition_id=15&amp;flag=1">AIOps挑战赛2020-官网</a></li><li><a href="https://github.com/chiechie/Insighter">开源代码-Insigter</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;目录&quot;&gt;目录&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-0-summary/&quot;&gt;chapter0 概览&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;htt</summary>
      
    
    
    
    <category term="AIOps" scheme="https://chiechie.github.io/categories/AIOps/"/>
    
    
    <category term="计算机网络" scheme="https://chiechie.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="图数据" scheme="https://chiechie.github.io/tags/%E5%9B%BE%E6%95%B0%E6%8D%AE/"/>
    
    <category term="AIOps" scheme="https://chiechie.github.io/tags/AIOps/"/>
    
    <category term="根因分析" scheme="https://chiechie.github.io/tags/%E6%A0%B9%E5%9B%A0%E5%88%86%E6%9E%90/"/>
    
    <category term="微服务" scheme="https://chiechie.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>chapter2 故障定位</title>
    <link href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-2-event-analysis/"/>
    <id>https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-2-event-analysis/</id>
    <published>2021-05-21T08:04:20.000Z</published>
    <updated>2021-05-28T13:39:33.574Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录">目录</h2><ul><li><a href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-0-summary/">chapter0 概览</a></li><li><a href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-1-event-generate/">chapter1 故障发现</a><ul><li><a href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-1_1-kpi-detector/">chapter1.1 单指标异常检测</a></li><li><a href="https://chiechie.github.io/2021/03/04/AI/AIOps/AIOps-1_2-fault-prediction/">chapter1.3 故障预测</a></li><li><a href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-1_4-kpi-correlation/">chapter1.4 指标异常关联</a></li><li><a href="https://chiechie.github.io/2021/02/19/AI/AIOps/AIOps-1_5-log-analysis/">chapter1.5 日志聚类</a><ul><li><a href="https://chiechie.github.io/2021/03/04/AI/AIOps/AIOps-1_5_1-log-analysis_logmine/">chapter1.5.1 使用logmine加强版做日志聚类</a></li><li><a href="https://chiechie.github.io/2021/03/04/AI/AIOps/AIOps-1_5_2-log-analysis_meituan/">chapter1.5.2 美团日志聚类</a></li></ul></li></ul></li><li><a href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-2-event-analysis/">chapter2 故障定位</a><ul><li><a href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-2_1-topo-rca/">chapter2.1 微服务系统的故障定位</a><ul><li><a href="https://chiechie.github.io/2021/03/02/AI/AIOps/AIOps-2_1_1-topo-rca-causeinfer-notes1/">chapter2.1.1 CauseInfer1</a></li><li><a href="https://chiechie.github.io/2021/03/03/AI/AIOps/AIOps-2_1_2-topo-rca-causeinfer-notes2/">chapter2.1.2 CauseInfer2</a></li><li><a href="https://chiechie.github.io/2021/03/10/AI/AIOps/AIOps-2_1_3-topo-rca-aiops2020/">chapter2.1.3 AIOps挑战赛2020-获奖方案分享</a></li><li><a href="https://chiechie.github.io/2021/03/09/AI/AIOps/AIOps-2_1_4-topo-rca-aiops2021/">chapter2.1.4 AIOps挑战赛2021-demo方案</a></li><li><a href="https://chiechie.github.io/2021/03/10/AI/AIOps/AIOps-2_1_5-topo-rca-cnsoftbei2020/">chapter2.1.5 N-Softbei2020比赛</a></li><li><a href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-2_1_6-topo-rca-MicroCause">chapter2.1.6 MicroCause</a></li></ul></li><li><a href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-2_2-multi-dimensional-rca/">chapter2.2 多维下钻根因定位</a>: 暂无</li><li><a href="https://chiechie.github.io/2021/03/15/AI/AIOps/AIOps-2_3-trace_rca/">chapter2.3 调用链根因分析</a></li><li><a href="https://chiechie.github.io/2021/04/14/AI/AIOps/AIOps-2_4-metric_event_correlation/">chapter2.4 时间序列关联性分析</a></li></ul></li><li>chapter3 故障恢复</li></ul><p>故障定位阶段，需要对众多生成的告警事件进行综合分析，找出事件之间的关联，并且定位出根因。 主要的细分场景包括：</p><ul><li>基于拓扑的故障定位</li><li>多维指标下钻分析</li><li>调用链根因定位</li><li>指标和事件的关联关系</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;目录&quot;&gt;目录&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-0-summary/&quot;&gt;chapter0 概览&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;htt</summary>
      
    
    
    
    <category term="AIOps" scheme="https://chiechie.github.io/categories/AIOps/"/>
    
    
    <category term="AIOps" scheme="https://chiechie.github.io/tags/AIOps/"/>
    
    <category term="异常检测" scheme="https://chiechie.github.io/tags/%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B/"/>
    
    <category term="异常分类" scheme="https://chiechie.github.io/tags/%E5%BC%82%E5%B8%B8%E5%88%86%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>chapter1 故障发现</title>
    <link href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-1-event-generate/"/>
    <id>https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-1-event-generate/</id>
    <published>2021-05-21T08:03:52.000Z</published>
    <updated>2021-05-28T13:39:33.538Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录">目录</h2><ul><li><a href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-0-summary/">chapter0 概览</a></li><li><a href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-1-event-generate/">chapter1 故障发现</a><ul><li><a href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-1_1-kpi-detector/">chapter1.1 单指标异常检测</a></li><li><a href="https://chiechie.github.io/2021/03/04/AI/AIOps/AIOps-1_2-fault-prediction/">chapter1.3 故障预测</a></li><li><a href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-1_4-kpi-correlation/">chapter1.4 指标异常关联</a></li><li><a href="https://chiechie.github.io/2021/02/19/AI/AIOps/AIOps-1_5-log-analysis/">chapter1.5 日志聚类</a><ul><li><a href="https://chiechie.github.io/2021/03/04/AI/AIOps/AIOps-1_5_1-log-analysis_logmine/">chapter1.5.1 使用logmine加强版做日志聚类</a></li><li><a href="https://chiechie.github.io/2021/03/04/AI/AIOps/AIOps-1_5_2-log-analysis_meituan/">chapter1.5.2 美团日志聚类</a></li></ul></li></ul></li><li><a href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-2-event-analysis/">chapter2 故障定位</a><ul><li><a href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-2_1-topo-rca/">chapter2.1 微服务系统的故障定位</a><ul><li><a href="https://chiechie.github.io/2021/03/02/AI/AIOps/AIOps-2_1_1-topo-rca-causeinfer-notes1/">chapter2.1.1 CauseInfer1</a></li><li><a href="https://chiechie.github.io/2021/03/03/AI/AIOps/AIOps-2_1_2-topo-rca-causeinfer-notes2/">chapter2.1.2 CauseInfer2</a></li><li><a href="https://chiechie.github.io/2021/03/10/AI/AIOps/AIOps-2_1_3-topo-rca-aiops2020/">chapter2.1.3 AIOps挑战赛2020-获奖方案分享</a></li><li><a href="https://chiechie.github.io/2021/03/09/AI/AIOps/AIOps-2_1_4-topo-rca-aiops2021/">chapter2.1.4 AIOps挑战赛2021-demo方案</a></li><li><a href="https://chiechie.github.io/2021/03/10/AI/AIOps/AIOps-2_1_5-topo-rca-cnsoftbei2020/">chapter2.1.5 N-Softbei2020比赛</a></li><li><a href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-2_1_6-topo-rca-MicroCause">chapter2.1.6 MicroCause</a></li></ul></li><li><a href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-2_2-multi-dimensional-rca/">chapter2.2 多维下钻根因定位</a>: 暂无</li><li><a href="https://chiechie.github.io/2021/03/15/AI/AIOps/AIOps-2_3-trace_rca/">chapter2.3 调用链根因分析</a></li><li><a href="https://chiechie.github.io/2021/04/14/AI/AIOps/AIOps-2_4-metric_event_correlation/">chapter2.4 时间序列关联性分析</a></li></ul></li><li>chapter3 故障恢复</li></ul><h2 id="概览">概览</h2><p>故障发现阶段，根据监控的对象不同，可以细分为以下场景：</p><ol type="1"><li>单指标异常检测</li><li>多指标异常检测</li><li>故障预测</li><li>指标异常关联</li><li>日志聚类</li><li>调用链异常检测</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;目录&quot;&gt;目录&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-0-summary/&quot;&gt;chapter0 概览&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;htt</summary>
      
    
    
    
    <category term="AIOps" scheme="https://chiechie.github.io/categories/AIOps/"/>
    
    
    <category term="AIOps" scheme="https://chiechie.github.io/tags/AIOps/"/>
    
    <category term="异常检测" scheme="https://chiechie.github.io/tags/%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B/"/>
    
    <category term="异常分类" scheme="https://chiechie.github.io/tags/%E5%BC%82%E5%B8%B8%E5%88%86%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>chapter0 AIOps概览</title>
    <link href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-0-summary/"/>
    <id>https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-0-summary/</id>
    <published>2021-05-21T08:03:30.000Z</published>
    <updated>2021-05-28T13:36:50.069Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录">目录</h2><ul><li><a href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-0-summary/">chapter0 概览</a></li><li><a href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-1-event-generate/">chapter1 故障发现</a><ul><li><a href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-1_1-kpi-detector/">chapter1.1 单指标异常检测</a></li><li><a href="https://chiechie.github.io/2021/03/04/AI/AIOps/AIOps-1_2-fault-prediction/">chapter1.3 故障预测</a></li><li><a href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-1_4-kpi-correlation/">chapter1.4 指标异常关联</a></li><li><a href="https://chiechie.github.io/2021/02/19/AI/AIOps/AIOps-1_5-log-analysis/">chapter1.5 日志聚类</a><ul><li><a href="https://chiechie.github.io/2021/03/04/AI/AIOps/AIOps-1_5_1-log-analysis_logmine/">chapter1.5.1 使用logmine加强版做日志聚类</a></li><li><a href="https://chiechie.github.io/2021/03/04/AI/AIOps/AIOps-1_5_2-log-analysis_meituan/">chapter1.5.2 美团日志聚类</a></li></ul></li></ul></li><li><a href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-2-event-analysis/">chapter2 故障定位</a><ul><li><a href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-2_1-topo-rca/">chapter2.1 微服务系统的故障定位</a><ul><li><a href="https://chiechie.github.io/2021/03/02/AI/AIOps/AIOps-2_1_1-topo-rca-causeinfer-notes1/">chapter2.1.1 CauseInfer1</a></li><li><a href="https://chiechie.github.io/2021/03/03/AI/AIOps/AIOps-2_1_2-topo-rca-causeinfer-notes2/">chapter2.1.2 CauseInfer2</a></li><li><a href="https://chiechie.github.io/2021/03/10/AI/AIOps/AIOps-2_1_3-topo-rca-aiops2020/">chapter2.1.3 AIOps挑战赛2020-获奖方案分享</a></li><li><a href="https://chiechie.github.io/2021/03/09/AI/AIOps/AIOps-2_1_4-topo-rca-aiops2021/">chapter2.1.4 AIOps挑战赛2021-demo方案</a></li><li><a href="https://chiechie.github.io/2021/03/10/AI/AIOps/AIOps-2_1_5-topo-rca-cnsoftbei2020/">chapter2.1.5 N-Softbei2020比赛</a></li><li><a href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-2_1_6-topo-rca-MicroCause">chapter2.1.6 MicroCause</a></li></ul></li><li><a href="https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-2_2-multi-dimensional-rca/">chapter2.2 多维下钻根因定位</a>: 暂无</li><li><a href="https://chiechie.github.io/2021/03/15/AI/AIOps/AIOps-2_3-trace_rca/">chapter2.3 调用链根因分析</a></li><li><a href="https://chiechie.github.io/2021/04/14/AI/AIOps/AIOps-2_4-metric_event_correlation/">chapter2.4 时间序列关联性分析</a></li></ul></li><li>chapter3 故障恢复</li></ul><h2 id="总结">总结</h2><p>智能运维（AIOps）全程是Artificial Intelligent Operation，即，使用AI技术辅助运维。现在业界和学术界研究的比较多的主要有9个场景，这10个场景按照监控的阶段可以分为故障发现阶段（6个场景）和故障分析（4个场景）两类。还有少部分人研究故障恢复阶段的场景，但是，这个场景对数据要求比较高，并且实施过程中，风险比较大，暂时不列出来。</p><p>故障发现阶段，根据监控的对象不同，可以细分为以下场景：</p><ol type="1"><li>单指标异常检测</li><li>多指标异常检测</li><li>故障预测</li><li>指标异常关联</li><li>日志聚类</li><li>调用链异常检测</li></ol><p>故障分析阶段, 根据需要定位的组件对象不同，也可以细分为以下几个场景：</p><ol type="1"><li>微服务系统的故障定位</li><li>多维指标下钻分析</li><li>调用链根因定位</li><li>指标和事件的关联关系</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;目录&quot;&gt;目录&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://chiechie.github.io/2021/05/21/AI/AIOps/AIOps-0-summary/&quot;&gt;chapter0 概览&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;htt</summary>
      
    
    
    
    <category term="AIOps" scheme="https://chiechie.github.io/categories/AIOps/"/>
    
    
    <category term="AIOps" scheme="https://chiechie.github.io/tags/AIOps/"/>
    
    <category term="异常检测" scheme="https://chiechie.github.io/tags/%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B/"/>
    
    <category term="异常分类" scheme="https://chiechie.github.io/tags/%E5%BC%82%E5%B8%B8%E5%88%86%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>对心动的股票分析</title>
    <link href="https://chiechie.github.io/2021/05/21/investment/xindong-analysis/"/>
    <id>https://chiechie.github.io/2021/05/21/investment/xindong-analysis/</id>
    <published>2021-05-21T02:27:35.000Z</published>
    <updated>2021-05-24T01:56:27.161Z</updated>
    
    <content type="html"><![CDATA[<h2 id="key-performance">key performance</h2><ol type="1"><li>2020年TapTap中国版的MAU为2570万，同比增长43.7%；海外版MAU为481万，同步增长330.9%，且去年Q4的平均MAU已经达到了1070万；游戏下载次数为4.1亿，同比增长15.8%；而心动的信息服务收入（主要为TapTap广告业务）为5.2亿，同比增长12.2%。</li><li>4月6日，心动收购云服务提供商LeanCloud，后者2020年超50％收入来自游戏客户。在未来，LeanCloud将与TapTap的开发者服务（TDS）团队一起负责公司面向开发者的产品线。</li><li>LeanCloud是AVOS中国团队在2013年9月发布的应用开发一站式后端服务，为开发者提供数据存储、实时消息、消息推送以及统计分析等服务。AVOS则是由YouTube联合创始人陈士骏和Chad Hurley创建，2011年4月，Chad Hurley和陈士骏从雅虎手中收购了书签网站Delicious，并在此基础上成立了AVOS公司。游戏客户在LeanCloud 2020年的收入里已经占到一半以上。</li></ol><h2 id="参考">参考</h2><ol type="1"><li>游戏葡萄</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;key-performance&quot;&gt;key performance&lt;/h2&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;2020年TapTap中国版的MAU为2570万，同比增长43.7%；海外版MAU为481万，同步增长330.9%，且去年Q4的平均MAU已经达到了10</summary>
      
    
    
    
    <category term="投资" scheme="https://chiechie.github.io/categories/%E6%8A%95%E8%B5%84/"/>
    
    
    <category term="投资" scheme="https://chiechie.github.io/tags/%E6%8A%95%E8%B5%84/"/>
    
    <category term="个股分析" scheme="https://chiechie.github.io/tags/%E4%B8%AA%E8%82%A1%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>对bilibili的股票分析</title>
    <link href="https://chiechie.github.io/2021/05/21/investment/bilibili-analysis/"/>
    <id>https://chiechie.github.io/2021/05/21/investment/bilibili-analysis/</id>
    <published>2021-05-21T02:26:00.000Z</published>
    <updated>2021-05-24T01:56:27.160Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>豪掷8亿拿下《英雄联盟》后，B站又获《守望先锋》数年赛事独播权</p></blockquote><h2 id="key-performance">key performance</h2><blockquote><p>3年来，B站在电竞板块大动作频繁</p></blockquote><ol type="1"><li><p>2018年，B站成立了哔哩哔哩电竞公司，任命前战旗直播CEO陈悠悠出任公司总裁。</p></li><li><p>2019年12月，B站豪掷8亿元的价格，拿下英雄联盟全球总决赛中国地区三年独家直播版权。</p></li><li><p>2020年又与EA合作了2020秋季赛FIFA ONLINE 4顶级职业赛事的电竞活动。</p></li><li><p>2020年8月,拳头也宣布，英雄联盟S10、S11都将在中国举办。两个事件都大力推动了《英雄联盟》中国地区在线上线下的电竞产业发展。</p></li><li><p>2021年，B站拿下《守望先锋联赛》独播权，一方面是因为2年前8亿换来的三年独播权，让B站在电竞板块同时得到了短期流量增长与长线产业布局的收益，而在疫情改变玩家的网络使用习惯后，经验与时机都让B站有更充足的底气采取类似的激进策略拿下《守望先锋》。另一方面，哔哩哔哩电竞或希望其电竞布局，能够突破MOBA类游戏的范围，在FPS等多个电竞品类中建立起自己的用户池，使其在电竞行业中有更细分的竞争力。此前，陈睿将「用户增长」作为公司近期的工作重点，哔哩哔哩电竞的一系列动作也符合该逻辑。</p><blockquote><p>根据此前MakeDataShine公布的全球网络游戏流量份额Top 10，2019-2020年《英雄联盟》与《守望先锋》持续稳定在1、3名,</p></blockquote></li></ol><h2 id="消息来源">消息来源</h2><ol type="1"><li>游戏葡萄</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;豪掷8亿拿下《英雄联盟》后，B站又获《守望先锋》数年赛事独播权&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;key-performance&quot;&gt;key performance&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;3年来，B站在电竞板块大</summary>
      
    
    
    
    <category term="投资" scheme="https://chiechie.github.io/categories/%E6%8A%95%E8%B5%84/"/>
    
    
    <category term="投资" scheme="https://chiechie.github.io/tags/%E6%8A%95%E8%B5%84/"/>
    
    <category term="个股分析" scheme="https://chiechie.github.io/tags/%E4%B8%AA%E8%82%A1%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>从「双缝干涉」到量子力学</title>
    <link href="https://chiechie.github.io/2021/05/21/reading_notes/phisics-yangfengganshe/"/>
    <id>https://chiechie.github.io/2021/05/21/reading_notes/phisics-yangfengganshe/</id>
    <published>2021-05-21T00:24:14.000Z</published>
    <updated>2021-05-24T01:56:27.163Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>20世纪物理学的一些重要进展和矛盾</p></blockquote><h2 id="总结">总结</h2><ol type="1"><li>20世纪物理学的一种根本矛盾，广义相对论和量子理论不自洽，两者不能统一。</li><li>所有的基本粒子，都是宇宙弦的不同振动模式或者振动激发态。弦的不同频率的振动，对应不同质量和能量。</li><li>20世纪30年代，狄拉克把相对论与量子力学放在一起研究，电厂和磁场相互作用时。看电子的行为，发现，电子必须有其反粒子（叫正电子）才能存在。两年后，物理学家们在宇宙射线中发现了正电子。随后这个现象成了一个原理，质子必有反质子，中子必有反中子，所有基本粒子都必须有反粒子，他们才能存在。粒子与反粒子相遇就会彼此湮灭，转化为能量。</li><li>能量从何而来，宇宙的总能量刚好是零，宇宙的物质是由正能量构成，然而所有物质都由引力互相吸引，引力场具有负能量。</li><li>量子电动力学：宇宙暴涨时期，能量密度保持不变，当宇宙体积加倍时，正物质能和负引力能都加倍，总能量保持为零，不破环能量守恒。在这个时期，其实只是一个非常短的瞬间，宇宙的尺度增大了非常多倍，可以制造粒子的总能量就变得非常大。</li><li>量子纠缠，传统的自然科学都标榜自己研究的是东西，是不以人主观意志为转移的客观真理。但是杨氏双缝干涉实验，否定了这个世界观。</li><li>杨氏双缝干涉实验: 一个电子通过两个狭缝往后面走，如果电子只通过其中一个狭缝，看到的图像就不会出现干涉，如果电子同时通过了两个狭缝，看到的图像就会出现干涉，也就是有些地方加强有些地方减弱，类似水波浪。实验的结论就是，有干涉。</li><li>薛定谔的猫：针对解决爱因斯坦和波尔争论的议题，薛定谔设计了第一个“薛定谔的猫”的思想实验。</li><li>带着放毒面具的朋友：1963年，基于薛定谔的猫的实验，维格纳加上了一个“带着放毒面具的朋友”，这个朋友要进到房间里面，观测猫是死还是活。</li><li>维格纳结论是，当朋友的意识被包含在整个系统中时，叠加态就不适用了，即使他本人在门外，箱子里的波函数家还是因为朋友的观测而不断地被触动，因此只有“死猫”和“活猫”两种纯态。为什么人会改变世界的状态？人有意识，也就是分辨心。意识一旦包含在微观系统里，围观系统就会坍塌。维格纳认为，意识可以作用于外部世界，使得波函数坍塌是不足为奇的，因为外部世界的变化可以引起我们意识的改变，根据牛顿第三定律，作用与反作用原理，意识也应当反过来作用与外部世界。量子物理的观察问题中，意识无疑是在触动波函数种起了重要的作用。</li><li>平行宇宙：没有人类的意识观测之前，宇宙在百亿年中，都处于混沌状态，每个粒子都以波函数的形式存在，并无确定的状态和清晰的图像。好比近视眼看到的周围世界只是模糊不清的一片。在人类有意识地观测之时，万物才突然从不确定坍塌到确定的状态，宇宙才突然呈现出清晰的图像，就想戴上眼镜，外界突然清晰呈现那样。</li></ol><h2 id="参考">参考</h2><ol type="1"><li><a href="https://www.youtube.com/watch?v=CBttlMxCUvU&amp;list=PLSFBUUyJDmPhLJZEvBv_amqDqPo9skYD0&amp;index=16">朱清时谈佛学与物理学（上）</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;20世纪物理学的一些重要进展和矛盾&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;20世纪物理学的一种根本矛盾，广义相对论和量子理论不自洽，两者不能统一。&lt;/li&gt;
&lt;li&gt;所有的基</summary>
      
    
    
    
    <category term="阅读" scheme="https://chiechie.github.io/categories/%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="物理" scheme="https://chiechie.github.io/tags/%E7%89%A9%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>以太坊介绍-Patrick访谈</title>
    <link href="https://chiechie.github.io/2021/05/20/reading_notes/intro-to-ether/"/>
    <id>https://chiechie.github.io/2021/05/20/reading_notes/intro-to-ether/</id>
    <published>2021-05-20T02:14:40.000Z</published>
    <updated>2021-05-24T01:56:27.162Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>有空再翻吧</p></blockquote><p>Patrick访谈以太坊组织的研究人员--Justin，内容包括：</p><ul><li>以太坊和比特币的区别</li><li>以太坊平台孵化的项目数量日益增长</li><li>共识算法从工作量证明到权益证明的转变，对以太坊的意义</li></ul><h2 id="key-concepts-of-btc">Key Concepts of BTC</h2><ol type="1"><li>以太坊（Ethereum）诞生于2015年，是一个去中心化的区块链（blockchain），类似的概念是Bitcoin。</li><li>以太坊的平台原生加密货币是以太（Ether），类似的概念是BTC。</li><li>以太坊网络的交易费用每天达到1500w美元，需求日益增长。</li><li>区块链是一个协作平台（coordination platform），让互联网上的人们即使不认识不信任彼此，也可以协作。</li><li>互联网是区块链的第一个阶段，它的使命是冲破地域限制，让世界各地的人可以commmuniction。区块链是对这一能力的拓展，它可以让彼此不信任对方的现状下，人跟人仍然能协作。它的信任来自代码，数学，技术，而不是人。</li><li>货币的本质，一个账本，这个账本记录每个人有多少购买力。比特币本质也是账本，记录每个人有多少比特币。</li><li>关于安全性有哪些必备条件，可参考最安全的东西--时间。时间有3个属性，过去的不可篡改。第二个属性是，当下，对所有人，是一个共享的体验（shared experience）。第三个属性是，未来是确定的，一定会发生，没有任何人能够阻止。</li><li>回到货币上，过去的交易不可篡改，每个人都能信任比特币的状态，不用第三方。绕开审查（Censorship resistance），如果比特币是一个计算器，以太坊就是一个计算机。</li><li>矿工让彼此不信任的人达成共识，理应获得报酬--BTC。</li></ol><h2 id="以太坊">以太坊</h2><ol type="1"><li>what was the original impetus（动力） in early history here?</li><li>Why was Ethereum created?</li><li>What shortcomings of Bitcoin did it seek to address in the early days?</li><li>比特币的编程能力有限，以太坊扩展了变成能力。</li><li>说一说以太坊创始人Vitalik的想法？</li><li>权益证明比工作量证明，更便宜，因为货币的机会成本更低？？啥意思</li><li>The rewards that you get as a validator are, number one, issuance but also these tips that don't get burnt.</li><li>The way that we do ownership really in the crypto world is using public keys. It's basically cryptography that allows you to prove that you're the owner of something. What it means to go buy an NFT is, at the end of the day, to basically change this ledger entry to add your public key as the owner of this hash.</li><li>We have, right now, 130,000 validators that are securing the proof-of-stake in Ethereum. This is going to grow to half a million or even close to a million validators. Another thing that is important is to understand that the proof-of-stake is best-in-class in terms of security. Just to give you one compelling reason for that is that when we have this scarce resource securing your consensus engine being money placed as collateral, you have the option to destroy it fully. If an attacker is in a position to be able to attack Ethereum, meaning that it has amassed all these economic resources, well, as soon as they make an attack, we can penalize them and remove them from the system so the system is self-healing. Actually, because there's only a finite number of ETH out there, we can actually put an upper bound on the number of times that an attacker can successfully make an attack. It's on the order of 10 times</li><li>Be intellectually curious, be intellectually honest in the sense that participating in things that you understand and whenever there's something you don't understand, don't be shy to ask questions. There's a lot of information out there. Actually, on that point a lot of information out there, there's also a lot of bad information out there. This is a very organic, decentralized, and chaotic space.</li></ol><h2 id="参考">参考</h2><ol type="1"><li><a href="https://www.joincolossus.com/episodes/14242194/drake-ethereum-into-the-ether?tab=blocks">Justin Drake - Ethereum: Into the Ether</a></li><li><a href="https://steemit.com/cryptocurrency/@danielzhuang/6uohm9">A Letterto Jamie Dimo-中文</a></li><li><a href="http://www.ceresaig.com/wp-content/uploads/2017/11/A-Letter-to-JP-Morgan-Jamie-Dimon-%E2%80%93-Block-Chain-Crypto-FX.pdf">A Letterto Jamie Dimo-英文</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;有空再翻吧&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Patrick访谈以太坊组织的研究人员--Justin，内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以太坊和比特币的区别&lt;/li&gt;
&lt;li&gt;以太坊平台孵化的项目数量日益增长&lt;/li&gt;
&lt;li&gt;共识算法</summary>
      
    
    
    
    <category term="阅读" scheme="https://chiechie.github.io/categories/%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="区块链" scheme="https://chiechie.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="以太坊" scheme="https://chiechie.github.io/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
    <category term="智能合约" scheme="https://chiechie.github.io/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
    <category term="信任" scheme="https://chiechie.github.io/tags/%E4%BF%A1%E4%BB%BB/"/>
    
  </entry>
  
  <entry>
    <title>关于未来的一点模糊的认知</title>
    <link href="https://chiechie.github.io/2021/05/20/meditation/about-future/"/>
    <id>https://chiechie.github.io/2021/05/20/meditation/about-future/</id>
    <published>2021-05-19T23:13:07.000Z</published>
    <updated>2021-05-24T01:56:27.162Z</updated>
    
    <content type="html"><![CDATA[<h2 id="未来趋势">未来趋势</h2><blockquote><p>大部分是别人说的，只是比较接近我的认知，有待观察验证</p></blockquote><ol type="1"><li>虚拟世界vs物理世界，前者将吞噬掉人类更多的注意力和时间, 终极形态类似「元宇宙」。</li><li>强AI技术首先在游戏领域突破，然后拓展到整个虚拟世界。目前最promising的技术方向是强化学习。</li><li>人对精神层次追求的提升，相关产业包括心理咨询，冥想，正念，哲学教育等</li><li>智能合约孵化的应用普及：去中心化金融，NFT。</li><li>医疗健康产业未来10年有很大市场，包括健康饮食，制药，医疗器械。</li><li>理财教育低龄化，终身化。</li><li>老龄化已成为现实</li><li>量子计算机是趋势？</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;未来趋势&quot;&gt;未来趋势&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;大部分是别人说的，只是比较接近我的认知，有待观察验证&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;虚拟世界vs物理世界，前者将吞噬掉人类更多的注意力和时间, 终极形态类似「</summary>
      
    
    
    
    <category term="沉思录" scheme="https://chiechie.github.io/categories/%E6%B2%89%E6%80%9D%E5%BD%95/"/>
    
    
    <category term="未来趋势" scheme="https://chiechie.github.io/tags/%E6%9C%AA%E6%9D%A5%E8%B6%8B%E5%8A%BF/"/>
    
    <category term="元宇宙" scheme="https://chiechie.github.io/tags/%E5%85%83%E5%AE%87%E5%AE%99/"/>
    
  </entry>
  
  <entry>
    <title>对元宇宙的分析</title>
    <link href="https://chiechie.github.io/2021/05/19/investment/metauniverse/"/>
    <id>https://chiechie.github.io/2021/05/19/investment/metauniverse/</id>
    <published>2021-05-19T13:00:58.000Z</published>
    <updated>2021-05-21T02:24:59.500Z</updated>
    
    <content type="html"><![CDATA[<h2 id="总结">总结</h2><ol type="1"><li>元宇宙（Metaverse）的概念最早来源于尼尔·斯蒂芬森（Neal Stephenson）的著作《雪崩》（Snow Crash），该书首先描述并创造了“元宇宙”的概念和描述。事实上，自上世纪70年代末和80年代初以来，在科技领域中，很多人都是设想过这种属于未来的状态。Metaverse 这个词是由 Meta 和 Verse 组成， Meta 表示超越， verse 的意思是宇宙 universe， 合起来通常表示“超越宇宙”的概念。</li><li>这一概念指向了人类长远的发展目标，我们可以创造属于自己的宇宙，它将平行于现实世界运行、成为一个人造的维度空间。大家认为，互联网的下一个阶段， 是由逻辑端、图像端技术和各种终端硬件支持的虚拟世界。</li><li>关于元宇宙的特点，我们可以大概归纳出一些描述：元宇宙将会是一个始终在线的虚拟世界，有无限量的人们可以同时参与其中。它也会有完整的经济系统在不间断地运行，并且可以跨越真实世界和数字世界。同时，任何基于数据信息的形象、内容、财富等都可以在元宇宙流通，很多人、很多公司都会创作内容、商店以及体验，来让它更繁荣。</li><li>人们所达成的共识是，元宇宙不会一夜之间出现，也不会是仅由一家公司打造和运行的。如同真实世界一样，元宇宙将会由非常多的公司、组织、个人等来共同实现，同时也会由许多独立工具、平台、基础设施、标准和协议等来支持其运行。</li><li>有很多评论和见解认为，元宇宙非常像现在我们定义的“游戏”，因为在目前所有数字化的领域中，游戏似乎也是最接近于元宇宙的一种形式。不过如果我们以一种动态的视角去看这个新物种，我们会发现，之所以我们认为“元宇宙”是一种游戏，是因为我们在使用当下的理解去理解未来的形态。</li><li>“游戏”、“虚拟世界”、“元宇宙”这三个词所代表内容的关系：<ol type="1"><li><p>“虚拟世界”是相对于“真实世界”而言的一个定义；</p></li><li><p>“元宇宙”是在“虚拟世界”这个大类下，对于“可连通信息”的总称；</p></li><li><p>广义来看，“元宇宙”是“虚拟世界”内和每一个参与主体发生交互的信息本身、交互形式、交互过程的总集合；</p></li><li><p>“游戏”是现阶段我们对于“虚拟世界”进行认知与交互的最直接载体；</p></li><li><p>广义来看，“虚拟世界”里的社交、支付、购物等等，都为以“游戏”的形式开展；</p></li><li><p>多个“虚拟世界”之间若不能相互流通，则单个“虚拟世界”或整个集合就不是“元宇宙”；</p><blockquote><p>多个“虚拟世界”不能相互流通的指的是：不能以一个类似于 one-pass 的统一身份进入各个“虚拟世界”、“游戏”、“社交”、“电商”等，同时无法以统一或者一致的经济系统进行交易。</p></blockquote></li></ol></li></ol><h2 id="元宇宙的发展阶段">元宇宙的发展阶段</h2><p>目前根据计算机相关技术和整个互联网的发展轨迹，我们从信息的角度入手，将元宇宙的发展对应地分为几个不同的发展阶段。</p><h3 id="metaverse-0.1-版本底层规则建立1940s---1970s">Metaverse 0.1 版本：底层规则建立（1940s - 1970s）</h3><p><img src="./img_1.png" alt="img_1.png" /> 在这个时期中，电子计算机处于刚被创造出来的发展初期，人们设计了二进制的编码进行储存和计算，并在基础上拓展成“冯·诺伊曼原理”。同时，我们也设定了一套标准的“沟通机制”，用于以代码的方式去和计算机沟通。 也许当时的人们并没有意识到，正是这样的底层规则，不仅开启了虚拟世界的大门，也将两个完全不同的世界从代码输入的那一刻联系了起来。</p><h3 id="metaverse-0.2-版本信息基础传递1980s---1990s">Metaverse 0.2 版本：信息基础传递（1980s - 1990s）</h3><p><img src="./img_2.png" alt="img_2.png" /> 随着计算机技术的不断发展与更新，最初的电子数据交换也发展成了互联网，并逐渐开始其“连接”的使命。在这个过程中，我们从过去的“面对面”信息交流和沟通，变成了基于网络通信的“跨时空”双向信息传递。人们对于一个似乎能“连接万物”的新物种表现出了极高的好奇，几乎疯狂般地向互联网中发送信息，希望和虚拟世界中的一切建立联系。</p><p>不过，那时的网络通信技术有限制，无法像今天一样进行实时流媒体传输，“连接”的效率也有待提升。总的来看，这个阶段中人们对于互联网的态度，更多的是认为这是一个新的机遇，不断地向其中投入资本并产生各种信息数据，希望能借助于“互联网”这一物种产生经济回报，从而在真实世界中实现不同目标和追求。</p><h3 id="metaverse-0.3-版本信息高频交互2000s---至今">Metaverse 0.3 版本：信息高频交互（2000s - 至今）</h3><figure><img src="./img_3.png" alt="img_3.png" /><figcaption aria-hidden="true">img_3.png</figcaption></figure><p>当人们对互联网的使用日益增加，愈发地离不开基于互联网的应用，互联网本身也逐渐作为一种虚拟世界的基础设施存在于真实世界。通信技术的创新和进步也使得人们与虚拟世界发生交互的方式获得了提升，我们能够从虚拟世界中实时地获取高质量的各种流媒体，同时也开始向虚拟世界中贡献了爆发级别数量的信息。</p><p>由于虚拟世界的基础设施贡献，以及产生的各种内容，虚拟世界逐渐开始为真实世界提供价值反哺。在过去，虚拟世界创造价值的目的是为了让真实世界变得更好，但价值反哺意味着，真实世界产生的价值导向变成了让虚拟世界变得更好，也许是更加沉浸、更加自由、更加逼真或者更加与真实世界融合。</p><h3 id="metaverse-未来版本虚拟信息反哺未来">Metaverse 未来版本：虚拟信息反哺（未来）</h3><figure><img src="./img_4.png" alt="img_4.png" /><figcaption aria-hidden="true">img_4.png</figcaption></figure><p>在未来，随着我们对虚拟世界建设的不断增加，虚拟世界的基础设置将会愈发的完善，并会逐渐地展现出更高的支持效率。其中，内容的丰富度和供给效率将会变得远超我们想象，并且会以实时计算、实时生成、实时体验、实时反馈的方式提供，从而让我们认为虚拟世界和真实世界无差别。</p><p>在这个阶段，虚拟世界的经济体系已经“连通”，经济系统也已完善，同时伴随着对应的管理和治理结构，因此我们可认为这个阶段属于“元宇宙”的形态。同时，虚拟世界对真实世界的反哺也到达一个前所未有的高度，人们在真实世界中产生的价值，将会被大规模地投入到虚拟世界中，并更多地在虚拟世界完成经济和社会意义上的循环与迭代。</p><p>以上就是我们认为“元宇宙”发展的不同阶段的状态。需要再次说明和强调的是，“元宇宙”不会一夜之间出现，也不会是仅由一家公司打造和运行的，同时也许也不会有一个非常明确的节点或事件标志着正式的诞生和成熟。</p><h2 id="市场上的先行者">市场上的先行者</h2><ol type="1"><li>一款叫《第二人生》（Second life）的游戏，已经非常接近Metaverse。因为它不是一个专注于“赢”的游戏，而是一个开放式的世界，主旨是探索、交流。</li><li>Roblox是一个儿童版“元宇宙”。儿童和青少年可以在上面创建他们的3D世界和游戏.2021年3月10日，「Roblox」在美国上市，市值400多亿美金。</li><li>2021年3月11日，GreenPark Sports为NBA粉丝创建了一个可以在多人观看NBA球赛的虚拟场景，并获得虚拟奖品例如限量版球衣、鞋帽等；</li><li>2021年3月12日，红杉资本向虚拟办公平台「Gather」投资数百万美元，这平台可以支持虚拟婚礼、虚拟办公等多种场景</li><li>2021年4月13日，字节入局元宇宙赛道，投资中国版Roblox：字节跳动旗下游戏业务品牌朝夕光年正式完成了对有爱互娱的全资收购。</li><li>2021年4月7日「原神」云游戏服务商蔚领时代获1.5亿融资，小米领投，米哈游、中手游参与</li><li>4月15日B站获《守望先锋》数年赛事独播权:哔哩哔哩电竞将负责《守望先锋联赛》2021赛季中国大陆地区赛事的制作开发、赛事转播、商业权益，同时协助赛事在国内的宣发推广。</li></ol><p>B站获《守望先锋》数年赛事独播权；微软以197亿美元收购AI公司Nuance</p><h2 id="看好metaverse的声音">看好Metaverse的声音</h2><ol type="1"><li>VR技术能带来很大的想象空间。VR是实现Metaverse的重要一环，从人工跟踪 、面部跟踪、再到全身追踪，VR可以让人感觉到这个世界里面的化身就是”我“，让个体产生强烈的认同感。这一刻，用户才能真正严肃地对待、去拥抱这个新世界。在VR的新世界里，用户会发现它带来的是更低成本以及更高效的娱乐生活。比如，一秒钟穿梭到高山去滑雪、去音乐节蹦迪、去海滩冲浪等……一晚上可体验不同的生活。</li><li>Metaverse已经有了商业化的可能性。游戏、视频、直播，以及相融合的商业业态都让用户端有机会直接获取规模收入 <img src="./img.png" alt="img.png" /></li><li>虚拟世界正在占据着用户越来越多的时间,比如Roblox的用户使用时长从2019年的137亿小时增长124％至2020的306亿；每日付费用户从2019年的约18.4万增长至2020年的约49.0万。值得注意的是，目前Roblox超过一半用户年龄小于12岁，同时呈现极高的用户粘性。</li></ol><h2 id="反对metaverse的声音">反对Metaverse的声音</h2><ol type="1"><li>技术上还不够成熟，缺乏必要的基础设施、计算处理能力和接口设备。</li></ol><h2 id="参考">参考</h2><ol start="4" type="1"><li>消息来源：游戏葡萄、竞核</li><li><a href="https://www.huxiu.com/article/415676.html">为什么元宇宙Metaverse这两天又不火了？-2021-03-17</a></li><li><a href="http://www.gamelook.com.cn/2021/03/416439">海外分析师：Metaverse将颠覆人类社交方式！</a></li><li><a href="https://www.gcores.com/articles/129199">机器学习、虚拟世界与元宇宙 Metaverse</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;元宇宙（Metaverse）的概念最早来源于尼尔·斯蒂芬森（Neal Stephenson）的著作《雪崩》（Snow Crash），该书首先描述并创造了“元宇宙”的概念和描述。事实上，自上世纪70年代末和</summary>
      
    
    
    
    <category term="投资" scheme="https://chiechie.github.io/categories/%E6%8A%95%E8%B5%84/"/>
    
    
    <category term="未来趋势" scheme="https://chiechie.github.io/tags/%E6%9C%AA%E6%9D%A5%E8%B6%8B%E5%8A%BF/"/>
    
    <category term="投资" scheme="https://chiechie.github.io/tags/%E6%8A%95%E8%B5%84/"/>
    
    <category term="行业分析" scheme="https://chiechie.github.io/tags/%E8%A1%8C%E4%B8%9A%E5%88%86%E6%9E%90/"/>
    
    <category term="元宇宙" scheme="https://chiechie.github.io/tags/%E5%85%83%E5%AE%87%E5%AE%99/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chiechie&#39;s Mini World</title>
  
  <subtitle>Set your course by the stars, not by the lights of passing ships. —— Omar Bradley</subtitle>
  <link href="https://chiechie.github.io/atom.xml" rel="self"/>
  
  <link href="https://chiechie.github.io/"/>
  <updated>2021-06-16T00:43:43.482Z</updated>
  <id>https://chiechie.github.io/</id>
  
  <author>
    <name>Chiechie</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《行为经济学》读书笔记</title>
    <link href="https://chiechie.github.io/2021/06/15/reading_notes/economics/xingweijingjixue/"/>
    <id>https://chiechie.github.io/2021/06/15/reading_notes/economics/xingweijingjixue/</id>
    <published>2021-06-15T01:26:37.000Z</published>
    <updated>2021-06-16T00:43:43.482Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第二部分-社会网络研究">第二部分 社会网络研究</h2><h3 id="选择选择什么">选择选择什么？</h3><ol type="1"><li>“群体选择”:群体之间的竞争可能使内部合作的群体最终胜出并淘汰那些内部不合作的群体.群体选择这一主题兼具个体视角和群体视角。</li><li>"利他行为"：体为增加群体的适存度而降低自己的适存度，它的行为是利他行为。适存度，fitness。</li><li>生物学家怎样测度呢？他们用后代与母代之比，来测度适存度。如果一个人的生存策略有利于增加自己的适存度，那么在一名旁观者看来，他的后代的数目必须逐渐超过母代的数目，这就是繁衍，否则就是消亡</li><li>行为模式是可观测的，行为动机是不可观测的。策略是对行为模式的一种描述，所以是可观测的。心理学描述心理事实，包括动机，通常是不可观测的。如生物学家那样，行为经济学试图做的，是从可观测的“显型”策略，推测那些不可观测的“基因型”行为动机。</li><li>什么是传统：：一切经过长期历史的检验有利于生存和繁衍的知识。其中可交流的传统就是常识。传统的大部分不能交流，只能模仿。</li><li>为什么蚂蚁懂得合作没有淘汰人类？蚂蚁行为的驱动力量是族群惯性，但是他没有灵活性。人的行为驱动力量一部分是族群惯性，一部分是灵活性，这样就使得可以保持创新的同时，又能够保持一定的合作秩序。</li><li>在古尔德看来，漫长的地球演化史，首先由一些漫长的稳态构成，其次，这些稳态之间有一些瞬间的黑天鹅事件打破既有的均衡态，然后陷入新的均衡态，再等待新的黑天鹅事件</li><li>人类的出现，就是其中一个黑天鹅事件，它只占演化史的一个瞬间，是大约900万年以内的事情</li><li>古尔德的结论是：历史从来不是决定论的，由许多偶然因素决定历史路径，只在事后才可能知道 自然选择的力量从来不是惟一的演化力量，类似地，为什么最优越的物种只在以往漫长历史的最后一秒之内发生呢？</li><li>在多因多果的网络里，科学家怎样令人信服地指出哪一条因果链条是最重要的呢？理想方法是通过实验，在实验中，我们可以只让一条因果链发生作用，我们控制所有其他因果关系不许它们起作用</li></ol><h3 id="社会网络研究什么">社会网络研究什么？</h3><ol type="1"><li>如何界定一项知识的重要性？用途。手段的质，依赖于目的本身。</li></ol><h3 id="爱因斯坦的自由论">爱因斯坦的自由论</h3><ol type="1"><li>整体论可爱，但不可信，因为它缺少可行的研究方法。个体论可信，却不可爱。</li><li>爱因斯坦:创造是个体的，从来就是个体行为。但是自由，却是整体的. 没有宽容的社会，个人自由也将消失。</li></ol><h3 id="哈耶克的涌现秩序">哈耶克的涌现秩序</h3><ol type="1"><li><p>马克思理论的逻辑矛盾在第一卷里尚未出现，非要在第二卷和第三卷才成为无法挣脱的内在矛盾。</p></li><li><p>马克思主义和哈耶克：哈耶克论证，没有一个微观主体（个体或群体），不论多么聪明，有能力预先知道从大量哪怕是极简单的微观主体的相互作用中涌现出来的宏观秩序是怎样的。这当然意味着社会计划的不可能和理性的狂妄。理性实在很渺小，不可能完成社会主义者赋予它的资源有效配置任务。</p></li><li><p>人类互动问题的复杂性，时间与结构的复制以及涌现，宏观秩序的涌现</p></li><li><p>哈耶克的“涌现秩序"：演化理论，假以时日，从大量的简单局部结构之间的相互作用中必能涌现更复杂的结构。</p><blockquote><p>涌现秩序的思想，可以溯源至柏格森和怀特海。</p></blockquote></li><li><p>哈耶克使用的关键词：简单结构、复制过程、优胜劣汰、适应性。</p></li><li><p>哈耶克的社会演化基本原理：单子复杂交往涌现宏观秩序的不可预见性。</p><ul><li>“单子”，是莱布尼茨的概念，它们如“素数”那样单纯，具有不可再分性。只不过，莱布尼茨假设单子之间没有交往，而哈耶克假设单子之间的交往是事物演化的原因。</li></ul></li><li><p>多主体仿真（multi-agent simuiation）:一种模拟不确定性的环境与社会变迁的程序.哈佛的诺瓦克小组在使用软件仿真时，将每一个agent都设置为具有最简单的行为规则。然后，一个环境中有数千个agent，相互作用之后，宏观秩序涌现出来，这个宏观秩序是不可预期的。最初研究这样的仿真程序的，是2005年与奥曼分享诺贝尔经济学奖的谢林，这一程序称为“谢林程序”。</p></li><li><p>《解释的程度》中，哈耶克的论述十分接近“社会现象是多因多果”这一见解。</p></li><li><p>《复杂现象论》中，哈耶克全面论述了他设想的演化理论的各要素。目前，社会网络的研究方法，是最适合研究哈耶克涌现秩序的实证方法。</p></li><li><p>对于统计学的看法：本质上是通过消除复杂性来处理大量数据的。</p></li></ol><h2 id="参考">参考</h2><ol type="1"><li>https://weread.qq.com/web/reader/b48321a058a8aeb48d182ac</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第二部分-社会网络研究&quot;&gt;第二部分 社会网络研究&lt;/h2&gt;
&lt;h3 id=&quot;选择选择什么&quot;&gt;选择选择什么？&lt;/h3&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;“群体选择”:群体之间的竞争可能使内部合作的群体最终胜出并淘汰那些内部不合作的群体.群体选择这一主题兼具个体视</summary>
      
    
    
    
    <category term="经济学" scheme="https://chiechie.github.io/categories/%E7%BB%8F%E6%B5%8E%E5%AD%A6/"/>
    
    <category term="行为经济学" scheme="https://chiechie.github.io/categories/%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E8%A1%8C%E4%B8%BA%E7%BB%8F%E6%B5%8E%E5%AD%A6/"/>
    
    <category term="幂律" scheme="https://chiechie.github.io/categories/%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E8%A1%8C%E4%B8%BA%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%B9%82%E5%BE%8B/"/>
    
    <category term="哈耶克" scheme="https://chiechie.github.io/categories/%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E8%A1%8C%E4%B8%BA%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%B9%82%E5%BE%8B/%E5%93%88%E8%80%B6%E5%85%8B/"/>
    
    <category term="群体选择" scheme="https://chiechie.github.io/categories/%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E8%A1%8C%E4%B8%BA%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%B9%82%E5%BE%8B/%E5%93%88%E8%80%B6%E5%85%8B/%E7%BE%A4%E4%BD%93%E9%80%89%E6%8B%A9/"/>
    
    
    <category term="经济学" scheme="https://chiechie.github.io/tags/%E7%BB%8F%E6%B5%8E%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>关于AGI？</title>
    <link href="https://chiechie.github.io/2021/06/10/meditation/about-AGI/"/>
    <id>https://chiechie.github.io/2021/06/10/meditation/about-AGI/</id>
    <published>2021-06-10T09:04:32.000Z</published>
    <updated>2021-06-16T00:43:43.481Z</updated>
    
    <content type="html"><![CDATA[<h2 id="chiechies-reflection">chiechie's reflection</h2><ol type="1"><li>理论突破不是技术爆发的必经之路，很多技术都没有理论，比如古代时候的发明，造船，造纸，造火药，爱迪森发明电灯泡，还有现代的量子计算机和深度学习，理论完备个P。</li><li>大部分发明都是做实验，通过试错迭代而产生的,而很多情况下理论都是滞后的。</li></ol><h2 id="无人驾驶现状">无人驾驶现状</h2><ol type="1"><li>一个技术在工业化生产之前，一般要经历三个阶段, 理论突破，技术验证，工程化<ol type="1"><li>理论突破，科学家在理论上证明其可行性，即产品要达到一个什么样的性能，在技术上是一定可以实现的；</li><li>技术突破，研究机构突破技术实现上壁垒，做出来达到预期的Demo；</li><li>工程化，主要解决产品设计，方案优化，功能完备，性能提升，良品率，鲁棒性，可用性提升，大规模复制的技术准备，成本降低等工程问题。</li></ol></li><li>通用无人驾驶在第一，第二阶段还彻底整明白的情况下，由资本驱动直接进入第三阶段.</li></ol><h2 id="agi的理论先行者">AGI的理论先行者</h2><ol type="1"><li>目前强化学习是最被看好的方向。</li><li>强化学习本质上是演化论的思路，跟自然界一样，给定一个reward，让机器放肆的学习探索。</li><li>目前还需要解决的问题是计算资源的问题。</li><li>自然界的演化大部分时间是平稳状态，只有极少数黑天鹅事件决定了演化的方向。</li><li>在计算机中模拟agent的演化过程，和自然界的演化类似，需要忍受长期的无秩序无进展。</li><li>如果全世界的资源往这方面倾斜，可能可以加快黑天鹅事件出现。</li><li>理论突破不是AGI成熟的必要条件，有可能是2者互相促进发展。</li></ol><h2 id="参考">参考</h2><ol type="1"><li>https://www.zhihu.com/question/404870865/answer/1324577689</li><li>https://www.zhihu.com/question/464616760/answer/1940847401</li><li><a href="https://www.sciencedirect.com/science/article/pii/S0004370221000862">reward is enough ,david silver</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;chiechies-reflection&quot;&gt;chiechie&#39;s reflection&lt;/h2&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;理论突破不是技术爆发的必经之路，很多技术都没有理论，比如古代时候的发明，造船，造纸，造火药，爱迪森发明电灯泡，还有现代的量子计算机</summary>
      
    
    
    
    <category term="沉思录" scheme="https://chiechie.github.io/categories/%E6%B2%89%E6%80%9D%E5%BD%95/"/>
    
    
    <category term="人工智能" scheme="https://chiechie.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    <category term="科技史" scheme="https://chiechie.github.io/tags/%E7%A7%91%E6%8A%80%E5%8F%B2/"/>
    
    <category term="人工智障" scheme="https://chiechie.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E9%9A%9C/"/>
    
  </entry>
  
  <entry>
    <title>哲学导论</title>
    <link href="https://chiechie.github.io/2021/06/10/reading_notes/zhexue/zhexue-summart/"/>
    <id>https://chiechie.github.io/2021/06/10/reading_notes/zhexue/zhexue-summart/</id>
    <published>2021-06-10T09:01:52.000Z</published>
    <updated>2021-06-10T09:30:51.230Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义">定义</h1><p>哲学，就我对这个词的理解来说，乃是某种介乎神学与科学之间的东西。它和神学一样，包含着人类对于那些迄今仍为科学知识所不能肯定之事物的思考；但它又像科学一样，是诉之于人类的理性而不是诉之于权威的，不论是传统的权威还是启示的权威。一切确切的知识都属于科学；一切涉及超乎确切知识之外的教条都属于神学。但介乎神学与科学之间还有一片受到双方攻击的无人之域，这片无人之域就是哲学。---罗素</p><h1 id="哲学的主分支">哲学的主分支</h1><p>哲学的主分支：形而上学、知识论、伦理学、逻辑学和美学 - <a href="https://zh.wikipedia.org/wiki/%E9%82%8F%E8%BC%AF%E5%AD%B8">逻辑学</a> - <a href="https://zh.wikipedia.org/wiki/%E5%BD%A2%E8%80%8C%E4%B8%8A%E5%AD%B8">形而上学</a>/<a href="https://zh.wikipedia.org/wiki/%E5%AE%87%E5%AE%99%E8%AB%96">宇宙论</a> - <a href="https://zh.wikipedia.org/wiki/%E7%9F%A5%E8%AD%98%E8%AB%96">知识论</a> - <a href="https://zh.wikipedia.org/wiki/%E5%80%AB%E7%90%86%E5%AD%B8">伦理学</a>/<a href="https://zh.wikipedia.org/wiki/%E5%83%B9%E5%80%BC%E8%AB%96">价值论</a> - <a href="https://zh.wikipedia.org/wiki/%E7%BE%8E%E5%AD%B8">美学</a></p><h1 id="特殊分支">特殊分支</h1><p>哲学的特殊分支：是交叉学科的哲学研究</p><ul><li><a href="https://zh.wikipedia.org/wiki/%E5%85%83%E5%93%B2%E5%AD%A6">后设哲学</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%AE%97%E6%95%99%E5%93%B2%E5%AD%A6">宗教哲学</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%BF%83%E9%9D%88%E5%93%B2%E5%AD%B8">心灵哲学</a></li><li><a href="https://zh.wikipedia.org/wiki/%E8%AF%AD%E8%A8%80%E5%93%B2%E5%AD%A6">语言哲学</a></li><li><a href="https://zh.wikipedia.org/wiki/%E7%A7%91%E5%AD%A6%E5%93%B2%E5%AD%A6">科学哲学</a>： 现代西方科学哲学的中心是<strong>科学方法论</strong>问题，具体包括<ul><li>统计哲学：统计假设检验（证伪），贝叶斯</li><li>数学哲学：</li><li>物理哲学</li><li>化学哲学</li><li>生物哲学</li><li>医学哲学</li><li>心理学哲学</li><li>经济哲学</li><li>社会科学哲学：代表之一---马克思</li></ul></li><li><a href="https://zh.wikipedia.org/wiki/%E6%94%BF%E6%B2%BB%E5%93%B2%E5%AD%A6">政治哲学</a></li><li><a href="https://zh.wikipedia.org/wiki/%E6%B3%95%E5%BE%8B%E5%93%B2%E5%AD%B8">法律哲学</a></li></ul><h2 id="西方的-科学哲学发展路径">西方的 科学哲学发展路径</h2><ul><li>到50年代为止，一直是作为“正统科学哲学”的<strong>逻辑实证主义</strong>占主导地位</li><li>从50年代末兴起，在60年代发展和完成：波普尔的<strong>批判理性主义</strong>和库恩-拉卡托斯的<strong>历史主义</strong>科学哲学。</li><li>至70年代，出现了两股发展趋势。<ul><li>一股是<strong>复兴</strong>和发展“正统<strong>的”逻辑主义方法论</strong>，</li><li>另一股就是法伊尔阿本德的<strong>非理性主义</strong>，它在很大程度上是把<strong>历史主义</strong>中的非理性因素贯彻到极端程度的产物。</li></ul></li><li>本书对<strong>逻辑实证主义</strong>和波普尔、库恩与拉卡托斯的科学哲学等现代西方理性主义科学哲学学说一一作了批判，并在这个批判中阐发了自己的科学哲学——<strong>多元主义方法论</strong></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;定义&quot;&gt;定义&lt;/h1&gt;
&lt;p&gt;哲学，就我对这个词的理解来说，乃是某种介乎神学与科学之间的东西。它和神学一样，包含着人类对于那些迄今仍为科学知识所不能肯定之事物的思考；但它又像科学一样，是诉之于人类的理性而不是诉之于权威的，不论是传统的权威还是启示的权威。一切确切的</summary>
      
    
    
    
    <category term="阅读" scheme="https://chiechie.github.io/categories/%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="哲学" scheme="https://chiechie.github.io/tags/%E5%93%B2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>概率图模型</title>
    <link href="https://chiechie.github.io/2021/06/10/AI/machine_learning/gailvtu/"/>
    <id>https://chiechie.github.io/2021/06/10/AI/machine_learning/gailvtu/</id>
    <published>2021-06-10T08:52:21.000Z</published>
    <updated>2021-06-11T01:19:42.404Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念">基本概念</h2><p>概率图模型(Probabilistic Graphical Model，PGM)，简称图模型(Graphical Model，GM)，首先是一种概率模型，其次，它用图结构描述多个随机变量之间的依赖关系，它是研究高维空间中的概率模型的一种有用工具。</p><p>概率图模型有三个基本问题: 表示问题，学习问题和推断问题</p><p><img src="https://img.mubu.com/document_image/e3036b4e-18d3-4e73-b996-eafe4a4c08d1-3380623.jpg" /></p><h3 id="表示问题">1. 表示问题</h3><p>表示问题，即对于一个概率模型，如何通过图结构来描述变量之间的依赖关系。</p><h4 id="有向图模型directed-graphical-model">有向图模型(Directed Graphical model)</h4><p>有向图模型(Directed Graphical model)，也称为贝叶斯网络(Bayesian Network)，或信念网络(Belief Network，BN)，是指用有向图来表示概率分布的图模型。</p><figure><img src="https://img.mubu.com/document_image/75c9420a-058f-4005-a4b2-4609e7987c1b-3380623.jpg" alt="贝叶斯网络" /><figcaption aria-hidden="true">贝叶斯网络</figcaption></figure><p>条件独立性在贝叶斯网络中，如果两个节点是直接连接的，它们肯定是非条件独立的，是直接因果关系。父节点是“因”，子节点是“果”。</p><p>很多经典的机器学习模型可以使用有向图模型来描述，比如 - 朴素贝叶斯分类器 - 隐马尔可夫模型 - 深度信念网络(sigmoid 信念网络)</p><h4 id="无向图模型">无向图模型</h4><p>无向图模型也称为马尔可夫随机场(Markov Random Field，MRF)或 马尔可夫网络(Markov Network)，是一类用无向图来描述一组具有局部马尔 可夫性质的随机向量 X 的联合概率分布的模型。</p><figure><img src="https://img.mubu.com/document_image/85a18510-051c-4339-a808-4d3759095432-3380623.jpg" alt="无向图模型" /><figcaption aria-hidden="true">无向图模型</figcaption></figure><ul><li>如果(G,X)满足局部马尔可夫性质， 即一个变量 Xk 在给定它的邻居的情况下独立于所有其它变量，</li><li>无向图模型的概率分解<ul><li>因子分解 :无向图中的的联合概率可以分解为一系列定义在最大团上的非负函数的乘积形式。</li><li>吉布斯分布 :无向图模型和吉布斯分布是一致的。吉 布斯分布一定满足马尔可夫随机场的条件独立性质，并且马尔可夫随机场的概 率分布一定可以表示成吉布斯分布。</li></ul></li><li>常见的无向图模型:很多经典的机器学习模型可以使用无向图模型来描述，比如<ul><li>对数线性 模型(Log-Linear Model)或最大熵模型(Maximum Entropy Model)</li><li>条件随机场(Conditional Random Field，CRF)</li><li>玻尔兹曼机、</li><li>受限玻尔兹曼机等。</li></ul></li><li>有向图和无向图之间的转换:<ul><li>无向图模型可以表示有向图模型无法表示的一些依赖关系，比如循环依赖;</li><li>无向图模型不能表示有向图模型能够表示的某些关系，比如因果关系。</li></ul></li></ul><h3 id="推断问题">2. 推断问题</h3><p>推断问题，即在已知部分变量时，计算其它变量的后验概率分布。</p><p>图模型的推断问题可以转换为求任意一个变量子集的边际概率分布问题。</p><h4 id="精确推断">精确推断</h4><ul><li>变量消除法</li><li>信念传播(Belief Propagation，BP)算法，也称为和积(Sum-Product)算法 或消息传递(Message Passing)算法，是将变量消除法中的和积(Sum-Product) 操作看作是消息，并保存起来，这样可以节省大量的计算资源。<ul><li>链式结构上的的信念传播算法</li><li><img src="https://img.mubu.com/document_image/bd0b3e40-76a5-42e2-8716-799247eddc32-3380623.jpg" /></li><li>树结构上的信念传播算法<ul><li>1)从叶子节点到根节点依次计算并传递 消息;</li><li>2)从根节点开始到叶子节点，依次计算并传递消息;</li><li>3)在每个节点上 计算所有接收消息的乘积(如果是无向图还需要归一化)，就得到了所有变量的 边际概率。</li></ul></li></ul></li></ul><h4 id="近似推断">近似推断</h4><p>环路信念传播</p><h5 id="变分法">变分法</h5><p>图模型中有些变量的局部条件分布可能非常复杂，或其积分无法计算。</p><p>变分法(Variational Method)是引入一个变分分布(通常是比较 简单的分布)来近似这些条件概率，然后通过迭代的方法进行计算。</p><h5 id="采样法">采样法</h5><p>采样法(SamplingMethod) 是通过模拟的方式来采集符合某个 分布 p(x) 的一些样本，并通过这些样本来估计和这个分布有关的运算，比 如期望等。 - 蒙特卡罗方法： - 基本思想可以归结为根据一个已知概率密度函数为 p(x) 的 分布来计算函数 f (x) 的期望 - 拒绝采样(Rejection Sampling)，也叫接受-拒绝采样(Acceptance-RejectionSampling) - <img src="https://img.mubu.com/document_image/f6ae17af-597a-4445-abbf-2c2b0a5bce67-3380623.jpg" /> - 假设原始分布 p(x) 难以直接采样，我们可以引入一个容易采样的分布 q(x)， 一般称为提议分布(Proposal Distribution)，然后以某个标准来拒绝一部分的 样本使得最终采集的样本服从分布 p(x)。 - 重要性采样 - 如果采样的目的是计算分布 p(x) 下函数 f (x) 的期望，那么实际上抽取的样 本不需要严格服从分布 p(x)。也可以通过另一个分布，即提议分布 q(x)，直接 采样并估计。 - 重要性采样(Importance Sampling)是通过引入重要性权重，将分布p(x) 下 f (x) 的期望变为在分布 q(x) 下 f (x)w(x) 的期望</p><h5 id="马尔可夫链蒙特卡罗markov-chain-monte-carlomcmc">马尔可夫链蒙特卡罗(Markov Chain Monte Carlo，MCMC)</h5><ul><li>在高维空间中，拒绝采样和重要性采样的效率随空间维数的增加而指数降低。</li><li>MCMC方法是一种 更好的采样方法，可以很容易地对高维变量进行采样。</li><li>核心思想是将采样过程看 作是一个马尔可夫链。具体方法有：<ul><li>Metropolis-Hastings 算法</li><li>Metropolis 算法<ul><li>可以看作是 Metropolis-Hastings 算法的特例</li><li>假设MH算法中的提议分布是对称的</li></ul></li><li>吉布斯采样(Gibbs Sampling)<ul><li>可以看作是 Metropolis-Hastings 算法的特例</li><li>用全条件概率(Full Conditional Probability)作为提议分布来依次对每个维度 进行采样，并设置接受率为A = 1。</li></ul></li></ul></li></ul><h3 id="学习问题">3. 学习问题</h3><p>图模型的学习包括：图结构的学习和参数的学习</p><p>参数的学习，即参数估计问题，可分为含隐变量的参数估计和不含因变量的参数估计：</p><ul><li>不含隐变量的参数估计：<ul><li>如果图模型中不包含隐变量，即所有变量都是可观测的，那么网络参数一般可以直接通过最大似然来进行估计。</li><li>有向图模型：所有变量x的联合概率分布可以分解为每个随机 变量 xk 的局部条件概率 p(xk |xπk , θk ) 的连乘形式，其中 θk 为第 k 个变量的局部 条件概率的参数。</li><li>无向图模型： 所有变量x的联合概率分布可以分解为定义在最 大团上的势能函数的连乘形式。</li></ul></li><li>含隐变量的参数估计：<ul><li>如果图模型中包含隐变量，即有部分变量是不可观测的，就需要用 EM 算法</li><li>EM 算法的应用例子:高斯混合模型。高斯混合模型(Gaussian Mixture Model，GMM)是由多个高斯分布组成的模型，其密度函数为多个高 斯密度函数的加权组合。</li><li><img src="https://img.mubu.com/document_image/3476923c-5528-4dd4-aa4d-ae10183bf377-3380623.jpg" /></li><li><img src="https://img.mubu.com/document_image/28d53640-0eb6-4a17-81c6-ffa8e4dbb289-3380623.jpg" /></li></ul></li></ul><h2 id="图模型与机器学习">图模型与机器学习</h2><ul><li>很多机器学习模型都可以归结为概率模型，即建模输入和输 出之间的条件概率分布。</li><li>图模型提供了一种新的角度来解释机器学习模 型，并且这种角度有很多优点，比如了解不同机器学习模型之间的联系，方便设计新模型等。</li><li>概率图模型中最基本的假设是条件独立性。图形化表示直观地描述了随机 变量之间的条件独立性，有利于将复杂的概率模型分解为简单模型的组合，并 更好地理解概率模型的表示、推断、学习等方法。</li></ul><h2 id="概率图模型与神经网络的关系">概率图模型与神经网络的关系</h2><p>概率图模型和神经网络有着类似的网络结构，但两者也有很大的不同。</p><ul><li>节点<ul><li>概率图模型的节点是随机变量，其图结构的主要功能是用来描述变量 之间的依赖关系，一般是稀疏连接。使用图模型的好处是可以有效进行统计推 断。</li><li>神经网络中的节点是神经元，是一个计算节点。如果将神经网络中每个 神经元看做是一个二值随机变量，那神经网络就变成一个 sigmoid 信念网络。</li></ul></li><li>变量的含义<ul><li>图模型中的每个变量一般有着明确的解释，<strong>变量之间依赖关系一般是人工 来定义</strong>。</li><li>神经网络中的单个神经元则没有直观的解释。</li></ul></li><li>生成模型与判别模型<ul><li>神经网络是判别模型，直接用来分类。</li><li>图模型不但可以是判别模型，也 可以是生成模型。生成模型不但可以用来生成样本，也可以通过贝叶斯公式用 来做分类。</li></ul></li><li>学习方法<ul><li>神经网络参数学习的目标为交叉熵或平方误差等损失函数。</li><li>图模型的参数学习的目标函数为似然函数或条件似然函数，若包含隐变量则通常通过 EM 算法来求解。</li></ul></li></ul><p>神经网络和概率图模型的结合：</p><ul><li>用神经网络强大的表示能力来建模图模型中的<ul><li>推断问题(比如变分自编码器， 第13.2节)，</li><li>生成问题(比如生成对抗网络，第13.3节)</li><li>势能函数(比如 LSTM+CRF模型[Lample et al., 2016, Ma and Hovy, 2016])</li></ul></li><li>用图模型的算法来解决复杂结构神经网络中的学习和推断问题<ul><li>图结构神 经网络(Graph Neural Network)</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基本概念&quot;&gt;基本概念&lt;/h2&gt;
&lt;p&gt;概率图模型(Probabilistic Graphical Model，PGM)，简称图模型(Graphical Model，GM)，首先是一种概率模型，其次，它用图结构描述多个随机变量之间的依赖关系，它是研究高维空间中的概率</summary>
      
    
    
    
    <category term="AI" scheme="https://chiechie.github.io/categories/AI/"/>
    
    
    <category term="概率图模型" scheme="https://chiechie.github.io/tags/%E6%A6%82%E7%8E%87%E5%9B%BE%E6%A8%A1%E5%9E%8B/"/>
    
    <category term="贝叶斯网络" scheme="https://chiechie.github.io/tags/%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%BD%91%E7%BB%9C/"/>
    
    <category term="贝叶斯优化" scheme="https://chiechie.github.io/tags/%E8%B4%9D%E5%8F%B6%E6%96%AF%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>深度学习基础1</title>
    <link href="https://chiechie.github.io/2021/06/10/AI/machine_learning/deeplearning/dl-basic0/"/>
    <id>https://chiechie.github.io/2021/06/10/AI/machine_learning/deeplearning/dl-basic0/</id>
    <published>2021-06-10T08:35:36.000Z</published>
    <updated>2021-06-11T01:50:23.824Z</updated>
    
    <content type="html"><![CDATA[<h2 id="layers的基本类型">layers的基本类型</h2><p>keras中layer的基本类型：</p><ul><li>卷积(Conv1D)</li><li>池化(MaxPooling1D/GlobalAveragePooling1D)</li><li>dropout(Dropout)</li><li>线性全连接层(Dense)</li><li>high-level层(LSTM)</li></ul><h3 id="卷积层">卷积层</h3><ol type="1"><li>卷积的维度有1Ｄ，2Ｄ，3D, 区别在于?</li></ol><p>输入数据的shape以及卷积核如何滑动</p><ul><li><img src="https://miro.medium.com/max/1621/1*aBN2Ir7y2E-t2AbekOtEIw.png" title="fig:" alt="I１维卷积和２维卷积的区别" /></li><li>1维卷积（Conv1D）：只有1个维度可以滑动，但是另一维度也是有待估参数的</li><li>2维卷积（Conv2D）：有两个维度可以滑动，</li><li>相同点：从参数视角都是2维的，每一个卷积kernel，参数个数是 height × width +１　（off_ set）</li></ul><ol start="2" type="1"><li>什么情况下，1d比2d好用呢？其中2个维度上，做卷积没有意义(high,close,open,close)</li></ol><h3 id="关于dropout">关于dropout</h3><p>keras中对dropout的处理，因为训练阶段需要dropout ，但是inference阶段不需要dropout，keras中如何设置？</p><p>Keras does this by default. In Keras dropout is disabled in test mode. You can look at the code<a href="https://github.com/keras-team/keras/blob/dc95ceca57cbfada596a10a72f0cb30e1f2ed53b/keras/layers/core.py#L109">here</a> and see that they use the dropped input in training and the actual input while testing.</p><p>As far as I know you have to build your own training function from the layers and specify the training flag to predict with dropout (e.g. its not possible to specify a training flag for the predict functions). This is a problem in case you want to do GANs, which use the intermediate output for training and also train the network as a whole, due to a divergence between generated training images and generated test images.</p><h2 id="损失函数">损失函数</h2><p>tensorflow中的损失函数:</p><ul><li>sparse_categorical_crossentropy: target是interger list，形状n*1；</li><li>categorical_crossentropy: target 是one-hot vector，target的shape跟模型输出一致，是n*k(类)。<ul><li><span class="math display">\[C E(x)=-\sum\limits_{i=1}^{C} y_{i} \log f_{i}(x)\]</span></li></ul></li><li>binary_crossentropy: target 是interger list。 <span class="math display">\[B C E(x)_{i}=-\left[y_{i} \log f_{i}(x)+\left(1-y_{i}\right) \log \left(1-f_{i}(x)\right)\right]\]</span></li><li>如果输出标签维度为1，只能使用binary_crossentropy，否则程序会报错。不能直接使用categorical_crossentropy 或者sparse_categorical_crossentropy</li><li>如果输出标签维度为K：使用categorical_crossentropy 或者sparse_categorical_crossentropy</li><li>单标签多分类（multi-class）：softmax + CE</li><li>二分类：sigmoid + BCE</li><li>多标签多分类（multi-label）的情况：sigmoid + BCE</li><li>最小化交叉熵损失函数等价于最大化训练数据集所有标签类别的联合预测概率。</li></ul><h2 id="归一化">归一化</h2><p>归一化层，目前主要有这几个方法：</p><ul><li>Batch Normalization（BN， 2015年）</li><li>Layer Normalization（LN， 2016年）</li><li>Instance Normalization（IN， 2017年）</li><li>Group Normalization（GN， 2018年）</li><li>Switchable Normalization（SN， 2018年）；</li></ul><figure><img src="img_1.png" alt="几种归一化方法g" /><figcaption aria-hidden="true">几种归一化方法g</figcaption></figure><h3 id="问题1-transformer-为什么要使用ln而不是-bn">问题1 transformer 为什么要使用LN而不是 BN？</h3><p>在<a href="https://arxiv.org/pdf/2003.07845.pdf">paper: Rethinking Batch Normalization in Transformers</a>中, 作者对比了cv和nlp的BN, 得出的结论是在nlp数据上基于batch的统计信息不稳定性过大(相比cv的数据)，导致bn在nlp上效果差。相比之下layer norm能够带来更稳定的统计信息，有利于模型学习</p><p>Batch Normalization主要的问题是计算归一化统计量时计算的样本数太少，在RNN等动态模型中不能很好的反映全局统计分布信息，而Layer Normalization根据样本的特征数做归一化，是batch size无关的，只取决于隐层节点的数量，较多的隐层节点数量能保证Layer Normalization归一化统计分布信息的代表性。</p><h3 id="问题2.-in直观上怎么理解">问题2. IN直观上怎么理解？</h3><p>在计算机视觉中，IN本质上是一种Style Normalization，它的作用相当于把不同的图片统一成一种风格。另外，既然IN和BN都会统一图片的风格，那么在Generator里加IN或BN应该是不利于生成风格多样的图片的，论文中也进行了展示：</p><p><img src="https://pic2.zhimg.com/v2-235433127838fca762ebd10511de9ca7_b.jpg" /></p><p>图e是在generator中加了BN的结果，图f是在generator中加了IN的结果。果然崩了，IN崩得尤其厉害。</p><h2 id="激活函数">激活函数</h2><ul><li><img src="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Frf_learning%2F4_fjPJ90ir.png?alt=media&amp;token=9fb9e321-aed2-4c7b-bb6b-4762b7a38c81" /></li><li><img src="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Frf_learning%2FADUH_mebAQ.png?alt=media&amp;token=65efc150-0f7b-42f9-8657-1ca131bfd8b5" /></li><li><img src="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Frf_learning%2FMWiLJVveHv.png?alt=media&amp;token=55bc24ce-0531-4702-8d3d-394595bd4d6e" /></li><li><img src="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Frf_learning%2FFztLjU8MxY.png?alt=media&amp;token=d7421445-afca-439e-85be-8631db133a41" /></li><li>https://missinglink.ai/guides/neural-network-concepts/7-types-neural-network-activation-functions-right/</li></ul><h2 id="其他实践">其他实践</h2><h2 id="参考资料">参考资料</h2><ol type="1"><li><a href="https://arxiv.org/pdf/1502.03167.pdf">Batch Normalization</a></li><li><a href="https://arxiv.org/pdf/1607.06450v1.pdf">Layer Normalizaiton</a></li><li><a href="https://arxiv.org/pdf/1607.08022.pdf">Instance Normalization</a></li><li><a href="https://github.com/DmitryUlyanov/texture_nets">code</a></li><li><a href="https://arxiv.org/pdf/1803.08494.pdf">Group Normalization</a></li><li><a href="https://arxiv.org/pdf/1806.10779.pdf">Switchable Normalization</a></li><li><a href="https://github.com/switchablenorms/Switchable-Normalization">code</a></li><li><a href="https://blog.csdn.net/liuxiao214/article/details/81037416">有公式推导，写的很棒</a></li><li><a href="https://www.jianshu.com/p/05de1f989790">用书比喻图像很好理解</a></li><li><a href="https://zhuanlan.zhihu.com/p/61248211">Conditional Batch Normalization 详解</a></li><li><a href="https://zhuanlan.zhihu.com/p/57875010">从Style的角度理解Instance Normalization</a></li><li><a href="https://blog.goodaudience.com/introduction-to-1d-convolutional-neural-networks-in-keras-for-time-sequences-3a7ff801a2cf">在时序数据上应用conv1D</a></li><li>https://zhuanlan.zhihu.com/p/57875010</li><li>https://stackoverflow.com/questions/47787011/how-to-disable-dropout-while-prediction-in-keras</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;layers的基本类型&quot;&gt;layers的基本类型&lt;/h2&gt;
&lt;p&gt;keras中layer的基本类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;卷积(Conv1D)&lt;/li&gt;
&lt;li&gt;池化(MaxPooling1D/GlobalAveragePooling1D)&lt;/li&gt;
&lt;li</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>《财务讲义》读书笔记</title>
    <link href="https://chiechie.github.io/2021/06/10/reading_notes/reality/caiwujiangyi/"/>
    <id>https://chiechie.github.io/2021/06/10/reading_notes/reality/caiwujiangyi/</id>
    <published>2021-06-10T08:25:08.000Z</published>
    <updated>2021-06-11T01:03:18.833Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>思考几个问题，选股的分析框架？看市盈率，看行业龙头股的baseline，跨版本的股票，看业务构成，找相应板块</p></blockquote><h2 id="第3章-花钱-投资与分配">第3章 花钱-投资与分配</h2><h3 id="chapter-21-固定资产">chapter 21 固定资产</h3><ul><li>固定资产：企业的大件资产，比如厂房，生产设备。不仅花费大，而且是企业准备长期 持有的资产。</li><li>与固定资产相对的 是流动资产，如 库存 ，短期投资 等</li><li>企业最大的开销是固定资产投资（类似搞基建，互联网公司可以弱化，但是实业公司不能弱化）</li><li>租赁的本质是债务融资（跟房贷一样）</li><li>财务决策中，在 同风险等级 的 投资决策 之间进行比较是一个重要原则。</li><li>投资的机会成本 是为了一个项目A 所放弃的 其他项目B 的收益，其他项目B的风险等级必须要和A一样。</li><li>所以，不应该考虑买还是租，而是考虑 租还是 借（钱）。也就是说 把 租赁这种 债务融资方式 和 借 这种债务融资方式 比较</li><li>如何降低租赁对负债率的影响<ul><li>在2018年 会计准则修改之前，将融资行负债 修改为 经营性负债</li><li>在2018年 会计准则修改之后，就没法专空子了。</li></ul></li><li>如何盘活租来的固定资产</li><li>融资性 售后回租：将固定资产 卖给 融资租赁公司，然后签订租赁合同，合同期满就可以买回来。</li></ul><h3 id="chapter-22-价值投资-用别人的错误赚钱">chapter 22 价值投资-用别人的错误赚钱</h3><h3 id="chapter-23-资本预算-项目之间是如何pk的">chapter 23 资本预算-项目之间是如何PK的</h3><ul><li>投资收益比较</li><li>（往上一层）投资的溢出效应：值新项目对企业其他项目 或者 外部事物的影响<ul><li>负向</li><li>正向-协同效应</li></ul></li><li>投资回收期平衡</li></ul><h3 id="chapter-24-风险量化">chapter 24 风险量化</h3><ul><li>点分析：项目的保本点是多少<ul><li>对美国上市公司的盈余公告进行研究：发现每一美元造成的股价下跌，几乎是每一美元盈利带来的股价上涨幅度的两倍</li><li>企业的盈利目标又三个层析：1. 保证不亏损 2 超过前一年同期的盈利 3 超过证券分析师的预期</li><li>局限：<ul><li>有的项目处于战略需要一定要投资，即时财务不赚钱</li><li>正向偏离也是一种风险</li></ul></li></ul></li><li>线分析：跟往年比是多少</li><li>面分析：分析师的预期是多少</li></ul><h3 id="chapter-25-实物期权-应对投资的不确定性">chapter 25 实物期权-应对投资的不确定性</h3><ul><li>案例：爱尔眼科怎样降低并购小诊所的风险？<ul><li>【道】增加投资的灵活性</li><li>【法】采用延迟期权，扩张期权，放弃期权策略</li><li>【术】联合PE成立 并购基金，联合孵化小型创业公司</li><li>https://www.pedata.cn/jsp/research.html</li></ul></li><li>互联网项目 的投资 适合实物期权投资 策略。</li></ul><h3 id="chapter-26-风险转移-保险和责任共担">chapter 26 风险转移-保险和责任共担</h3><ul><li>常见的企业风险转移方法：<ul><li>签订长期合同；利用金融工具；购买保险。</li></ul></li></ul><h3 id="chapter-27-并购策略-以小博大的智慧">chapter 27 并购策略-以小博大的智慧</h3><ul><li>基本概念：<ul><li>私有化：将一家上市公司从公众公司重新 变回 私人公司。</li><li>MBO： 管理层收购，manegement buy-out，指管理层要把公司其流通在市场上的股份全部回购。</li><li>LBO：杠杆收购，lenerage buy-out，企业用很少的自由资金，买下一家体谅比自己大很多的企业</li></ul></li><li>判断一家企业的复制扩张战略是否成功看两个指标：收入集中度，利润集中度</li><li>如何看待企业的并购活动？<ul><li>是企业实现规模和也业务扩张常用的一种方式</li><li>并购的效果与起亚的管理能力有关</li><li>杠杆收购的本质是利用财务杠杆以小博大，是一种高风险的资本运作方式</li></ul></li></ul><h3 id="chapter-28-并购隐患-商誉这只灰犀牛">chapter 28 并购隐患-商誉这只灰犀牛</h3><h3 id="chapter-29-减值时机">chapter 29 减值时机</h3><h3 id="chapter-30-分红政策-分红多就是好公司吗">chapter 30 分红政策-分红多就是好公司吗</h3><h2 id="第4章-精进-快速把脉一家上市公司">第4章 精进-快速把脉一家上市公司</h2><ul><li>我觉得这一章是 对所有 公司的 财务状况的 诊断，其中上市公司只是一个特例，并且上市公司暴露了更多的财务数据，也有公众对其未来盈利能力的估值（股价）</li></ul><h3 id="chapter-31-财务诊断-分析框架">chapter 31 财务诊断-分析框架</h3><ul><li>哈佛分析框架包括战略分析，会计分析，财务分析和前景分析。战略分析 和 会计分析都是比较 主观的分析，财务分析 和 前景分析是可以用量化的指标 分析出来的</li><li>战略分析：<ul><li>先看外部环境-“经营环境分析”<ul><li>宏观环境<ul><li>政治，经济，法律，社会文化</li></ul></li><li>行业环境<ul><li>行业规模，增长前景，利润空间，变革速度</li><li>增长前景，按照行业跟经济周期的关系可以将行业分类：<ul><li>增长型行业：如高科技行业</li><li>防御性行业：</li><li>周期性行业：如大宗原材料行业，房地产行业</li></ul></li><li>利润空间<ul><li>行业利润率估值方法-波特五力模型：<ul><li>行业内竞争的激烈程度</li><li>行业进入 壁垒的高低</li><li>供应商谈判能力的强弱</li><li>购买方谈判能力的强弱</li><li>替代产品威胁的大小</li></ul></li></ul></li><li>行业变革速度：哪些是核心驱动因素，以及核心因素的变化速度<ul><li>一个是客户群体以及消费偏好的变化：例如消费行业</li><li>一个是技术革新的速度：如新能源技术在汽车的应用</li></ul></li></ul></li></ul></li><li>再看自己-“企业自身战略”<ul><li>战略：差异化战略（星巴克），成本领先战略（沃尔玛）</li><li>前者毛利率是后者两倍</li></ul></li></ul></li><li>会计分析：检验财务指标的真实性，是否真实的反应了公司的运营状况，重点关注以下3个维度<ul><li>1， 对企业影响最大的<strong>会计政策</strong>是什么？<ul><li>高科技企业利润要重点关注对研发支出的处理</li><li>重资产企业利润要重点关注固定资产折旧的处理</li></ul></li><li>2 哪些会计政策发生了变化？<ul><li>比如某一年度钢铁公司<strong>突然</strong>调节了固定资产折旧政策--延长折旧时间，来降低档期折旧费用。那么就需要进一步了解是否“操纵利润”的嫌疑。（真实情况是，这个是为了避免退市的垂死挣扎）</li></ul></li><li>3，对标企业（同行，用一行业的其他公司）的会计政策有哪些不一样？<ul><li>如果发现一家高科技企业的研发支出资本化比例 明显超过同行，就要进一步分析背后的原因。</li></ul></li></ul></li><li>财务分析：从4个维度 用具体的数值 评价公司现在做的怎么样</li><li>前景分析：预测业绩的可持续性，以及未来的价值</li></ul><h3 id="chapter-32-财务分析-4个维度诊断公司健康">chapter 32 财务分析-4个维度诊断公司健康</h3><ul><li><p>我同可以通过建立一些核心的财务指标考察企业在偿债能力，营运能力，盈利能力，价值创造这4个维度的表现，这个分析方法被称为“比率分析”方法。偿债能力: 关注的是企业家必须守住的底线，其他三个指标考虑的是企业的发展问题。企业发展 要靠“开源节流”，也就是，一方面提升盈利，一方面提升管理效率（营运能力）。</p></li><li><p>偿债能力: 关注的是企业家必须守住的底线</p><ul><li>流动比率 = 流动资产 / 流动负债， 小于1说明有重大问题，a股平均值1.22</li><li>速动比率= （流动资产 - 存货） /流动负债，a股平均值0.5<ul><li>速冻比率 相对流动比率，剔除了资产中 变现能力 最差的 存货</li></ul></li><li>现金比率 = 货币资金 / 流动负债，a股平均值0.31<ul><li>现金比率相对速动比率剔除 了 应收帐款</li><li>这个比率不能过高，过高了虽然风险预防能力是具备了，但是也说明资金使用效率低了。</li></ul></li></ul></li><li><p>营运能力</p><ul><li>周转率：<ul><li>主要反应管理效率，</li></ul></li></ul></li><li><p>盈利能力</p></li><li><p>价值创造能力：市盈率 和 市净率 - ### chapter 33 财报工具-竖着比和横着比</p></li><li><p>竖着比就是跟自己往年业绩比</p></li><li><p>横着比就是跟同行业的竞争公司比</p></li></ul><h3 id="chapter-34-财务实战-哈佛分析框架的应用">chapter 34 财务实战-哈佛分析框架的应用</h3><ul><li>【chiechie】作业1-使用哈佛分析框架分析下腾讯</li><li>【chiechie】作业2-使用哈佛分析框架分析下现在在做的项目</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;思考几个问题，选股的分析框架？看市盈率，看行业龙头股的baseline，跨版本的股票，看业务构成，找相应板块&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;第3章-花钱-投资与分配&quot;&gt;第3章 花钱-投资与分配&lt;/h2&gt;
&lt;h3 id=&quot;cha</summary>
      
    
    
    
    <category term="阅读" scheme="https://chiechie.github.io/categories/%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="平台" scheme="https://chiechie.github.io/tags/%E5%B9%B3%E5%8F%B0/"/>
    
    <category term="平台治理" scheme="https://chiechie.github.io/tags/%E5%B9%B3%E5%8F%B0%E6%B2%BB%E7%90%86/"/>
    
    <category term="行业研究" scheme="https://chiechie.github.io/tags/%E8%A1%8C%E4%B8%9A%E7%A0%94%E7%A9%B6/"/>
    
    <category term="商业模式" scheme="https://chiechie.github.io/tags/%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="创业" scheme="https://chiechie.github.io/tags/%E5%88%9B%E4%B8%9A/"/>
    
  </entry>
  
  <entry>
    <title>多世界理论</title>
    <link href="https://chiechie.github.io/2021/06/10/reading_notes/phisics/duoshijie/"/>
    <id>https://chiechie.github.io/2021/06/10/reading_notes/phisics/duoshijie/</id>
    <published>2021-06-10T06:26:46.000Z</published>
    <updated>2021-06-11T01:03:18.830Z</updated>
    
    <content type="html"><![CDATA[<h2 id="总结">总结</h2><ol type="1"><li>多世界理论是埃弗里特（Hugh Everett III, 1930 - 1982）在1957年提出的. 这个理论的核心是：量子理论是一个自洽的理论，不需要借助经典概念和任何额外的假设就能描述和解释一切现象，包括我们日常生活感受的经典世界和量子测量。根据这个理论，波包永远也不会塌缩，任何物体无论大小都是量子的，都可以用波函数描述。 整个宇宙的波函数<span class="math inline">\(\Psi\)</span>可以写成很多个分量的叠加 <span class="math display">\[\Psi=\varphi_{1}+\varphi_{2}+\ldots+\varphi_{n}+\ldots\]</span></li><li>其中的每一个分量<span class="math inline">\(\varphi_{n}\)</span>代表一个平行世界，这些平行世界真实存在、平行演化、互不干扰，偶尔发生干涉。 3 对多世界理论持反对意见的人其实无法给出任何令人信服的理由，主要是心理上无法接受其他平行世界的存在。</li><li>埃弗里特一开始就指出了波包塌缩理论的逻辑缺陷：当存在两个或两个以上观察者的时候，观察者们会给出不同的波包塌缩时间。埃弗里特用了一个例子来说明这个逻辑缺陷，他的例子和维格纳朋友佯谬类似。</li></ol><h2 id="薛定谔的猫猫">薛定谔的猫猫</h2><ol type="1"><li>薛定谔猫是一个关于量子测量的思想实验。在薛定谔的最初设想中，被测量的是正在衰变的放射性元素，这里用光子的偏振代替。 <img src="img.png" alt="img.png" /></li><li>每一个光子有两个可能的偏振态，水平偏振和垂直偏振。一般情况下，光子既不是水平偏振也不是垂直偏振，而是处于它们的叠加态。（类似复数）</li><li>现在假设有一个封闭的实验室，里面有一只猫猫，和光子偏振的测量设备。实验开始时，一个光子入射穿方解石，出来后落在检测屏上。如果落在检测评上方，什么也不会发生，猫猫依然是活的，如果落在下方，会触发打开毒气瓶的开关，把猫猫毒死。</li><li>光子落在屏幕上之后，猫猫和光子发生了纠缠。</li><li>现在让我们用量子力学来描述这个实验。实验开始前，实验室的波函数可以写成: <span class="math display">\[\left|\Psi_{0}\right\rangle=(\alpha|H\rangle+\beta|V\rangle) \otimes \mid live cat \rangle\]</span> 这时猫和光子没有任何关联。实验结束后，实验室的波函数变成了: <span class="math display">\[\begin{aligned}\left|\Psi_{1}\right\rangle&gt;=\alpha &amp;|H\rangle \otimes \mid \text { live cat }\rangle+\\ &amp;\beta|V\rangle \otimes \mid \text { dead cat }\rangle \end{aligned}\]</span></li><li>现在的问题是，上面的波函数有两部分：在第一部分里，猫是活的；在第二部分里，猫是死的。那这猫究竟是活的还是死的呢？如果你重复这个实验1000次，每次实验结束后打开实验室查看猫的死活，那么你会发现大约有 1000 |α|2次猫是活的，大约1000 | β |2次猫是死的。你不会看到一只既活又死的猫。</li><li>这个实验的本质是，波函数里明明有两个实验结果，当我们去观察时，却只能看到一个。为什么会这样? <img src="img_1.png" alt="img_1.png" /></li><li>在量子力学的框架下，如何解释这个现象？波包塌缩理论：当我们打开实验室去观察时，波函数发生了塌缩。它有<span class="math inline">\(\alpha^2\)</span>的几率发生如下塌缩： <span class="math display">\[\left|\Psi_{0}\right\rangle=\alpha|H\rangle \otimes \mid live cat \rangle\]</span> <span class="math inline">\(\beta^2\)</span>的几率发生如下塌缩： <span class="math display">\[\left|\Psi_{0}\right\rangle=\beta|V\rangle \otimes \mid dead cat \rangle\]</span> 也就是说，有一部分波函数会神秘的消失。</li><li>虽然波包塌缩理论能解释实验结果，但有很多缺点，比如没有描述塌缩究竟怎样发生的，持续了多长时间</li><li>另外一种理论就是多世界理论，系统的波函数<span class="math inline">\(\Psi\)</span>中两个分量，分别代表两个不同世界：一种世界里面，猫猫是活的，另外一种世界，猫猫是死的。这两种世界一样真实，并行存在。由于量子力学的演化是线性的，这两种世界会独立演化，互不影响。当观测者打开实验室的门，在一种世界里，他会看到一直活着的猫猫，感觉不到死猫，这个时候，似乎波函数发生了公式描述的塌缩。在另外一个世界，他会看到相反的景象，这似乎象征着波函数发生了第二种塌缩。从这个角度看，波包塌缩其实是多世界理论的推论，迄今没有任何实验可以推翻多世界理论。</li><li>当一个世界一分为二时，多世界理论是不是预示着能量不守恒了？并没有，分裂之后，只是几率变化了。分类之后的<span class="math inline">\(\Psi_1\)</span>表示，一个实验室有两种状态，一种状态里光子是水品偏振和猫是活的，另外一种状态里，光子是垂直偏振，猫猫却死了。这时，仍然只有一个光子，和一只猫。测量，让猫猫和光子的状态发生了纠缠，并没有增加数量 11。 量子图灵机非常推崇多世界理论，这个宇宙有无限个世界，跟0到1之间的实数一样多，对于薛定谔猫猫实验，一开始有无限多个世界，他们都完全相同。光子偏振测量结束后，这无穷多个世界分成了两组，分别由<span class="math inline">\(\Psi_1\)</span>中的两个分量描述，两组所占的比重分别为</li><li>多世界理论的核心：整个宇宙都是由微观粒子构成，宏观物体和围观粒子没有本质区别，他们也由波函数描述。一个波函数的不同分量代表不同的世界，每个分量都同样真实的，他们并行存在。相对于其他量子力学的解释，多世界理论不需要在量子力学的基本框架之外的额外假设。</li></ol><h2 id="谁对谁错">谁对谁错?</h2><blockquote><p>以薛定谔猫为例介绍了波包塌缩理论和多世界理论，它们都能解释现有实验结果。而且迄今为止没有人能设计一个实验来区别这两种理论，比如直接观测到另外一个世界或波包塌缩过程。那么究竟哪一个理论是正确的呢？实验是科学理论的试金石，现在这块试金石失效了，我们该如何判断这两种理论的对错？埃弗里特在他长论文的最后一个附录里谈到了物理理论的对错优劣问题，他认为除了寻求实验的验证，我们还应该考查理论的逻辑性、有用性、简单性等。下面我们就从这些方面详细对比波包塌缩理论和多世界理论。</p></blockquote><h3 id="逻辑性">逻辑性</h3><p>埃弗里特指出波包塌缩理论的逻辑缺陷：当存在两个或两个以上观察者的时候，观察者们会给出不同的波包塌缩时间。埃弗里特用了一个例子来说明这个逻辑缺陷，他的例子和维格纳朋友佯谬类似。在图3描述的实验中，我们把猫换成观察者爱丽丝，同时移走毒气瓶。如果光子落在检测屏上方，她就记录“上”；如果光子落在检测屏下方，她就记录“下”。对于爱丽丝来说，波包塌缩在光子和检测屏碰撞的一刻就已经发生了，因为她每次都明确地观察到了光子落在了上方或下方。现在假设实验室外面还有一个观察者鲍勃，在实验完成前，他和实验室没有任何相互作用。对于鲍勃来说，在他打开实验室以前，实验室由如下波函数描述 <span class="math display">\[\left|\Psi_{3}\right\rangle=\alpha|H\rangle \otimes|\mathrm{Up}\rangle+\beta|V\rangle \otimes \mid Down \rangle \]</span> 波包还没塌缩。假设鲍勃在实验结束后一周打开了实验室，这时波包塌缩了。他对爱丽丝的记录没有任何异议，但他坚持说波包塌缩是在他进入实验室的一刻发生的，爱丽丝当然不同意。于是矛盾产生了。这就是波包塌缩理论的逻辑缺陷。文献[10]对这个逻辑问题有更详细的描述。</p><h3 id="简单性">简单性</h3><p>这里指的是概念和理论框架的简单。多世界理论显然在概念上更简单，除了量子力学的基本框架，它不需要任何额外的假设。而波包塌缩是量子力学基本框架之外的一个额外假设。在量子力学里，量子态都是随时间进行连续和幺正的演化；而波包塌缩是不连续和非幺正的。因此，波包塌缩必须是一个独立的假设，不可能从量子力学的基本框架推出来。这个假设非常的不物理：塌缩是怎样的物理过程？经历了多长时间？如何界定外部观察者？这些问题迄今没有令人满意的答案。当我们考虑整个宇宙时，波包塌缩假说显得更是不合理。一方面，宇宙的外部没有观察者，所以整个宇宙的波函数应该连续地随时间幺正演化，不会经历随机的波包塌缩；另一方面，我们人类又时时刻刻在进行类似图3的实验，波包在随机的塌缩。这样宇宙的波函数由于我们的观察不再随时间幺正演化。多世界理论则不会导致这样矛盾的结果。</p><h3 id="刚性">刚性</h3><p>如果一个理论不能随意改动，我们就说这个理论具有刚性。多世界理论在概念上更简单，因为它不需要任何额外的假设。这也使它具有了刚性。量子力学已经被大量实验证实，它的基本理论框架是不能随意改动的。如果你能改动量子力学的基本框架，那你一定在引导一场新的物理革命。与之相反，波包塌缩理论显然是可以随意改动的。比如，我可以假设波包塌缩有一个中间过程：任何波函数都先塌缩为一个等权重量子态然后再塌缩到目标态。根据这个假设，公式(6) 描述的塌缩应该改写为</p><p><span class="math display">\[\left|\Psi_{1}\right\rangle \rightarrow \frac{1}{\sqrt{2}}(|H\rangle \otimes \mid live cat \rangle+|V\rangle \otimes \mid dead cat \left.\rangle\right) \rightarrow|H\rangle \otimes \mid live cat \rangle\]</span></p><p>这个修改后的波包塌缩理论同样能解释图3中的实验结果和其他量子测量结果。更糟糕的是，我们可以对波包塌缩理论做任意类似的改动。所以波包塌缩理论刚性非常差，完全是一团可以被随意揉捏的面。笔者认为任何真理和美都具有类似的刚性。一首动听的乐曲具有刚性：它的每一个音符都不能随意改动；一首美的诗具有刚性：它的每一个字都不能随意改动；一朵漂亮的鲜花具有刚性：花瓣的颜色、形状等都不能随意变动，所以花店老板总是对她店里的鲜花小心呵护。由于篇幅限制，这里不展开讨论了。</p><h3 id="有用性">有用性</h3><p>波包塌缩理论似乎只能用来解释类似图3中的量子测量实验，笔者不清楚它还有什么其他用处。多世界理论则帮助笔者解开了一些长久的困惑。按照进化论，我们人类是由非常初级的化学分子一步一步进化而来。每一步进化都是一个小概率事件，所以最后一步一步进化成具有智慧的人，概率是非常、非常小的。即使整个进化过程的时间很长，依然让人觉得不好接受：这么小概率的事件居然发生了。按照多世界理论，这种进化则是必然的，因为在多世界理论中任何小概率事件都会实现。波函数|Ψ1〉中有两个分量：无论α多小，活猫的世界都存在；无论β多小，死猫的世界都存在。也就是说，宇宙从来都不做选择，它只是按照比重不停地分裂为更多的世界。基于这个认识，让我们再来看生物进化。每一步进化其实都是一个化学反应过程：早期的进化是小分子组合成大分子，后来则是基因突变。而任何化学反应都是一个量子演化过程。按照多世界理论，无论事件发生的概率多小它都会发生。概率小只是说明在众多的世界里只有很少一部分生活着我们这样的智慧生物，绝大多数世界里地球上没有生命或者生命处于极其初始的状态。</p><h2 id="自由意志和多世界">自由意志和多世界</h2><p>按照经典物理，一旦初始条件给定，系统随后的演化就是唯一确定的。形象点说就是你所做的一切都是命中注定的，你的一生在你出生的那个时刻就已经确定了，自由意志只是一种假象。从经典物理理论出发，这个观点真是难以辩驳。后来有了量子力学，理论框架里含有内禀的几率，自由意志似乎不再是假象。但仔细一想，即使有了量子力学，自由意志似乎依然是假象。按照波包塌缩理论，几率只发生在外部观察者进行观察时。整个宇宙并没有外部观察者，宇宙的波函数依然按照量子力学进行确定的演化，所以自由意志依然是假象。但是按照多世界理论，整个宇宙的波函数虽然在确定地演化，但是它却在不停地分裂成不同的世界，观察者究竟感受和经历哪一个特定的世界是随机的，他不确定自己的未来是属于哪一个世界。这样，对于每一个世界来说，人是有自由意志的。于是我们有了一个非常美妙的结论：在一个确定演化的宇宙里存在真正的自由意志。</p><h2 id="世界是量子的">世界是量子的</h2><p>量子力学是一场颠覆性的物理革命，彻底推翻了很多经典的概念。但是非常有意思的是，几乎所有的量子力学的创立者都始终没有彻底摆脱经典物理的枷锁。这个问题的根源是波函数。波函数是抽象的希尔伯特空间中的一个向量，它和我们感知的世界没有直接的联系。为了建立波函数和现实世界的联系，这些伟大的物理学家开始回头在经典物理中寻求答案。爱因斯坦认为波函数根本就不能完整地描述自然，最终的理论一定是一个经典的理论，即所谓的隐变量理论。以玻尔和海森伯为代表的哥本哈根学派虽然认为波函数完整地描述了自然，但波函数和现实世界的联系需要通过经典仪器来完成。但最令人迷惑的事情是，没有一篇文章或一本书清晰明确阐明哥本哈根学派，他们的观点弥散在玻尔和他门徒无穷的文章和讲话里，每次他们似乎在谈论同一个观点，仔细一读似乎又总是有些变化。朗道在他的《量子力学》第一节中写了这样一段话，量子力学在物理理论中占有一个很不平常的地位；它把经典力学作为一种极限情形而包含之，但在它的自身表述中，同时又需要这一极限情形。</p><p>这或许能概括哥本哈根学派关于量子力学和经典力学之间关系的模棱两可的态度吧。哥本哈根学派无论怎么表述他们的观点，有一点很明确，他们没有彻底摆脱经典力学的枷锁。德布罗意试图将波函数解释成一种经典波，发展了导波理论，后来玻姆独立发展这个理论。这个理论认为粒子本质上是经典的。薛定谔似乎是这些量子先贤中唯一一位不走回头路的。他曾经在1952年的一次演讲中批评了当时流行的哥本哈根学派，指出波函数中的每一个分量都可能同时存在[11]。这当然就是多世界理论的本质。但是很遗憾，薛定谔并没有进一步发展这个想法。</p><h2 id="参考">参考</h2><ol type="1"><li><a href="https://weibo.com/ttarticle/p/show?id=2309404646458711212151#_0">埃弗里特和他的多世界理论-吴飙-weibo</a></li><li><a href="https://www.phy.pku.edu.cn/wubiao/dfiles/pw/aifulitehetadeduoshijielilun.pdf">埃弗里特和他的多世界理论-吴飙-paper</a></li><li><a href="https://www.phy.pku.edu.cn/wubiao/pxsj.htm">吴飙-主页</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;多世界理论是埃弗里特（Hugh Everett III, 1930 - 1982）在1957年提出的. 这个理论的核心是：量子理论是一个自洽的理论，不需要借助经典概念和任何额外的假设就能描述和解释一切现象</summary>
      
    
    
    
    <category term="阅读" scheme="https://chiechie.github.io/categories/%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="物理" scheme="https://chiechie.github.io/tags/%E7%89%A9%E7%90%86/"/>
    
    <category term="平行世界" scheme="https://chiechie.github.io/tags/%E5%B9%B3%E8%A1%8C%E4%B8%96%E7%95%8C/"/>
    
    <category term="自由意志" scheme="https://chiechie.github.io/tags/%E8%87%AA%E7%94%B1%E6%84%8F%E5%BF%97/"/>
    
    <category term="薛定谔的猫猫" scheme="https://chiechie.github.io/tags/%E8%96%9B%E5%AE%9A%E8%B0%94%E7%9A%84%E7%8C%AB%E7%8C%AB/"/>
    
  </entry>
  
  <entry>
    <title>《the book of why》读书笔记-7</title>
    <link href="https://chiechie.github.io/2021/06/10/the-book-of-why/judea-pearl_the-book-of-why7/"/>
    <id>https://chiechie.github.io/2021/06/10/the-book-of-why/judea-pearl_the-book-of-why7/</id>
    <published>2021-06-10T00:33:38.000Z</published>
    <updated>2021-06-15T00:28:10.651Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>the book of why 的第7章-一些悖论</p></blockquote><h2 id="参考">参考</h2><ol type="1"><li><a href="http://bayes.cs.ucla.edu/WHY/why-intro.pdf">the book of why-微信读书</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;the book of why 的第7章-一些悖论&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;http://bayes.cs.ucla.edu/WHY/why-</summary>
      
    
    
    
    <category term="因果分析" scheme="https://chiechie.github.io/categories/%E5%9B%A0%E6%9E%9C%E5%88%86%E6%9E%90/"/>
    
    
    <category term="人工智能" scheme="https://chiechie.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    <category term="哲学" scheme="https://chiechie.github.io/tags/%E5%93%B2%E5%AD%A6/"/>
    
    <category term="因果分析" scheme="https://chiechie.github.io/tags/%E5%9B%A0%E6%9E%9C%E5%88%86%E6%9E%90/"/>
    
    <category term="贝叶斯" scheme="https://chiechie.github.io/tags/%E8%B4%9D%E5%8F%B6%E6%96%AF/"/>
    
    <category term="因果推断" scheme="https://chiechie.github.io/tags/%E5%9B%A0%E6%9E%9C%E6%8E%A8%E6%96%AD/"/>
    
    <category term="根因分析" scheme="https://chiechie.github.io/tags/%E6%A0%B9%E5%9B%A0%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>《the book of why》读书笔记-6</title>
    <link href="https://chiechie.github.io/2021/06/10/the-book-of-why/judea-pearl_the-book-of-why6/"/>
    <id>https://chiechie.github.io/2021/06/10/the-book-of-why/judea-pearl_the-book-of-why6/</id>
    <published>2021-06-10T00:33:38.000Z</published>
    <updated>2021-06-15T00:28:10.647Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>the book of why 的第6章-一些悖论</p></blockquote><h2 id="悖论1-蒙提-霍尔">悖论1-蒙提 霍尔</h2><h3 id="背景">背景</h3><p>一个竞猜游戏中，有三个用幕布遮住的们，其中有2个门后面是山羊，1个是汽车。有两种游戏规则，分别是：</p><ol type="1"><li>观众先选择三个门中的一个，然后主持人从另外两个门中选择一个没有汽车的们打开，然后这个观众可以选择要不要换门？</li><li>观众先选择三个门中的一个，然后主持人从另外两个门中随便选一个打开，然后这个观众可以选择要不要换门？</li></ol><p>第一种强况下，选择换门的话，赢到车车的概率是2/3， 第二种情况下，选择换门的话，赢到的车车的概率是1/2</p><figure><img src="./img789.png" alt="img.png" /><figcaption aria-hidden="true">img.png</figcaption></figure><h3 id="悖论的原因">悖论的原因</h3><ol type="1"><li><p>贝叶斯公式可以解释信息在非因果关系上的流动，也就是规则1，主持人选择了没有汽车的之后，第三个门的不确定性降低了（沿着门后有车的概率变大的方向），而整个空间的概率之和为1，所以第一个门有车的概率变小了。</p><blockquote><p>主持人的这个决策带来了系统的熵减，系统坍塌到2号门某个确定状态的子空间去了。</p></blockquote></li><li><p>为什么直觉上很难接受规则1的结论，反而会认为比赛的机制不公平？这个跟人类大脑结构有关系：</p><ul><li>大脑不擅长处理概率问题，</li><li>大脑自发抵制非因果关系的信息传递，这个是贝叶斯式变量控制的产物。</li><li>习惯将相关性等同于因果性</li><li>大脑天生难以接受</li></ul></li></ol><h2 id="悖论2-伯克森悖论">悖论2-伯克森悖论</h2><ol type="1"><li>生物统计学家约瑟夫.伯克森在医院做实验时，观察到了一个现象：两种疾病本来在一般人群中毫无关联，但是在住院人群中却会观察到似是而非的相关性。</li><li>医院样本实际上是一个冲撞模型，即，当一个人同时患了两种疾病时，一定会住院。</li><li>所以，「医院样本」就好像一个经过精心挑选过的样本，体现出来的相关关系是控制了「住院」变量之后，疾病1和疾病2的伪相关性。 <img src="img7890.png" alt="img.png" /></li><li>1956年，哲学家赖欣巴提出了一个猜想「共因原则」（common cause principle），他认为没有不含因果关系的相关关系，即，X和Y的相关不是偶然发生的，要么是一个变量导致另一个变量，要么是第三个变量，比如说出现在两个变量之前的Z变量，导致两者发生。</li><li>设计一个抛硬币的实验就可以推翻「共因原则」：假设同时抛两枚硬币，抛100次，只记录其中至少又一枚硬币为正面的结果，实验结束，发现记录的75条记录中，发现只要硬币1反面，硬币2就是正面，是因为两个硬币互通消息了吗？不是的，是因为人为记录改变了测度空间。</li><li>还有一个社会现象就是，在一些调查中发现，跟你约会的人中，哪些又魅力的人往往是混蛋。这个也是因为测度空间被你亲手改变了，因为长得丑的渣男最开始就被你过滤了。过滤之前，有魅力的渣男的概率是1/4，过滤之后有魅力的渣男概率是1/3。所以感觉这个比例增加了。</li></ol><h2 id="悖论3-辛普森悖论">悖论3-辛普森悖论</h2><ol type="1"><li>辛普森逆转：一个叫辛普森的医生，在文献上发现了一种新药D，可以治疗心脏病。论文的实验数据显示，女性患者服用药物之后，心脏病发作比例升高；男性患者服用药物之后，心脏病发作比例也升高。但是，在整体人群上，心脏病发作比例却降低了，因此该药物也被归为BBG（BAD/BAD/GOOD）型药物。然而，实际上这种药物不存在，虽然说在数学上没有什么问题。 <img src="./img.png" alt="辛普森" /></li><li>对整体人群来说，正确的结论应该是什么呢？可以这么操作，先控制性别：<ul><li>do（性别）=女性，计算女性服药之后心脏病发作比例的变化 r1。</li><li>do（性别）=男性，计算男性服药之后心脏病发作比例的变化 r2。</li><li>假设整体人群中，男女比例为1：1，那么可以推断出整体人群，服药之后，心脏比发作比例的变化为（r1+r2）/2</li></ul></li><li>辛普森悖论是因为混杂因子的存在。</li><li>当我们考察两个变量的因果效应时：<ul><li>如果存在混在因子，只能用分层数据计算因果效应，采用控制混杂因子的方式，case by case，计算每个混在因子取值的情况下，两个变量的因果关系，然后按照混杂因子每个取值的概率汇总，得到整体上，两个变量之间的因果关系。 <img src="./img_2.png" alt="img_2.png" /></li><li>如果不存在混杂因子（有可能存在中介物），可以用聚合数据计算因果效应 <img src="./img_1.png" alt="中介物" /></li></ul></li><li>混杂因子存在的警告：根据聚合数据估计出来的因果效应大于，根据分层数据估计出来的因果效应。</li></ol><h2 id="关于悖论">关于悖论</h2><ol type="1"><li><p>什么是悖论？绝大部分人深信不疑的两个信念之间的冲突。</p><blockquote><p>辛普森逆转并不算悖论，只是纠正了不懂数学的人，对"平均表现"的错误认识。</p></blockquote></li><li><p>如何解决悖论？</p><ol type="1"><li>理解为什么大多数人会把它看成一个悖论？or大家对世界的直观看法到底在哪里存在重大缺陷？eg生理结构原因：大部分人不擅长处理概率问题；「过分擅长」处理因果问题</li><li>如何纠正：刻意训练，完成大脑重塑。</li></ol></li></ol><h2 id="参考">参考</h2><ol type="1"><li><a href="http://bayes.cs.ucla.edu/WHY/why-intro.pdf">the book of why-微信读书</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;the book of why 的第6章-一些悖论&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;悖论1-蒙提-霍尔&quot;&gt;悖论1-蒙提 霍尔&lt;/h2&gt;
&lt;h3 id=&quot;背景&quot;&gt;背景&lt;/h3&gt;
&lt;p&gt;一个竞猜游戏中，有三个用幕布遮住的们，其中有2</summary>
      
    
    
    
    <category term="因果分析" scheme="https://chiechie.github.io/categories/%E5%9B%A0%E6%9E%9C%E5%88%86%E6%9E%90/"/>
    
    
    <category term="人工智能" scheme="https://chiechie.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    <category term="哲学" scheme="https://chiechie.github.io/tags/%E5%93%B2%E5%AD%A6/"/>
    
    <category term="因果分析" scheme="https://chiechie.github.io/tags/%E5%9B%A0%E6%9E%9C%E5%88%86%E6%9E%90/"/>
    
    <category term="贝叶斯" scheme="https://chiechie.github.io/tags/%E8%B4%9D%E5%8F%B6%E6%96%AF/"/>
    
    <category term="因果推断" scheme="https://chiechie.github.io/tags/%E5%9B%A0%E6%9E%9C%E6%8E%A8%E6%96%AD/"/>
    
    <category term="根因分析" scheme="https://chiechie.github.io/tags/%E6%A0%B9%E5%9B%A0%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>《编程:隐匿在计算机硬件背后的语言 》的读书笔记</title>
    <link href="https://chiechie.github.io/2021/06/08/reading_notes/computer/coding/"/>
    <id>https://chiechie.github.io/2021/06/08/reading_notes/computer/coding/</id>
    <published>2021-06-08T01:09:12.000Z</published>
    <updated>2021-06-11T02:39:26.044Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二进制加法器">12 二进制加法器</h2><ol type="1"><li>电路中的逻辑门能实现二进制加法。</li></ol><blockquote><p>逻辑门是认为设计的一种电路走线，为了映射到逻辑上的加法运算。</p><p>逻辑门是链接物理世界和信息世界的桥梁，信息世界以逻辑求和为根基，开始构建信息世界的高楼大厦。</p></blockquote><h2 id="存储器组织">16 存储器组织</h2><ol type="1"><li><p>我们习惯于将可能用到的事物先存起来，在需要时将它们取出。从技术角度来讲，这个过程称为先存储后访问。存储器的职责和作用就在于此，它负责保障这两个过程之间信息完好无损。</p></li><li><p>存储信息都要利用不同种类的存储器。比如，保存文本信息的不二之选就是纸张，而磁带则更适于存储音乐和电影。</p></li><li><p>电报继电器（Telegraph Relays）——以一定形式组织起来构成逻辑门，然后再形成触发器——同样具备保存信息的能力</p></li><li><p>随机访问存储器（RAM）一断电，数据就消失了。因此随机访问存储器也叫易失性（volatile）存储器。</p><blockquote><p>一个辛辛苦苦装满65,536字节珍贵数据的64 K×8 RAM阵列，如果断掉电源，首先所有的电磁铁都将因为没有电流而失去磁性，随着“梆”的一声，金属片将弹回原位，所有继电器将还原到未触发状态。RAM中存储的数据呢？它们将如风中残烛般消失在黑暗中</p></blockquote></li></ol><h2 id="从算盘到芯片">18 从算盘到芯片</h2><h2 id="两种微处理器">19 两种微处理器</h2><ol type="1"><li><p>微处理器将中央处理器的所有组建整合到一个硅芯片上。</p></li><li><p>第一个微处理器，intel 4004，包含了2300个晶体管</p></li><li><p>三十年过去了，一个微处理器中的晶体管数量逼近1000w个。</p></li><li><p>摩托罗拉公司，从20实际50年代生产半导体和晶体管，在1974年8月推出了6800处理器。</p></li><li><p>得克萨斯仪器在1974年，推处4位的处理器TMS1000，</p></li><li><p>英特尔为8080最初定的价格为360美元，8080是一个8位的微处理器，它包括6000个晶体管，运行的时钟频率为2 MHz，寻址空间为64 KB。</p></li><li><p>这些芯片被称为“单芯片微处理器”（single-chip microprocessors</p></li><li><p>除了处理器之外，计算机还需要其他一些设备，至少要包括存储器（RAM），输入设备（键盘），输出设备（显示屏），以及其他一些能把所有构件连接在一块的芯片（主板，机箱）。</p></li><li><p>通过观测芯片的输入、输出信号，特别是芯片的指令集来理解微处理器的工作原理。</p></li><li><p>微处理器通过管脚提供了处理器的输入和输出访问接入点 <img src="img.png" alt="img.png" /></p></li><li><p>所有电气或电子设备都需要某种电源来供电</p></li><li><p>8080的一个特殊的地方就是它需要三种电源电压：管脚20必须接到5V的电压；管脚11需要接到-5V的电压；管脚28需接12V的电压；管脚2接地。（英特尔在1976年发布了8085芯片，目的就是简化对这些电源的要求）.</p><ul><li>从芯片引出的箭头表明这是一个输出（output）信号，这种信号由微处理器控制，计算机的其他芯片对该信号响应。</li><li>指向芯片的箭头表明该信号是一个输入（input）信号，该信号由其他芯片发出，并由8080芯片对其响应。还一些管脚既是输入又是输出。</li></ul></li><li><p>8080有16个用于寻址的输出信号，标记为A0～A15，因此它的可寻址空间大小为<span class="math inline">\(2^16\)</span></p></li><li><p>在计算机中，所有的指令都是3个字节长（1个字节=8个bit），包括1字节的操作码和2字节的地址，指令长什么样？：</p><ul><li>有些指令使8080从存储器的一个特定地址读取字节到微处理器，</li><li>有些指令使8080将一个字节从微处理器写入存储器的特定地址；</li><li>还有些指令使8080在其内部执行而不需要访问RAM</li></ul><p>8080执行完第一条指令后，接着从「存储器」读取第二条指令，并依此类推。这些指令组合在一起构成了计算机程序</p></li><li><p>计算机的指令集包括两条非常重要的指令，我们称之为加载（Load）和保存（Store），每条指令占3个字节</p><ul><li>在Load指令中，第一个字节是操作码，其后的两个字节是要加载的操作数的16位地址。当处理器执行加载指令时，会把该指定地址中的字节加载到累加器。</li><li>当Store指令被执行时，累加器中的内容被保存到该指令指定的地址中。</li></ul></li><li><p>8080芯片的微处理器的内部除累加器外还设置了6个寄存器（register），每个寄存器可以存放一个8位的数。这些寄存器和累加器非常相似，事实上累加器被视为一种特殊的寄存器。</p></li><li><p>寄存器是计算机必不可少的部件吗？理论上不是。很多计算机程序都同时用到多个数据，将这些数据存放在寄存器比存放在存储器更便于访问，因为程序访问内存的次数越少其执行速度就越快。</p></li><li><p>利用指令，可以方便地把一个寄存器存放的数据转移到另一个寄存器</p></li><li><p>有一种存储器叫堆栈：以从底部到顶部的顺序把数据存入存储器，并以相反的顺序把数据从堆栈中取出，因此该技术也称作后进先出存储器（last-in-first-out，LIFO）。在计算机中使用堆栈技术是十分方便的。通常把将数据存入堆栈的过程称作压入（push），把从堆栈取出数据的过程称作弹出（pop）。</p></li><li><p>堆栈的功能是怎样实现的呢？首先，堆栈其实就是一段普通的RAM存储空间，只是这段空间相对独立不另作他用。8080微处理器设置了一个专门的16位寄存器对这段存储空间寻址，这个特殊的寄存器称为堆栈指针（SP，Stack Pointer）。</p></li><li><p>在8080中，执行PUSH指令实际上是把16位的数据保存到堆栈，执行POP指令是把这些数据从堆栈中取回至寄存器。</p></li><li><p>每执行一条PUSH指令，堆栈都会增加两个字节，这可能会导致程序出现一些小错误——堆栈可能会不断增大，最终覆盖掉存储器中保存的程序所必需的代码或数据。这种错误被称作堆栈上溢（stackoverflow）。类似的，如果在程序中过多地使用了POP指令，则会过早地取完堆栈中的数据从而导致类似的错误，这种情况称为堆栈下溢（stack underflow）。</p></li><li><p>根据摩尔定律（Moore’s Law），微处理器中的晶体管数量每18个月翻一倍，增加的这些大量的晶体管用来做什么呢？</p><ul><li>一些晶体管用来适应处理器不断增加的数据宽度——从4位、8位、16位到32位；</li><li>另一些新增的晶体管用来应对新的指令。</li></ul></li><li><p>现代处理器主要使用2种策略来提高运行速度:</p><ul><li>一种就是流水线技术（pipelining），即处理器在执行一条指令的同时读取下一条指令，</li><li>还有一种是Cache（高速缓冲存储器），它是一个设置在处理器内部，访问速度非常快的RAM阵列，用来存放处理器最近要执行的指令</li></ul><p>这两种策略都需要在处理器内部增加更多的逻辑组件和晶体管。</p></li></ol><h2 id="ascii码和字符转换">20　ASCII码和字符转换</h2><ol type="1"><li>存储器中唯一可以存储的东西是bit</li><li>如果我们想把一段文本存下来该怎么办呢？将文本表示成数字。</li><li>可以为每一个字母赋予一个唯一的编码，具有这种功能的系统叫 字符编码集（Coded CharacterSet），系统内的每个独立编码称为字符编码（Character Codes）</li><li>莫尔斯码: 常用字符的编码较短，而不常用字符的编码较长。这样的编码非常适合电报系统，但并不适用于计算机.</li><li>对一个句子进行编码后得到的连续字符通常被称为文本字符串（string）</li><li>电传打字机键盘上的每一个键实质上都起到了转换器的作用，它负责产生二进制编码并且通过输出电缆逐位传输出去</li><li>尽管ASCII码是计算机领域最重要的标准,但是它是太美国化了，在其他国家ASCII码并不适用。</li><li>近几十年来出现了许多不同版本的扩展的ASCII码，多个不同的版本严重影响了编码的一致性，导致了混淆和不兼容。ASCII码被扩展到极致，有的甚至可以对中文、日文和韩文进行编码</li><li>从1988年开始，几大著名计算机公司合作研究出一种用来替代ASCII码的编码系统，取名为Unicode（统一化字符编码标准）。相对于ASCII的7位编码，Unicode采用了16位编码，每一个字符需要2个字节。</li><li>Unicode编码不是从零开始设计的，前128个字符编码——即0000h～007Fh——与ASCII码是一致的</li><li>对于Unicode来讲，它唯一的问题，就是它改变了字符与存储空间之间“单字符，单字节”的等价对应关系。采用ASCII编码方式存储的著作《怒火之花》，其所占据的存储空间约为1 MB。而如果采用Unicode编码，约占2 MB。为了使编码系统兼容，Unicode在存储空间上付出了相应的代价。</li></ol><blockquote><p>UTF-8是unicode的升级版，减少存储空间。</p></blockquote><p>你看到的unicode字符集是这样的编码表： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">I 0049</span><br><span class="line">t 0074</span><br><span class="line">&#x27; 0027</span><br><span class="line">s 0073</span><br><span class="line">  0020</span><br><span class="line">知 77e5</span><br><span class="line">乎 4e4e</span><br><span class="line">日 65e5</span><br><span class="line">报 62a5</span><br></pre></td></tr></table></figure></p><p>每一个字符对应一个十六进制数字。计算机只懂二进制，因此，严格按照unicode的方式(UCS-2)，应该这样存储： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">I 00000000 01001001</span><br><span class="line">t 00000000 01110100</span><br><span class="line">&#x27; 00000000 00100111</span><br><span class="line">s 00000000 01110011</span><br><span class="line">  00000000 00100000</span><br><span class="line">知 01110111 11100101</span><br><span class="line">乎 01001110 01001110</span><br><span class="line">日 01100101 11100101</span><br><span class="line">报 01100010 10100101</span><br></pre></td></tr></table></figure></p><p>这个字符串总共占用了18个字节，但是对比中英文的二进制码，可以发现，英文前9位都是0！浪费啊，浪费硬盘，浪费流量。怎么办？UTF。</p><p>于是，”It's 知乎日报“就变成了： <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">I 01001001</span><br><span class="line">t 01110100</span><br><span class="line">&#x27; 00100111</span><br><span class="line">s 01110011</span><br><span class="line">  00100000</span><br><span class="line">知 11100111 10011111 10100101</span><br><span class="line">乎 11100100 10111001 10001110</span><br><span class="line">日 11100110 10010111 10100101</span><br><span class="line">报 11100110 10001010 10100101</span><br></pre></td></tr></table></figure> 和上边的方案对比一下，英文短了，每个中文字符却多用了一个字节。但是整个字符串只用了17个字节，比上边的18个短了一点点。</p><p><img src="img_1.png" alt="img_1.png" /> ## 参考</p><ol type="1"><li><a href="https://weread.qq.com/web/reader/64e32bf071fd5a9164ece6b">编程：隐匿在计算机硬件背后的语言</a></li><li>https://www.zhihu.com/question/23374078/answer/65352538</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;二进制加法器&quot;&gt;12 二进制加法器&lt;/h2&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;电路中的逻辑门能实现二进制加法。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;逻辑门是认为设计的一种电路走线，为了映射到逻辑上的加法运算。&lt;/p&gt;
&lt;p&gt;逻辑门是链接物理世</summary>
      
    
    
    
    <category term="阅读" scheme="https://chiechie.github.io/categories/%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="编程" scheme="https://chiechie.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>时序预测最佳实践</title>
    <link href="https://chiechie.github.io/2021/06/05/AI/timeseries/quantml-practice/"/>
    <id>https://chiechie.github.io/2021/06/05/AI/timeseries/quantml-practice/</id>
    <published>2021-06-04T16:06:21.000Z</published>
    <updated>2021-06-11T01:47:17.437Z</updated>
    
    <content type="html"><![CDATA[<h1 id="建模pipeline">建模pipeline</h1><ol type="1"><li>搜集原始数据: 过去十年的成交数据</li><li>数据筛选: 选择交易日，固定时间段（９:30~15:30)的数据</li><li>对选好的数据进行采样，并不能保证每天都有整数个点</li><li>切分训练集 &amp; 验证集</li><li>模型训练<ul><li>归一化训练集，&lt;x， target&gt;</li><li>训练</li></ul></li><li>模型评估<ul><li>归一化验证集</li><li>预测&amp;画图：</li></ul></li></ol><p>实践过程中遇到的一些问题，需要逐一解决，下面记录其中一些</p><h1 id="问题集合">问题集合</h1><h2 id="问题1.-验证集的mse比训练集低但相关系数训练集远远大于调参集这是bug">问题1. 验证集的mse比训练集低，但相关系数训练集远远大于调参集，这是bug？</h2><p>没有bug，mse和correlation评估的侧重点不一样。</p><p>mse小，但是correlation也小的例子，如下图：</p><p><img src="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Frf_learning%2FNUSWvXNmWb.png?alt=media&amp;token=8c03a9f3-60e1-424d-879e-3371c1516623" /></p><p>几个距离：</p><ul><li>欧式距离（mse）量化的 是两个实体（或者两个群体）之间的绝对物理距离</li><li>余弦距离（correlation）量化的是 两个实体（或者两个群体）相对原点的角度的距离</li><li>pearson衡量的是 两个变量 之间的 线性相关性，具体做法是使用一个直线去拟合多组样本点&lt;变量1，变量2&gt; ，直线斜率就是相关性大小。</li></ul><h2 id="问题3怎么解决分布漂移的问题">问题3：怎么解决分布漂移的问题？</h2><p>分布漂移在时序预测中尤其常见，使用滑动窗口的均值来 做中心化</p><h2 id="问题4还有哪些措能提升实验效果">问题4：还有哪些措能提升实验效果？</h2><p>取效果好和效果差的两组实验进行对比，观察到1个现象：使用短期趋势中心化后，在使用长期趋势归一化，能使效果变好，背后的理论依据是什么？</p><p>分析下：因为用到了更长的历史数据作为参考,本身模型是记不住那么长的历史信息的。（输入才半个小时）</p><p><img src="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Frf_learning%2Fg6FAdLzkOj.png?alt=media&amp;token=362ed41e-1773-4ff5-ac41-a3095f75bb86" /></p><p>参考: <a href="https://github.com/Arturus/kaggle-web-traffic/blob/master/how_it_works.md">doc</a></p><h2 id="问题5-过拟合的原因">问题5： 过拟合的原因</h2><p>训练集 的比例远大于 验证集 和测试集</p><h2 id="问题6-是不是预测的准就能挣钱了">问题6： 是不是预测的准就能挣钱了？</h2><p>不是，回测的时候要考虑滑点，交易费用，爆仓风险</p><h2 id="问题7同样一个预测模型lstm商品期货准确率比股指差这么多">问题7：同样一个预测模型（LSTM），商品期货准确率比股指差这么多？</h2><ul><li>因为1min的股指期货数据平滑，噪声少，而1min的商品期货毛刺非常多</li><li>将1min的商品期货聚合成5min之后，再使用过去1h的数据预测未来1h的数据，准确率非常之高</li></ul><p>数据颗粒度太细时 噪声很大， 直接丢给模型，也可能造成模型学不好。（这个已经在quantML实践上面得到了证实）</p><h2 id="问题8直接用回归模型预测价格可能有负数怎么处理">问题8：直接用回归模型预测价格，可能有负数怎么处理</h2><p>预测增长率</p><h2 id="问题9除了直接回归还有哪些方法">问题9：除了直接回归，还有哪些方法？</h2><p>转化为分类问题，换预测涨跌幅</p><h1 id="其他经验">其他经验</h1><ol type="1"><li><p>不同品种的训练数据，分组训练 比 汇总训练 效果好。</p><blockquote><p>一定要汇总训练的话，要加入每个品种的静态特征，不然会学到混乱的模式。</p></blockquote></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;建模pipeline&quot;&gt;建模pipeline&lt;/h1&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;搜集原始数据: 过去十年的成交数据&lt;/li&gt;
&lt;li&gt;数据筛选: 选择交易日，固定时间段（９:30~15:30)的数据&lt;/li&gt;
&lt;li&gt;对选好的数据进行采样，并不能保证每</summary>
      
    
    
    
    <category term="实践" scheme="https://chiechie.github.io/categories/%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="人工智能" scheme="https://chiechie.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    <category term="最佳实践" scheme="https://chiechie.github.io/tags/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    
    <category term="时序预测" scheme="https://chiechie.github.io/tags/%E6%97%B6%E5%BA%8F%E9%A2%84%E6%B5%8B/"/>
    
    <category term="量化交易" scheme="https://chiechie.github.io/tags/%E9%87%8F%E5%8C%96%E4%BA%A4%E6%98%93/"/>
    
  </entry>
  
  <entry>
    <title>量子计算机</title>
    <link href="https://chiechie.github.io/2021/06/04/reading_notes/computer/liangzijisuanji/"/>
    <id>https://chiechie.github.io/2021/06/04/reading_notes/computer/liangzijisuanji/</id>
    <published>2021-06-04T01:05:44.000Z</published>
    <updated>2021-06-04T01:32:47.631Z</updated>
    
    <content type="html"><![CDATA[<h2 id="why">why？</h2><ol type="1"><li>最早提出用量子体系来计算，或者说模拟量子物理问题的科学家是费曼，不过当时只是一个概念。</li><li>真正从数学上证明有效的算法，是20世纪90年代数学家提出的两类算法：Shor算法和Grover算法.</li><li>Shor算法解决质因数分解问题。用量子的逻辑电路，可以将大数分解问题的求解时间从指数级降低为准多项式级。大数不可分正是现在互联网上应用最广泛的非对称加密系统，也叫公钥加密系统的数学基础。用现在最好的算法破解2048位数的公钥密码，需要超过100万年时间，而用Shor算法只需要几分钟</li><li>Grover算法是一个搜索算法，它可以将无结构的数据搜索问题从N复杂度降低为根号N复杂度。虽然加速能力不如Shor算法，但搜索算法是一种非常基础的算法，可以映射到多种实际问题中去。当N非常大时，这种加速效应也非常显著。目前互联网中每时每刻产生的海量数据，要从中寻找有用信息，正对应着这种N非常大的情况。此外，搜索算法还可以用来进行密码破解。</li><li>此外，量子计算还可以通过模拟复杂系统的哈密顿量来进行量子化学计算，研究原来很难研究的复杂多体物理问题；通过量子纠缠特性，量子计算还可以快速计算多参量的代价函数，从而提高优化问题的求解效率，在人工智能方面也有潜在的应用价值。</li></ol><h2 id="量子计算可以解决什么问题">量子计算可以解决什么问题？</h2><ol type="1"><li>计算科学中，所有的计算问题可以分为可判定问题和不可判定问题。</li><li>计算机能够解决的只是可判定类问题，也就是可计算问题。</li><li>NP问题中还有一类NP完全问题，计算复杂度指数增长，其中包括非常经典的最大割问题、行商问题等等。量子计算目前无法解决。</li></ol><figure><img src="img.png" alt="img.png" /><figcaption aria-hidden="true">img.png</figcaption></figure><h2 id="怎么实现量子计算">怎么实现量子计算？</h2><ol type="1"><li><p>从理论上看，比较简单，先把问题用比特进行编码，算完之后观测结果 <img src="img_1.png" alt="img_1.png" /></p></li><li><p>从实现上看，比较有挑战，因为实现过程中会有噪声，并且量子不好操控和测量。</p><blockquote><p>量子计算的理论和算法研究早在上世纪八九十年代就出现了，而实验物理研究却一直到2000年以后才逐渐走上快车道。</p></blockquote></li><li><p>现实世界中，能够用来做量子计算的体系有很多，包括自然原子、离子阱、光子、二维电子气、NV-色心、核自旋、冷原子，以及超导量子比特，等等。哪些是优秀的“量子比特”，能成功构建出实用的量子计算机呢？要满足以下条件（Divincenzo准则”）：</p><ul><li>可以构建一组可扩展的大量量子比特，并且能够很好的表征它们</li><li>能够对量子比特进行初始化</li><li>量子比特必须具有足够长的退相干时间</li><li>能实现一组通用的量子门操作</li><li>能够很好地测量这些量子比特的最终状态</li></ul></li><li><p>基于超导量子比特的超导量子计算，满足上面五点，成为现在各大头部公司最看好的技术方案</p></li></ol><h2 id="现状以及未来展望">现状以及未来展望</h2><ol type="1"><li>2019年10月，Google在Science上刊出了一篇论文，介绍了他们验证了量子霸权的实验结果。个实验让全世界都备感兴奋，谷歌的CEO皮查伊评价这个实验的意义，就像当年莱特兄弟发明了第一驾飞机。不过，正如第一驾民用客机要到50多年后才诞生，量子计算机走入千家万户，仍有很长的路要走。 <img src="img_2.png" alt="img_2.png" /></li></ol><h2 id="参考">参考</h2><ol type="1"><li>https://weibo.com/ttarticle/x/m/show/id/2309404644282962411850?<em>wb_client</em>=1</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;why&quot;&gt;why？&lt;/h2&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;最早提出用量子体系来计算，或者说模拟量子物理问题的科学家是费曼，不过当时只是一个概念。&lt;/li&gt;
&lt;li&gt;真正从数学上证明有效的算法，是20世纪90年代数学家提出的两类算法：Shor算法和Grove</summary>
      
    
    
    
    <category term="阅读" scheme="https://chiechie.github.io/categories/%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="人工智能" scheme="https://chiechie.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    <category term="未来趋势" scheme="https://chiechie.github.io/tags/%E6%9C%AA%E6%9D%A5%E8%B6%8B%E5%8A%BF/"/>
    
    <category term="量子计算机" scheme="https://chiechie.github.io/tags/%E9%87%8F%E5%AD%90%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>汇率机制</title>
    <link href="https://chiechie.github.io/2021/06/03/reading_notes/economics/huilv/"/>
    <id>https://chiechie.github.io/2021/06/03/reading_notes/economics/huilv/</id>
    <published>2021-06-03T00:28:28.000Z</published>
    <updated>2021-06-03T00:58:35.711Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>中国可以无限印钞购买美国的东西吗？</p></blockquote><p>蒙代尔三角：本国货币政策的独立性（印钞权），汇率的稳定性，资本自由流动，3选2，必须放弃一个。</p><p>蒙代尔三角短期可以三种都实行，但是最终会提供套利机会，导致三者里面必须放弃一个。 例如92-98年的泰国，三者都要导致外汇掏空，固定汇率无法维持，引起亚洲金融危机。</p><table><thead><tr class="header"><th></th><th>货币主权</th><th>汇率的稳定性</th><th>资本自由流动</th></tr></thead><tbody><tr class="odd"><td>英国/希腊等欧盟国家</td><td>No</td><td>Yes</td><td>Yes</td></tr><tr class="even"><td>中国香港</td><td>No</td><td>Yes</td><td>Yes</td></tr><tr class="odd"><td>中国大陆</td><td>Yes</td><td>有限</td><td>有限</td></tr><tr class="even"><td>美国</td><td>有限</td><td>有限</td><td>Yes</td></tr></tbody></table><h2 id="香港政府怎么发币的">香港政府怎么发币的？</h2><p>法律规定，香港的发钞银行在发行钞票时，需要找7.8:1的汇率向金管局提交等值美元，并计入外汇基金账目，作为所发钞票的支持。</p><h2 id="参考">参考</h2><ol type="1"><li><a href="https://www.zhihu.com/question/21611592/answer/18777171">一种货币和美元挂钩是怎样实现的？-知乎</a></li><li><a href="https://www.zhihu.com/question/67928805/answer/257923560">中国为什么不直接印大量的人民币去买美国的东西?知乎</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;中国可以无限印钞购买美国的东西吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;蒙代尔三角：本国货币政策的独立性（印钞权），汇率的稳定性，资本自由流动，3选2，必须放弃一个。&lt;/p&gt;
&lt;p&gt;蒙代尔三角短期可以三种都实行，但是最终会提供套利机会，导致三</summary>
      
    
    
    
    <category term="经济学" scheme="https://chiechie.github.io/categories/%E7%BB%8F%E6%B5%8E%E5%AD%A6/"/>
    
    
    <category term="经济学" scheme="https://chiechie.github.io/tags/%E7%BB%8F%E6%B5%8E%E5%AD%A6/"/>
    
    <category term="货币" scheme="https://chiechie.github.io/tags/%E8%B4%A7%E5%B8%81/"/>
    
    <category term="汇率" scheme="https://chiechie.github.io/tags/%E6%B1%87%E7%8E%87/"/>
    
  </entry>
  
  <entry>
    <title>强化学习5 蒙特卡洛树搜索</title>
    <link href="https://chiechie.github.io/2021/06/02/AI/reinforcement_learning/rl5-monte-calo/"/>
    <id>https://chiechie.github.io/2021/06/02/AI/reinforcement_learning/rl5-monte-calo/</id>
    <published>2021-06-02T08:58:05.000Z</published>
    <updated>2021-06-03T08:48:27.853Z</updated>
    
    <content type="html"><![CDATA[<h1 id="总结">总结</h1><ol type="1"><li>蒙特卡洛树搜索（MCTS）是一种基于模型的强化学习方法。</li><li>蒙特卡洛树搜索比价值学习和策略学习更难。</li><li>AlphaGp是一个围棋AI，依靠MCTS做决策，决策过程中需要策略网络和价值网络辅助。</li><li>AlphaGo真正跟人下棋的时候，做决策的不是策略网络或者价值网络，而是MCTS。</li><li>MCTS不需要训练，可以直接做决策，训练策略网络和价值网络的目的是辅助MCTS。</li></ol><h2 id="mcts的基本思想">MCTS的基本思想</h2><ol type="1"><li>高手是怎么下棋的？高手一般都会往前多看几步。</li><li>高手下棋，一般是动态看待局势，确保自己几步之后占据优势。如果只根据当前格局做判断，不考虑长远，肯定赢不了高手。</li><li>同理，AI下棋也应该跟高手一样，多往前看几步，枚举所有可能发生的情况，从而判断当前执行什么动作的胜算最大，这样远浩宇用策略网络输出一个动作。</li><li>AlphaGo每走一步，就要用MCTS做成千上万次模拟，基本思想如下：假设当前有3种可选的动作，每次模拟从三种动作中选出一种，然后将游戏进行到底，从而拿到最终结果。 重复成千上万次模拟，统计每种动作的胜负概率，发现胜率分别是48%、56%、52%。那么 AlphaGo 应当执行第二种动作，因为 它的胜算最大。然而实际做起来还有很多难点需要解决。</li></ol><h2 id="mcts的四个步骤">MCTS的四个步骤</h2><p>MCTS每次模拟都要经历四个步骤：选择（selection），扩展（expansion），估值（evaluation），回溯（backup）</p><h3 id="选择">选择</h3><ol type="1"><li><p>观察当前局势，找出符合规则的所有走位中最有胜算的那部分走位。 如何评估走位优劣？综合两方面：</p></li><li><p>看走位的胜率，就是动作价值</p></li><li><p>看策略网络给a的评分</p></li></ol><h3 id="扩展">扩展</h3><p>接下来，ALphaGo需要考虑：对方会怎么走？只能靠猜，使用"推己及人"的方式。使用策略网络模拟对手的策略， 策略网络站在对手角度，根据观测到的棋局，给出多个走位的概率，ALphaGo采样一个动作。 这个时候对手落下的子就是ALphaGo的新状态了。</p><p>上面的所有的走位都不是真实发生的，而是在AlphaGo的脑袋中推演的，</p><p>ALphaGo专门执行推演的模块就叫模拟器（就是环境，牛逼的很，自己构建出与现实平行的虚拟世界），</p><p>在模拟器中，ALphaGo每执行一个动作，模拟器就会返回一个新的状态。</p><p>如何搭建一个好的模拟器？关键在于构建的正确的状态转移函数，如果其跟事实偏离太远，那么模拟器就是一个废物。</p><p>AlphaGo如何构建好的模拟器呢？他利用了围棋的对称性：即我方视角的状态转移，等价于对方视角的真实策略--可以复用已经训练好的策略网络。</p><blockquote><p>有点类似理性市场假设，每个人都是同样聪明的人，市场不存在套利机会。</p></blockquote><p>在围棋场景，搭建模拟器很简单，但是其他场景就没有这么简单了。</p><p>比如机器人、无人车等应用，状态转移的构造需要物理模型，要考虑到力、运动、以及外部世界的干扰。 如果物理模型不够准确，导致状态转移函数偏离事实太远，那么 MCTS的模拟结果就不可靠。</p><h3 id="求值">求值</h3><p>AlphaGo在模拟器中交替落子，直到分出胜负，把结果记为r.但是r只是众多平行世界中的一个，把r就作为评判第一个走位的依据，未免过于随机。</p><p>有没有更加稳定的方法？AlphaGo的解决方案，把r与价值网络对下个状态的评价进行求和，得到了下一个状态的价值。</p><p>在实际实现的时候，AlphaGo在这一步训练了一个更小的策略网络。</p><p>为什么只在求值这一步使用小网络呢？因为这一步是连哥哥策略网络交替落子，并且通常要走一两百步，导致这步成为瓶颈。</p><p>用小的策略网络代替大的策略网络，可以大幅加速MCTS</p><h3 id="回溯">回溯</h3><p>对于下一步的每个状态，通过模拟都能得到多条记录--代表该状态的价值。</p><p>把假想走位的所有状态的所有价值记录，求平均，就能得到假想走位的价值。</p><p>将这个候选走位带回第一步，更新每个走位的分数，选出最高的，进行下一轮模拟</p><p><span class="math display">\[ \operatorname{score}(a) \triangleq Q(a)+\frac{\eta}{1+N(a)} \cdot \pi(a \mid s ; \boldsymbol{\theta}), \quad \forall a \]</span></p><h2 id="决策">决策</h2><p>一轮 选择-&gt;扩展-&gt;扩展-&gt;回溯只是执行了单次模拟。</p><p>实际上做一次决策之前，需要做成千上万次模拟。</p><p>每次模拟时，更新每个候选走位的score，选择最高分score，在模拟器执行。</p><p>经过成千上万次模拟后，最经常被选中的走位，就作为最终的决策依据。</p><p>注意，每次在真实世界走完一步，上一步存的分数都要清零。</p><p>总结下，AlphaGo下棋非常暴力：每走一步，都要在虚拟世界模拟几万局。</p><p>计算量是机器战胜柯洁的秘密武器。</p><h1 id="参考">参考</h1><ol type="1"><li><a href="https://netman.aiops.org/wp-content/uploads/2018/12/sunyq_IEEEAccess2018_HotSpot.pdf">HotSpot-英文paper</a></li><li><a href="https://mp.weixin.qq.com/s/Kj309bzifIv4j80nZbGVZw">HotSpot-中文</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;总结&quot;&gt;总结&lt;/h1&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;蒙特卡洛树搜索（MCTS）是一种基于模型的强化学习方法。&lt;/li&gt;
&lt;li&gt;蒙特卡洛树搜索比价值学习和策略学习更难。&lt;/li&gt;
&lt;li&gt;AlphaGp是一个围棋AI，依靠MCTS做决策，决策过程中需要策略</summary>
      
    
    
    
    <category term="AI" scheme="https://chiechie.github.io/categories/AI/"/>
    
    
    <category term="人工智能" scheme="https://chiechie.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    <category term="强化学习" scheme="https://chiechie.github.io/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>强化学习4 使用gym构建股票交易机器人</title>
    <link href="https://chiechie.github.io/2021/05/31/AI/reinforcement_learning/rl4-tradingrobot/"/>
    <id>https://chiechie.github.io/2021/05/31/AI/reinforcement_learning/rl4-tradingrobot/</id>
    <published>2021-05-31T07:01:49.000Z</published>
    <updated>2021-06-03T08:58:37.779Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>现在进行强化学习第2个实践项目--构建交易机器人，</p></blockquote><h2 id="思路">思路</h2><p>老路子，先构建environment 再构建agent：</p><ul><li>environment需要定义state，action类型，以及step和render方法。</li><li>agent需要定义策略函数，即每个state下最优action</li></ul><p>下面从0到构建一个,</p><p>为了构建environment，先简化问题:</p><ul><li>state: 过去3天close/open/high/low/volume5个指标的数据, shape = &lt;3, 5&gt;</li><li>action: 买/卖/持仓 + 数量(基于目前仓位的百分比), shape = &lt;2, &gt; ,</li><li>step方法返回<ul><li>state2: 第二天的close/open/high/low/volume5个指标的数据, shape = &lt;3, 5&gt;</li><li>reward：变动仓位 * 变化的股价</li></ul></li></ul><p>为了构建agent:</p><ul><li>随机策略</li><li>Q-table不行，因为state不连续了</li><li>naive策略：趋势策略，短期有上升趋势就买入，否则卖出。</li></ul><h2 id="实施">实施</h2><h3 id="step-1-自定义一个environment">step 1 自定义一个environment</h3><p>自定义一个environment，需要继承gym的标准环境类--gym.Env, 并实现类的关键方法，有step和reset</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomEnv</span>(<span class="params">gym.Env</span>):</span></span><br><span class="line">    metadata = &#123;<span class="string">&#x27;render.modes&#x27;</span>: [<span class="string">&#x27;human&#x27;</span>]&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, arg1, arg2, ...</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(CustomEnv, self).__init__()</span><br><span class="line">        self.action_space = <span class="literal">None</span></span><br><span class="line">        self.observation_space = <span class="literal">None</span></span><br><span class="line">                                       </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">step</span>(<span class="params">self, action</span>):</span>                                               </span><br><span class="line">        <span class="keyword">return</span> observation, reward, done, info</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reset</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> observation  <span class="comment"># reward, done, info can&#x27;t be included</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">render</span>(<span class="params">self, mode=<span class="string">&#x27;human&#x27;</span></span>):</span></span><br><span class="line">                                       </span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span> (<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="step1-1-定义环境类的构造函数">step1-1: 定义环境类的构造函数</h4><p>在构造函数中，定义state空间，和 action空间 state是连续的，action因为涉及到具体买卖多少份额，所以也有部分是连续的， 可以用gyn.space.Box来定义，需要指定上下界。 此外，为了简化问题，直接把一个df当作成员给这个子类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StockEnv</span>(<span class="params">gym.Env</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, df</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(StockEnv, self).__init__()</span><br><span class="line">        self.action_space = spaces.Box(low=-<span class="number">1</span>, high=<span class="number">1</span>,shape=(<span class="number">1</span>, ), dtype=np.float16)</span><br><span class="line">        self.observation_space = spaces.Box(low=<span class="number">0</span>, high=<span class="number">1</span>, shape=(<span class="number">3</span>, <span class="number">5</span>), dtype=np.float16)</span><br><span class="line">        self.df = df</span><br></pre></td></tr></table></figure><h4 id="step1-2-定义环境类的reset方法">step1-2: 定义环境类的reset方法</h4><p>定义环境类的reset方法，reset用来重置一局游戏。需要返回游戏的初始状态，收益为0， 计算收益的几个变量，账户净值，持股数量，余额，以及游戏开始的时间戳（这个可以随机设置的）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reset</span>(<span class="params">self</span>):</span></span><br><span class="line">    self.net_worth = <span class="number">10000</span></span><br><span class="line">    self.share_hold = <span class="number">0</span></span><br><span class="line">    self.current_step = <span class="number">2</span></span><br><span class="line">    self.cash = <span class="number">10000</span></span><br><span class="line">    observation = self.df.loc[self.current_step - WINDOW_SIZE + <span class="number">1</span>: self.current_step,  [<span class="string">&quot;open&quot;</span>, <span class="string">&quot;close&quot;</span>, <span class="string">&quot;high&quot;</span>, <span class="string">&quot;low&quot;</span>, <span class="string">&quot;volume&quot;</span>]]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> observation  <span class="comment"># reward, done, info can&#x27;t be included</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="step1-3-定义环境类的step方法">step1-3: 定义环境类的step方法</h4><p>定义step方法，step是标准环境类的标准方法，输入输出的格式是固定的，输入一个state，输出下一个state, reward, done, info。</p><p>这里涉及到交易的常识，补充下几个概念：</p><ul><li>net value：账户净值，也就是说账户当前现金+股票折现价值</li><li>cash：这里叫现金是为了方便理解。专业的叫法是balance。</li><li>action amount：一个百分比，基于当前账户余额（balance）可以买卖的比例。</li><li>done：什么时候一轮游戏结束？时间到了或者爆仓了，即net value &lt; 0了</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">step</span>(<span class="params">self, action</span>):</span></span><br><span class="line">    current_price = self.df.loc[self.current_step, <span class="string">&quot;close&quot;</span>]</span><br><span class="line">    <span class="comment"># action_type, action_percent = action</span></span><br><span class="line">    <span class="comment"># action = action[0]</span></span><br><span class="line">    action_amount = <span class="built_in">abs</span>(action)</span><br><span class="line">    buy = action &gt; <span class="number">0</span></span><br><span class="line">    sell = action &lt; <span class="number">0</span></span><br><span class="line">    <span class="comment"># 0表示买     </span></span><br><span class="line">    action_amount = self.cash * action_amount / current_price</span><br><span class="line">    reward = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> sell <span class="keyword">and</span> self.share_hold &lt; action_amount:</span><br><span class="line">        <span class="comment"># 不允许做空</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">elif</span> buy:</span><br><span class="line">        self.share_hold += action_amount</span><br><span class="line">        self.cash -= action_amount * current_price</span><br><span class="line">        reward = (self.df.loc[self.current_step + <span class="number">1</span>, <span class="string">&quot;close&quot;</span>] - current_price) * action_amount</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self.share_hold -= action_amount</span><br><span class="line">        self.cash += action_amount *  current_price</span><br><span class="line">        reward = - (self.df.loc[self.current_step + <span class="number">1</span>, <span class="string">&quot;close&quot;</span>] - current_price) * action_amount</span><br><span class="line"></span><br><span class="line">    self.current_step += <span class="number">1</span></span><br><span class="line">    observation = self._next_observation()</span><br><span class="line">    next_price = self.df.loc[self.current_step, <span class="string">&quot;close&quot;</span>]</span><br><span class="line">                                   </span><br><span class="line">    self.net_worth = self.cash + self.share_hold * next_price</span><br><span class="line">    done = self.net_worth &lt;= <span class="number">0.01</span></span><br><span class="line">                                         </span><br><span class="line">                                           </span><br><span class="line">    <span class="keyword">return</span> observation, reward, done, &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="step-2--定义策略policy">step 2- 定义策略policy</h3><h4 id="step-2-1-定义一个静态策略">step 2-1 定义一个静态策略</h4><p>这里先用一个简单的趋势策略作为baseline，如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def pi(obs):</span><br><span class="line">    close_list &#x3D; obs[&quot;close&quot;].values</span><br><span class="line">    ma &#x3D; close_list[:-1].mean()</span><br><span class="line">    price &#x3D;  close_list[-1]</span><br><span class="line"></span><br><span class="line">    if price &#x2F; ma &gt; 1.02:</span><br><span class="line">        action &#x3D; 0.2</span><br><span class="line">    elif price &#x2F; ma &lt; 0.98:</span><br><span class="line">        action &#x3D; -0.2</span><br><span class="line">    else:</span><br><span class="line">        action &#x3D; 0</span><br><span class="line">    return action</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h4 id="step-2-2-使用ppo算法构建策略">step 2-2 使用PPO算法构建策略</h4><p>PPO（Proximal Policy Optimization）算法结合了A2C和TRPO的idea，主要思路是， 每次更新策略时，新的策略不能离旧的策略太远，具体的做法是对梯度做截断（clipping）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">env_PPO = DummyVecEnv([<span class="keyword">lambda</span>: StockEnv(df)])</span><br><span class="line">model = PPO2(MlpPolicy, env_PPO, verbose=<span class="number">0</span>)</span><br><span class="line">model.learn(total_timesteps=<span class="number">100</span>)</span><br></pre></td></tr></table></figure><h4 id="step2-3-对比">step2-3 对比</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">df = pd.read_csv(<span class="string">&#x27;./stockdata/train/sh.600004.白云机场.csv&#x27;</span>)</span><br><span class="line">df = df.sort_values(<span class="string">&#x27;date&#x27;</span>)</span><br><span class="line">df[<span class="string">&quot;volume&quot;</span>] = df[<span class="string">&quot;volume&quot;</span>].<span class="built_in">map</span>(np.log)</span><br><span class="line"></span><br><span class="line">env_PPO = DummyVecEnv([<span class="keyword">lambda</span>: StockEnv(df)])</span><br><span class="line">env_basis = StockEnv(df)</span><br><span class="line">env_PPO1 = StockEnv(df)</span><br><span class="line"></span><br><span class="line">model = PPO2(MlpPolicy, env_PPO, verbose=<span class="number">0</span>)</span><br><span class="line">model.learn(total_timesteps=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">obs_PPO1 = env_PPO1.reset()</span><br><span class="line">obs_basis = env_basis.reset()</span><br><span class="line">env_PPO1.current_step = env_basis.current_step</span><br><span class="line">obs_PPO1 = obs_basis</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">200</span>):</span><br><span class="line">    action_PPO1, _ = model.predict(obs_PPO1)</span><br><span class="line">    action_basis = pi(obs_basis)</span><br><span class="line">    <span class="comment"># print(env_PPO1.current_step, env_basis.current_step)</span></span><br><span class="line">    obs_PPO, rewards_PPO, done_PPO, info_PPO = env_PPO1.step(action_PPO1)</span><br><span class="line">    obs_basis, rewards_basis, done_basis, info_basis = env_basis.step(action_basis)</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">20</span> ==<span class="number">0</span>:</span><br><span class="line">        print(<span class="string">&quot;****&quot;</span>*<span class="number">5</span>, <span class="string">&quot;PPO&quot;</span>, <span class="string">&quot;***&quot;</span>*<span class="number">5</span>)</span><br><span class="line">        env_PPO1.render()</span><br><span class="line">        print(<span class="string">&quot;****&quot;</span>*<span class="number">5</span>,<span class="string">&quot;Basis&quot;</span>,<span class="string">&quot;***&quot;</span>*<span class="number">5</span>)</span><br><span class="line">        env_basis.render()</span><br><span class="line">        </span><br></pre></td></tr></table></figure><p>还凑活吧，能用</p><figure><img src="img.png" alt="img.png" /><figcaption aria-hidden="true">img.png</figcaption></figure><h2 id="总结">总结</h2><ol type="1"><li>牛刀初试，强化学习实际效果不算离谱，凑活能用。</li><li>现有的强化学习算法框架比较成熟了, like stable-baselines，接口简单易用。</li><li>股票交易的Environment，github上还没有找到比较好用的工具，这个只能自己靠自己写了。上面写的一个简单的env，没有考虑交易费用/允许做空等情况，还要进一步细化。</li></ol><h2 id="参考">参考</h2><ol type="1"><li><a href="https://github.com/chiechie/quantML/blob/master/gym_rl.py">quantML-github-chiechie</a></li><li><a href="https://github.com/hill-a/stable-baselines">强化学习算法框架-stable-baselines</a></li><li><a href="https://www.oreilly.com/radar/introduction-to-reinforcement-learning-and-openai-gym/">强化学习环境框架-gym</a></li><li><a href="https://towardsdatascience.com/creating-a-custom-openai-gym-environment-for-stock-trading-be532be3910e">构建交易环境-medium</a></li><li><a href="https://github.com/wangshub/RL-Stock">构建交易环境和交易策略-github</a></li><li><a href="https://www.youtube.com/watch?v=5P7I-xPq8u8">PPO-youtube</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;现在进行强化学习第2个实践项目--构建交易机器人，&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;思路&quot;&gt;思路&lt;/h2&gt;
&lt;p&gt;老路子，先构建environment 再构建agent：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;environment需要定义</summary>
      
    
    
    
    <category term="AI" scheme="https://chiechie.github.io/categories/AI/"/>
    
    
    <category term="人工智能" scheme="https://chiechie.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    <category term="量化交易" scheme="https://chiechie.github.io/tags/%E9%87%8F%E5%8C%96%E4%BA%A4%E6%98%93/"/>
    
    <category term="强化学习" scheme="https://chiechie.github.io/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>十三邀-采访李安</title>
    <link href="https://chiechie.github.io/2021/05/30/reading_notes/reality/shisanyao-lian/"/>
    <id>https://chiechie.github.io/2021/05/30/reading_notes/reality/shisanyao-lian/</id>
    <published>2021-05-30T04:02:44.000Z</published>
    <updated>2021-05-31T00:46:04.218Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>看了昨天看十三邀采访李安那一期，关于如何面对恐惧，作为旁观者如何深入一个领域，李安分享了一些自己的经验</p><p>这些也是我比较困惑的地方，有一些触动，但是要完全解答我的困惑，还得考自己去实践吧</p></blockquote><h3 id="勤能补拙的旁观者">勤能补拙的旁观者</h3><p>许知远：你说你总是一个旁观者，旁观者可以进入不同的领域，通过研究理解事物，但它的劣势是什么？</p><p>李安：劣势就是不够地道，你只能用将心比心和勤快去弥补；另一个弥补就是电影不是我一个人拍的，这么多人参与，我总是可以跟他们商量，看看对不对，试试风向。</p><p>电影总是人家看嘛，只要你够勤快，天分到，你合作的伙伴愿意投入，入木三分是做得到的。</p><p>局外人的好处是看得比较准，而且一看就能看到； 局内人的话，你的成长经验、成见都会产生影响。</p><p>我觉得让局外人去做一个东西比较简单，但局内人的话，你要把自己的肉拿出来拧的话，有更大的难度。</p><p>事不关己，关己则乱。</p><p>chiechie: 我在研究一个新领域时，也经常会经常怀疑自己，所以要相信勤能补拙，做不到100分，80分总是可以的</p><h3 id="面对不安假装我是谁">面对不安"假装我是谁"</h3><p>许知远：被上了这么多次不同的“身”，面对不安全感、恐惧、挣扎，然后走出来，你觉得人变得更安全了吗？</p><p>李安：我想我们的成长不必靠电影去修炼，你可以用别的方式。我觉得我可能很像演员吧，年轻的时候我想过做演员，做不成，英文不会讲，就做了导演，所以我跟演员扮演角色的感觉很像。我记得梁朝伟跟我讲了一句话，他说“我们做演员很痛苦”，当然，好的演员才会这样讲。因为我每天都在说服他相信一些东西，他自己也相信了，然后就变成了那个人。拍完以后，又要说服自己不要去相信那个东西，要走出来，好累。而我可能就是用电影来扮演不同的角色吧。我觉得就像《色戒》里的主题一样，<strong>透过假装一件事情，你才会有胆量去触摸真实</strong>。<strong>我想人生倒是不可能没有一些好奇心，我们有自己的课业要学，这一辈子有很多东西要学，而这是一个很好的学习方式——“假装是谁”</strong>。</p><p>chiechie： 对于局内人，比如我工作中，要把我的亲身经验拿出来，反复的批判自己，让我感觉很痛苦，但是透过假装一件事情--假装我是谁，做产品的时候可以更有胆量去触摸真实。</p><h3 id="人生就像剥洋葱">人生就像剥洋葱</h3><p>李安：我觉得我也需要去摸自己不同的面向。</p><p>根据成长经验，你到了某一个面向，又到了某一个时间，你会对其他的主题产生兴趣，会遭遇一个困境，需要去触摸它，如果不去触摸的话，它会骚扰不休的。</p><p><strong>首先是要面对，然后去处理它，去处理它以后就可以把它 rationalize（理性化）了，你就定型了</strong>。</p><p>可是一个议题处理以后，你又会有新的会骚扰你的东西，你又要去面对它、处理它，然后把它理性化，<strong>这就跟剥洋葱一样，我想人生是剥不尽的</strong>。</p><h3 id="摸着石头过河">摸着石头过河</h3><p>许知远：那你现在最想剥的是哪块“洋葱”？你最想处理的是哪个主题？</p><p>李安：我不晓得，看下部电影吧。我可能会处理不同议题，也可能是用不同的角度来看同样的事情，这都很难讲，我不是天天思索这种问题的人，我不是搞哲学的。对，哲学有这个需要，它一定要有道理，而<strong>我是拍出来再制作道理</strong>。</p><p>我相信道家的玄之又玄，因为真的就是这样，摸不透，<strong>我只能在我可以触摸的地方去感受它</strong>。有时候触动别人的心的时候，也是有感应的，毕竟我们不是单独的存在嘛；感应多了有时候也有烦的时候，也有想独自一人的时候，<strong>人生也没有什么太大需要解答的东西，摸摸石头过河</strong>。</p><h3 id="命运的安排">命运的安排</h3><p>许知远：如果当时没有去美国，留在台湾，会是什么样？</p><p>李安：不晓得，我的命就是那个时候该离开。我说年纪到了，跟我的朋友冯光远一起去了，后来我们在纽约的人，大部分都回了台湾，很多人到了北京和上海，留在纽约的其实已经很少了。我那时候其实也想回来，可是刚好申请了绿卡，因为美国有一个经纪人签了我。学校刚毕业，太太还在读书，小孩生了，于是就在那边耗着。申请绿卡又好几年不能离开，也不能回台湾找工作，就这么耗着。说真的，我在念书的时候，从来没有想过可能在美国拍电影，这个事情在我脑子还不构成一个想象，连“梦想”都还没有。后来我得了台湾的一个奖，非拍那个片子不可，故事写的是美国，我才开始。后来那个片子又得奖了，一得国际奖，我又进了美国的艺术院线。</p><p>这也不是我设计出来的，好像是命运规定我这么走。现在好像<strong>东西两方我都沾到，有时候也会落到“缝隙”里面</strong>，这种经验也不少。</p><h3 id="失败的经历">失败的经历</h3><p>许知远：落到“缝隙”里是什么感觉？怎样描述这个“缝隙”？</p><p>李安：有一种黑暗无助的感觉。我不是每部电影都那么卖座成功的，我也受过好多打击，刚开始的时候也吃过很多苦头。</p><p>许知远：印象最深的打击是什么？</p><p>李安：不一而足啦，片子不卖座，没人看。但我觉得那片子也挺好，跟我成功的片子一样，<strong>我一样的拍，觉得差不多，可为什么别人不看呢</strong>？</p><p>电影有时真的是<strong>人算不如天算</strong>。</p><p>有的电影中西方都有市场，比如《断背山》这样的，突然大家都喜欢上了，这是没有国界的，我也不晓得为什么，我让一个台湾人看，他为什么会感动，我真的是不晓得。</p><p>我第一次受打击其实是拍完《冰风暴》，真没人看，《绿巨人》也是受打击的。</p><p>其实我受到的打击，我自己也不太知道，即便大约知道是什么，我也不敢肯定，所以会有一种惶恐的感觉，我也不是习惯受打击的。</p><h3 id="参考">参考</h3><ol type="1"><li><a href="https://www.sohu.com/a/349695818_563941">十三邀-许知远采访李安-文字稿</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;看了昨天看十三邀采访李安那一期，关于如何面对恐惧，作为旁观者如何深入一个领域，李安分享了一些自己的经验&lt;/p&gt;
&lt;p&gt;这些也是我比较困惑的地方，有一些触动，但是要完全解答我的困惑，还得考自己去实践吧&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id</summary>
      
    
    
    
    <category term="阅读" scheme="https://chiechie.github.io/categories/%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="许知远" scheme="https://chiechie.github.io/tags/%E8%AE%B8%E7%9F%A5%E8%BF%9C/"/>
    
    <category term="李安" scheme="https://chiechie.github.io/tags/%E6%9D%8E%E5%AE%89/"/>
    
    <category term="十三邀" scheme="https://chiechie.github.io/tags/%E5%8D%81%E4%B8%89%E9%82%80/"/>
    
    <category term="访谈录" scheme="https://chiechie.github.io/tags/%E8%AE%BF%E8%B0%88%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>关于雷蛇的个股研究</title>
    <link href="https://chiechie.github.io/2021/05/28/investment/about-leishe/"/>
    <id>https://chiechie.github.io/2021/05/28/investment/about-leishe/</id>
    <published>2021-05-28T05:31:24.000Z</published>
    <updated>2021-06-10T02:28:55.644Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>试着分析下</p><p>行业--&gt;护城河--&gt;未来增长--&gt;风险</p><p>分析不出啥？？？电脑主机？</p></blockquote><h2 id="行业分析">行业分析</h2><p>雷蛇属于电子消费行业，在2017-11-13 在港交所上市。</p><p>雷蛇卖什么？卖游戏周边，包括：</p><ul><li>硬件：游戏周边设备，鼠标键盘耳机，游戏笔记本</li><li>软件：？？</li><li>服务：支付服务。</li></ul><p>雷蛇的竞争对手，罗技</p><h3 id="关于显卡的产业链">关于显卡的产业链</h3><p>显卡供应商：AMD(AMD),英伟达(NVDA)</p><p>显卡消费者：矿工和游戏玩家</p><p>近半年，受到疫情影响，显卡供应减少，同时需求增多（主要是加密货币火爆行情刺激了矿机需求）</p><p>两种原因导致显卡涨价，但是雷蛇会受到什么影响？</p><figure><img src="about-cryptocurrency/img.png" alt="英伟达股价" /><figcaption aria-hidden="true">英伟达股价</figcaption></figure><figure><img src="./img_1.png" alt="AMD股价" /><figcaption aria-hidden="true">AMD股价</figcaption></figure><figure><img src="./img_2.png" alt="雷蛇股价" /><figcaption aria-hidden="true">雷蛇股价</figcaption></figure><h2 id="未来增长">未来增长</h2><p>集團更進一步拓展移動╱雲端遊戲、主機遊戲、直播產品及電競椅等增長領域</p><h2 id="新闻">新闻</h2><ol type="1"><li>雷蛇于5月12日在联交所回购855万股，每股价格介乎2.62至2.66846元，涉资约2,281.53万元。</li><li>2021年初至今雷蛇已回购约1.71亿股，占已发行股本约1.9229%。</li><li>2021年6月，大股东折价卖出大手笔股票，割韭菜了。</li></ol><h2 id="参考">参考</h2><ol type="1"><li><a href="https://doc.irasia.com/listco/hk/razer/annual/2020/crespress.pdf">雷蛇2020年财报</a></li><li><a href="https://news.futunn.com/post/9452174?lang=zh-cn&amp;src=2&amp;report_type=stock&amp;report_id=17625226&amp;level=1&amp;data_ticket=1615555035779921">雷蛇(01337.HK)斥约2,281万元回购855万股</a></li><li><a href="https://news.futunn.com/report/821714?lang=zh-cn&amp;src=43&amp;level=1&amp;data_ticket=1615555035779921">广发证券</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;试着分析下&lt;/p&gt;
&lt;p&gt;行业--&amp;gt;护城河--&amp;gt;未来增长--&amp;gt;风险&lt;/p&gt;
&lt;p&gt;分析不出啥？？？电脑主机？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;行业分析&quot;&gt;行业分析&lt;/h2&gt;
&lt;p&gt;雷蛇属于电子消费行业，在201</summary>
      
    
    
    
    <category term="投资" scheme="https://chiechie.github.io/categories/%E6%8A%95%E8%B5%84/"/>
    
    
    <category term="投资" scheme="https://chiechie.github.io/tags/%E6%8A%95%E8%B5%84/"/>
    
    <category term="行业研究" scheme="https://chiechie.github.io/tags/%E8%A1%8C%E4%B8%9A%E7%A0%94%E7%A9%B6/"/>
    
  </entry>
  
  <entry>
    <title>强化学习3 使用gym规划出租车行车路线的demo</title>
    <link href="https://chiechie.github.io/2021/05/27/AI/reinforcement_learning/rl3-gym/"/>
    <id>https://chiechie.github.io/2021/05/27/AI/reinforcement_learning/rl3-gym/</id>
    <published>2021-05-27T12:33:14.000Z</published>
    <updated>2021-05-31T07:07:22.467Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>看完了强化学习的理论，现在来动手试一试</p></blockquote><h2 id="场景介绍">场景介绍</h2><p>以出租车司机路线规划为背景，下面演示一下如何由强化学习解决这个问题</p><p>为了将问题进一步简化，基于已有的强化学习框架gym，我就可以更关注在策略实现了</p><p>首先强化学习将问题建模为两个部分：环境（environment）和 决策主体（agent）。 环境基于state，action给出反馈（reward），以及下一个时刻的reward。 agent基于state，给出最佳的action。</p><p>对于「出租车路线规划问题」，state就是给定区域：出租车坐标，行人坐标，行人目的地，障碍物（墙）的坐标，出租车当前是否已经载人</p><p>action就4个方向（东南西北），2个动作（载人，下客）</p><h2 id="开始编程实现啦">开始编程实现啦</h2><h3 id="step1-加载出租车路线规划这个环境">step1: 加载「出租车路线规划」这个环境</h3><p>因为gym已经带有这个环境，直接可用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gym</span><br><span class="line"></span><br><span class="line">env = gym.make(<span class="string">&quot;Taxi-v3&quot;</span>)</span><br><span class="line">env.reset()</span><br><span class="line"><span class="comment"># visulize current state</span></span><br><span class="line">env.render()</span><br></pre></td></tr></table></figure><figure><img src="img.png" alt="environment" /><figcaption aria-hidden="true">environment</figcaption></figure><p>上图环境渲染的图中</p><ul><li>黄色方块代表出租车当前的位置</li><li>“|”代表一堵墙，不能穿透</li><li>蓝色的字母表示载人地方</li><li>紫色的字母表示下客的地方</li><li>出租车接到人之后会编程绿色</li></ul><p>注意，这些颜色，形状只是方便人理解，算法内部只关心有5个状态</p><h3 id="step2-看一下action的6个状态">step2： 看一下action的6个状态</h3><p>看一下action的6个状态， down (0), up (1), right (2), left (3), pick-up (4), and drop-off (5). <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(env.action_space)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    print(env.action_space.sample())</span><br></pre></td></tr></table></figure> <img src="img_1.png" alt="img_1.png" /></p><h3 id="step3-跟env交互一次">step3: 跟env交互一次</h3><p>跟env交互一次，拿到反馈和最新的状态</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">state, reward, done, info = env.step(action=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><img src="img_3.png" alt="img_3.png" /> 注意：每个Gym环境的step方法都返回state, reward, done, info这四个变量，输入某个action</p><h3 id="step4-使用某个简单策略随机策略">step4： 使用某个简单策略（随机策略）</h3><p>使用某个简单策略（随机策略），让出租车跑完一轮</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">state = env.reset()</span><br><span class="line">env.render()</span><br><span class="line">n = <span class="number">0</span></span><br><span class="line">r = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    state, reward, done, info = env.step(action=env.action_space.sample())</span><br><span class="line">    r += reward</span><br><span class="line">    n = n + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> done:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">print(<span class="string">&quot;totally make %d decisions&quot;</span> % (n+<span class="number">1</span>), <span class="string">&quot;total reward&quot;</span>, r)</span><br><span class="line">env.render()</span><br></pre></td></tr></table></figure><figure><img src="img_4.png" alt="img_4.png" /><figcaption aria-hidden="true">img_4.png</figcaption></figure><h3 id="step5-升级策略-q-table-跑多轮">step5: 升级策略-Q-table, 跑多轮</h3><p>Q-table使用bellman方程迭代更新策略，并且存放到一张表中（这个表就是Q-table），即每个状态，每个action对应的Q-value</p><p><span class="math display">\[Q_{t+1}\left(s_{t}, a_{t}\right)=\underbrace{Q_{t}\left(s_{t}, a_{t}\right)}_{\text {old value }}+\underbrace{\alpha_{t}\left(s_{t}, a_{t}\right)}_{\text {learning rate }} \times[\overbrace{\underbrace{R_{t+1}}_{\text {reward }}+\underbrace{\gamma}_{\text {discount factor }} \underbrace{\max _{a} Q_{t}\left(s_{t+1}, a_{t}\right)}_{\text {estimate of optimal future value }}}^{\text {learned value }}-\underbrace{Q_{t}\left(s_{t}, a_{t}\right)}_{\text {old value }}]\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">n_state = env.observation_space.n</span><br><span class="line">n_action = env.action_space.n</span><br><span class="line">Q_table = np.zeros((n_state, n_action))</span><br><span class="line">alpha = <span class="number">0.615</span></span><br><span class="line">gamma = <span class="number">0.9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> episode <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">    state = env.reset()</span><br><span class="line">    <span class="comment">#env.render()</span></span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    r = <span class="number">0</span></span><br><span class="line">    done = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">while</span> done <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">        best_action = np.argmax(Q_table[state, :])</span><br><span class="line">        state2, reward, done, info = env.step(action=best_action)</span><br><span class="line">        Q_table[state, best_action] = Q_table[state, best_action] + alpha *(reward + gamma * np.<span class="built_in">max</span>(Q_table[state2]) - Q_table[state, best_action])</span><br><span class="line">        r += reward</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">        <span class="comment"># 别漏了</span></span><br><span class="line">        state = state2 </span><br><span class="line">    <span class="keyword">if</span> episode % <span class="number">50</span> == <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">&#x27;Episode &#123;&#125; Total Reward: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(episode,r))</span><br></pre></td></tr></table></figure><figure><img src="img_6.png" alt="img_6.png" /><figcaption aria-hidden="true">img_6.png</figcaption></figure><h2 id="遗留问题">遗留问题</h2><ol type="1"><li>策略函数要设置约束，比如不能撞墙</li></ol><h2 id="参考">参考</h2><ol type="1"><li><a href="https://www.oreilly.com/radar/introduction-to-reinforcement-learning-and-openai-gym/">强化学习环境框架-gym</a>)</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;看完了强化学习的理论，现在来动手试一试&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;场景介绍&quot;&gt;场景介绍&lt;/h2&gt;
&lt;p&gt;以出租车司机路线规划为背景，下面演示一下如何由强化学习解决这个问题&lt;/p&gt;
&lt;p&gt;为了将问题进一步简化，基于已有的强化</summary>
      
    
    
    
    <category term="AI" scheme="https://chiechie.github.io/categories/AI/"/>
    
    
    <category term="人工智能" scheme="https://chiechie.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    <category term="强化学习" scheme="https://chiechie.github.io/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>道德经(上) 1-37</title>
    <link href="https://chiechie.github.io/2021/05/26/daojia/daodejing1/"/>
    <id>https://chiechie.github.io/2021/05/26/daojia/daodejing1/</id>
    <published>2021-05-26T01:23:01.000Z</published>
    <updated>2021-06-15T01:05:04.004Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>道德经有多个版本：王弼注释/马王堆帛书等，帛书本距离老子的年代更近, 可信度更高。但是内容有缺失。</p><p>得其意即可，不必咬文嚼字</p></blockquote><h2 id="chiechies-总结">chiechie's 总结</h2><ol type="1"><li>道德经是给谁看的？古代是给君王和圣人看的。能力弱者，或受到挫折的人，容易误把道德经当作自己消极避世的借口。道德经中提到的"知者不博学"，"善者不辨"，"信言不美"，"利而不害"，"为而不争"，之所以可以不争，不辨，不博学，不美，都是有前提的，先要居其厚，居其实，才有资格"不争"，"不辩"。</li></ol><h2 id="道可道也非恒道">1 道可道也，非恒道</h2><blockquote><p>帛：道可道也，非恒道也。名可名也，非恒名也。无名万物之始也，有名万物之母也。故恒无欲也，以观其眇，恒有欲也，以观其徼。两者同出，异名同谓。玄之又玄，众妙之门。</p></blockquote><h2 id="有无之相生">2 有，无之相生</h2><blockquote><p>帛：天下皆知美之为美，恶矣，皆知善之为善，斯不善矣。有无之相生也，难易之相成也，长短之相形也，高下之相盈也，音声之相和也，先后之相随也。是以圣人居无为之事，行不言之教。万物作而弗始也，为而弗恃也，成功而弗居也，夫唯弗居，是以弗去。</p></blockquote><h2 id="使民无知无欲使夫知不敢弗为">3 使民无知无欲，使夫知不敢弗为</h2><blockquote><p>王：不尚贤，使民不争。不贵难得之货，使民不为盗；不见可欲，使民心不乱。是以圣人之治，虚其心，实其腹，弱其志，强其骨。常使民无知无欲，使夫智者不敢为也。为无为，则无不治。</p><p>帛：不上贤，使民不争。不贵难得之货，使民不为盗。不见可欲，使民不乱。是以圣人之治也，虚其心，实其腹，弱其志，强其骨，恒使民无知无欲也，使夫知不敢弗为而已，则无不治矣。</p></blockquote><p>苏辙《老子解》</p><p>尚贤，则民耻于不若而至于争；贵难得之货，则民病于无有而至于盗；见可欲，则民患于不得而至于乱。虽然，天下知三者之为患，而欲举而废之，则惑矣。圣人不然，未尝不用贤也，独不尚之耳；未尝弃难得之货也，独不贵之耳；未尝去可欲也，独不见之耳。夫是以贤者 用而民不争，难得之货、可欲之事毕效于前，而盗贼祸乱不起。是不亦虚其心而不害腹之实，弱其志而不害骨之强也哉！</p><p>「多元价值观」</p><p>今将举贤而尚之，宝货而贵之，眩可欲以示之，则是心与腹皆实也；若举而废之，则是志与骨皆弱也。心与腹皆实则民争，志与骨皆弱则无以立矣。不以三者眩之，则民不知所慕，淡然无欲。虽有智者，无所用巧矣。因三者之自然，而不尚、不贵、不见，所谓为无为也。</p><h2 id="挫其锐解其纷和其光同其尘">4 挫其锐，解其纷，和其光，同其尘</h2><blockquote><p>王： 道冲，而用之或不盈。渊兮，似万物之宗；挫其锐，解其纷，和其光，同其尘，湛兮，似或存。吾不知谁之子，象帝之先。 帛：道中，而用之又弗盈也，渊呵，似万物之宗。挫其锐，解其纷，和其光，同其尘，湛呵，似或存。吾不知谁之子，象帝之先。</p></blockquote><p>苏辙《老子解》</p><p>夫道冲然至无耳，然以之适众有，虽天地之大，山河之广，无所不遍。以其无形，故似不盈者。渊兮深眇，吾知其为万物宗也，而不敢正言之，故曰似万物之宗。</p><p>人莫不有道也，而圣人能全之。挫其锐，恐其流于妄也；解其纷，恐其与物搆也。不流于妄，不搆于物，外患已去而光生焉。又从而和之，恐其与物异也。光至洁也，尘至杂也。虽尘无所不同，恐其弃万物也。如是而后全，则湛然常存矣。</p><p>虽存而人莫之识，故曰似或存耳。道虽常存，终莫得而名，然亦不可谓无也，故曰此岂帝之先。帝先矣，而又先于帝，则莫或先之者矣。</p><p>搆，读音gòu，是一个汉字。 同“构”。 指构怨，结怨之意。</p><h2 id="多闻数穷不如守中">5 多闻数穷，不如守中</h2><blockquote><p>王：天地不仁，以万物为刍狗。圣人不仁，以百姓为刍狗。天地之间，其犹橐龠乎？虚而不屈，动而愈出。多言数穷，不如守中。</p><p>帛：天地不仁，以万物为刍狗。圣人不仁，以百姓为刍狗。天地之间，其犹橐龠乎？虚而不屈，动而愈出。多闻数穷，不如守中。</p></blockquote><p>橐龠(tuó yuè): 古代鼓风吹火用的器.</p><p>儒家提倡“读万卷书，不如行万里路”，道家却提倡“不出户，知天下”，“其出弥远，其知弥少”，“博者不知，知者不博”，“塞其兑，闭其门”。</p><p>老子的意思是：不要被外物复杂的声色变化迷惑而去追逐表象。为什么？因为它们是无穷无尽的。</p><p>比如现在的AI领域，追着最新的fancy的论文看，看的再多也没法把握技术发展的趋势。</p><h2 id="谷神不死是谓玄牝">6 谷神不死，是谓玄牝</h2><blockquote><p>帛：谷神不死，是谓玄牝。玄牝之门，是谓天地之根。绵绵呵若存，用之不堇。</p></blockquote><p>玄，原义是深黑色， 牝(pin)：是雌性的兽类动物 玄牝：指孕育和生养出天地万物的母体。 玄牝之門，言萬物自是出也。天地根，言天地自是生也。</p><h2 id="外其身而身存">7 外其身而身存</h2><blockquote><p>帛：天长地久。天地之所以能长且久者，以其不自生也，故能长生。是以圣人后其身而身先，外其身而身存，不以其无私邪，故能成其私。</p></blockquote><h2 id="水利万物而有静">8 水利万物而有静</h2><blockquote><p>帛：上善若水。水善利万物而有静，居众人之所恶，故几于道矣。居善地，心善渊，予善天，言善信，政善治，事善能，动善时。夫唯不争，故无尤。</p></blockquote><p>尤：怨咎、过失、罪过。</p><p>何为善？得道曰善。</p><p>居善地，。。。：避高趨下，未嘗有所逆，善地也。空虛靜默，深不可測，善淵也。利澤萬物，施而不求報，善仁也。圓必旋，方必折，塞必止，次爻流，善信也。洗滌群穢，平準高下，善治也。遇物賦形，而不留於一，善能也。冬凝春伴，涸溢不失節，善時也。</p><p>夫唯不争，故无尤：有善而不免於人非者，以其爭也。水惟不爭，故兼七善而無尤。</p><h2 id="功遂身退天之道也">9 功遂身退，天之道也。</h2><blockquote><p>帛：持而盈之，不如其已。揣而锐之，不可长葆之。金玉盈室，莫之守也，富贵而骄，自遗咎也。功遂身退，天之道也。</p></blockquote><p>已：止。</p><h2 id="明白四達能無知乎">10 明白四達，能無知乎？</h2><blockquote><p>帛：营魄抱一，能毋离乎?抟气致柔，能婴儿乎?修除玄览，能无疵乎?爱民治国，能毋以为乎?天门启阖，能为雌乎?明白四达，能毋以知乎?生之，畜之，生而弗有，长而弗宰也，是谓玄德。</p></blockquote><p>生之畜之，生而不有，為而不恃，長而不宰，是謂玄德:</p><p>圣人性定而神凝，不为物迁，虽以魄为舍，而神所欲行，魄无不从，则神常载魄矣。众人以物役性，神昏而不治，则神听于魄耳。目困以声色，鼻口劳于臭味，魄所欲行而神从之，则魄常载神矣。故教之以抱神载魄，使两者不相离。此固圣人所以修身之要。至于古之真人，深根固蒂，长生久视，其道亦由是也。</p><p>神不治则气乱，强者好斗，弱者喜畏，不自知也。神治则气不妄作，喜怒各以其类，是之谓专气。神虚之至也，气实之始也，虚之极为柔，实之极为刚。纯性而亡气，是之谓致柔。婴儿不知好恶，是以性全。性全而气微，气微而体柔，专气致柔如婴儿，极矣。圣人<strong>外不为魄所载，内不为气所使</strong>，则其涤除尘垢尽矣。于是其神廓然玄览，万物知其皆出于性，等观净秽而无所瑕疵矣。</p><p>内以治身，外以治国，至于临变，莫不有道也。非明白四达而能之乎？明白四达，心也，是心无所不知，然而未尝有能知之心也。夫心一而已，苟又有知之者，则是二也。自一而二，蔽之所自生，而愚之所自始也。今夫镜之于物，来而应之则已，又安得知应物者乎？本则无有而以意加之，此妄之源也。其道既足以生畜万物，又能不有不恃不宰，虽有大德，而物莫之知也，故曰玄德。</p><p>“涤除玄鉴，能无疵乎?”只有除却心头偏见，才能洞悉事物的本源，</p><h2 id="故有之以为利无之以为用">11 故有之以为利，无之以为用</h2><blockquote><p>王： 三十辐共一毂，当其无，有车之用。埏埴以为器，当其无，有器之用。凿户牖以为室，当其无，有室之用。故有之以为利，无之以为用。</p></blockquote><p>毂（gǔ）：是车轮中心的木制圆圈，中有圆孔，即插轴的地方。 埏（yàn）埴（zhì）：即用抟土和陶土做成饮食用的器皿 牖（yǒu）：窗户。</p><p>任何器具、房室、或机械要发生作用，都要有一「容纳」其他事物之「空间」，老子以此「空间」喻道之「无」，而容万物之性使万物发生作用。</p><p>竭知盡物以為器，而器之用常在無有中。非有，則無無以致其用，非無，則有无以施其利，是以聖人常無以觀其妙，常有以觀其徹。知兩者之為一而不可分，則至矣。</p><p>用尽智力和物力来制成器物，而器物发挥作用常常靠它空洞不实的部分。没有实际存在的物质部分就无法使用，没有空洞不实的部分就没法施展器物的功能。所以圣人常常从无概念、无称谓、无特征、不可辨的、无目的、无局限的宏观角度，来观察世界和万物的奥妙；常常从有概念、有称谓、有特征、可区分、有目的、受局限的微观角度，来观察某一特定事物与其他事物的边际，即万物的复杂差异和千变万化。人知道有与无是事物不可分割的两个方面，就完满极致了。</p><p>老子强调有无共重还是无更加重要，见仁见智，说法不一。但在现实生活中的确需要有无并重。对于自身修养来说既不能太过功利化，也不能成为一个空想家，立足于实际地生活在理想之中才是最好的处世方式;对于外部事物来说，要同时认识到它“有”的一面和“无”的一面，有时候正如庄子所说的“无用之用，方为大用”， eg做平台。</p><h2 id="难得之物令人行妨">12 难得之物令人行妨</h2><blockquote><p>王：五色令人目盲，五音令人耳聋，五味令人口爽，驰骋畋猎，令人心发狂，难得之货，令人行妨。是以圣人为腹不为目，故去彼取此。</p></blockquote><p>苏辙《老子解》</p><p>视色、听音、尝味，其本皆出于性。方其有性，而未有物也，至矣；及目缘五色、耳缘五音、口缘五味，夺于所缘而忘其本，则虽见而实盲，虽闻而实聋，虽尝而实爽也。</p><p>圣人视色、听音、尝味皆与人同，至于驰聘田猎未尝不为，而难得之货未尝不用也。然人皆以为病，而圣人独以为福，何也？圣人为腹，而众人为目，目贪而不能受，腹受而未尝贪故也。彼物之自外至者也，此性之凝于内者也。</p><h2 id="宠辱不惊">13 宠辱不惊</h2><blockquote><p>王：宠辱若惊，贵大患若身。何谓宠辱若惊？宠为下，得之若惊，失之若惊，是谓宠辱若惊。何谓贵大患若身？吾所以有大患者，为吾有身，及吾无身，吾有何患。故贵以身为天下，若可寄天下。爱以身为天下，若可托天下。</p></blockquote><p>苏辙《老子解》</p><p>古之达人，惊宠如惊辱，知宠之为辱先也。贵身如贵大患，知身之为患本也。是以遗宠而辱不及，忘身而患不至。所谓宠、辱，非两物也。辱生于宠，而世不悟，以宠为上而以辱为下者，皆是也。若知辱生于宠，则宠固为下矣。故古之达人，得宠若惊，失宠若惊，未尝安宠而惊辱也。所谓若惊者，非实惊也，若惊而已。</p><p>贵之为言难也，有身，大患之本，而世之士难于履大患，不难于有其身。故圣人因其难于履患，而教之以难于有身，知有身之为难，而大患去矣。性之于人，生不能加，死不能损，其大可以充塞天地，其精可以蹈水火、入金玉，凡物莫能患也。</p><p>然天下常患亡失本性，而惟身之为见，爱身之情笃，而物始能患之矣。生死病疾之变攻之于内，宠辱得失之交撄之于外，未有一物而非患也。夫惟达人知性之无坏，而身之非实，忽然忘身，而天下之患尽去，然后可以涉世而无累矣。</p><p>人之所以惊于权利、溺于富贵，犯难而不悔者，将以厚其身耳。今也禄之以天下，而重以身任之，则其忘身也至矣。如此而以天下予之，虽天下之大不能患之矣。</p><h2 id="执今之道以御今之有">14 执今之道，以御今之有</h2><blockquote><p>王：视之不见，名曰夷；听之不闻，名曰希；搏之不得，名日微。此三者不可致诘，故混而为一。其上不皦？其下不昧，绳绳兮不可名，复归于无物。是谓无状之状，无物之象，是谓惚恍⑨。迎之不见其首，随之不见其后。执古之道，以御今之有。能知古始，是谓道纪。</p></blockquote><blockquote><p>帛：执今之道，以御今之有，能知古始，是谓道纪。</p></blockquote><p>皦：jiǎo</p><p>庄子进一步的解释：“今子之所言，犹迹也。夫迹，履之所出，而迹岂履哉!”你学习的这些东西，都是先王留下来的遗迹，又哪里是他们的真实内涵呢？脚印是脚踩出来的，但脚印又哪里是脚呢！”</p><p>很像现在社会的浮躁教条之风.比如搞中台，也不管自己业务适合不适合。追求速成，不思索别人的决策路径，是否符合自己当前的situation，盲目照搬。</p><p>苏辙《老子解》</p><p>视之而见者色也，所以见色者不可见也。听之而闻者声也，所以闻声者不可闻也。搏之而得者触也，所以得触者不可得也。此三者，虽智者莫能诘也，要必混而归于一而可耳。所谓一者，性也，三者性之用也。人始有性而已，及其与搆，然后分裂四出，为视、为听、为触，日用而不知。反其本，非复混而为一则日远矣。若推广之，则佛氏所谓“六人皆然”矣。《首楞严》有云：“反流全一，六用不行。”此之谓也。</p><p>物之有形者，皆丽于阴阳，故上皦下昧，不可逃也。道虽在上而不皎，虽在下而不昧，难以形数推也。绳绳，运而不绝也，人见其运而不绝，则以为有物矣，不知为，卒归于无也。状其著也，象其微也。无状之状，无象之象，皆非无也。道无所不在，故无前后可见。古者物之所从生也，有者物之今，则无者物之古也。执其所从生，则进退疾徐在我矣。</p><h2 id="微妙玄通">15 微妙玄通</h2><blockquote><p>王：古之善为士者，微妙玄通，深不可识。夫唯不可识，故强为之容；豫兮若冬涉川；犹兮若畏四邻；俨兮其若客；涣兮其若凌释；敦兮其若朴；旷兮其若谷；混兮其若浊；澹兮其若海；飂兮若无止。孰能浊以静之徐清。孰能安以动之徐生。保此道者，不欲盈。夫唯不盈，故能蔽而新成。</p></blockquote><p>苏辙《老子解》</p><p>粗尽而微，微而妙，妙极而玄，玄则无所不通而深不可识矣。戒而后动曰豫，其所欲为，犹迫而后应。豫然若冬涉川，逡巡如不得已也。疑而不行曰犹，其所不欲，迟而难之，犹然如畏四邻之见之也。俨兮其若客，无所不敬，未尝惰也。涣兮若冰之将释，知万物之出于妄，未尝有所留也。敦兮其若朴，人伪已尽，复其性也。旷兮其若谷，虚而无所不受也。浑兮其若浊，和其光，同其尘，不与物异也。</p><p>世俗之士，以物汩性，则浊而不复清；枯槁之士以定灭性，则安而不复生。今知浊之乱性也则静之，静之而徐自清矣。知灭性之非道也，则动之，动之而徐自生矣。《易》曰：“寂然不动，感而遂通天下之故。”今所谓动者，亦若是耳。盈生于极，浊而不能清，安而不能生，所以盈也。物未有不蔽者也，夫惟不盈，故其弊不待新成而自去。</p><h2 id="致虚极守静">16 致虚极，守静</h2><blockquote><p>王: 致虚极，守静。万物并作，吾以观复。夫物芸芸，各复归其根。归根曰静，静曰复命。复命曰常，知常曰明。不知常，妄作凶。知常容，容乃公，公乃全，全乃天，天乃道，乃久，没身不殆。</p></blockquote><ul><li>笃（dǔ）</li></ul><p>苏辙《老子解》</p><p>致虚不极，则有未亡也；守静不笃，则动未亡也。丘山虽去，而微尘未尽，未为极与笃也。盖致虚存虚犹未离有，守静存静犹限于动，而况于他乎？不极不笃，而责虚静之用，难也！</p><p>虚极静笃，以观万物之变，然后不为变之所乱，知凡作之未有不复也。苟吾方且与万物皆作，则不足以知之矣。万物皆作于性，皆复于性，譬如华叶之生于根而归于根，涛澜之生于水而归于水。</p><p>苟未能自复于性，虽止动息念以求静，非静也。故惟归根，然后为静。命者，性之妙也。性可言，至于命则不可言矣。《易》曰：“穷理尽性以至于命。”圣人之学道，必始于穷理，中于尽性，终于复命。仁义礼乐，圣人之所以接物也，而仁义礼乐之用必有所以然者，不知其所以然而为之，世俗之士也，知其所以然而后行之，君子也。此之谓穷理。</p><p>虽然，尽性必穷理而后得之，不求则不得也。事物日构于前，必求而后能应，则其为力也劳，而其为功也少。圣人外不为物所蔽，其性湛然，不勉而中，不思而得，物至而能应，此之谓尽性。虽然，此吾性也，犹有物我之辨焉，则几于妄矣。君之命曰命，天之命曰命，以性接物而不知其为我，是以寄之命也。此之谓复命。</p><p>方其作也，虽天地山河之大，未有不变坏、不常者。惟复于性，而后湛然常存矣。不以复性为明，则皆世俗之智，虽自谓明，非明也。不知复性，则缘物而动，无作而非凶。虽得于一时，而失之远矣。方迷于妄，则自是而非彼，物皆吾敌，吾何以容？</p><p>苟知其皆妄，则虽仇雠犹将哀而怜之，何所不容哉！无所不容，则彼我之情尽，而尚谁私乎？无所不公，则天下将往而归之矣。无所不怀，虽天何以加之？天犹有形，至于道则极矣。然而虽道亦不能复进于此矣。</p><h2 id="信不足焉有不信焉">17 信不足焉，有不信焉</h2><blockquote><p>王: 太上，下知有之；其次，亲而誉之。其次，畏之。其次，侮之。信不足焉，有不信焉。悠兮其贵言。功成事遂，百姓皆谓：我自然。</p></blockquote><p>苏辙《老子解》</p><p>以道化育天下，而未尝治之，民不知其所以然，故亦有之而已。以仁义治天下，其德可怀，其功可见，故民得而亲誉之。其名虽美，而厚薄自是始矣。以政齐民，民非不畏也，然力之所不及，则侮之矣。</p><p>吾诚自信，则以道御天下足矣。唯不自信，以加之仁义，而重之刑政，而民始不信。圣人自信有余，其于言也犹然。贵之不轻出诸口，而民信之矣。及其功成事遂也，则民日迁善远罪而不自知矣。</p><h2 id="大道废有仁义">18 大道废，有仁义</h2><blockquote><p>王: 大道废，有仁义；慧智出，有大伪；六亲不和，有孝慈；国家昏乱，有忠臣。</p></blockquote><p>苏辙《老子解》</p><p>大道之隆也，仁义行于其中而民不知。大道废，而后仁义见矣。世不知道之足以统御万物也，而以智慧加之，于是民始以伪报之矣。六亲方和，孰非孝慈？国家方治，孰非忠臣？尧非不孝也，而独称舜，无瞽瞍也。伊尹周公，非不忠也，而独称龙逢、比干，无桀纣也。涸泽之鱼，相呴以沫，相濡以湿，不如相忘于江湖。</p><h2 id="绝圣弃智">19 绝圣弃智</h2><blockquote><p>王：绝圣弃智，民利百倍；绝仁弃义，民复孝慈；绝巧弃利，盗贼无有；此三者以为文不足。故令有所属，见素抱朴，少私寡欲，绝学无忧。</p></blockquote><p>苏辙《老子解》</p><p>非圣智不足以知道，使圣智为天下，其有不以道御物者乎？然世之人不足以知圣智之本而见其末，以为巧胜物者也，于是驰聘于其末流，而民始不胜其害矣。故“绝圣弃智，民利百倍”。</p><p>未有仁而遗其亲者也，未有义而后其君者也。仁义所以为孝慈矣，然及其衰也，窃仁义之名以要利于世，于是子有违父，而父有虐子，此则仁义之迹为之也。故“绝仁弃义，则民复孝慈”。巧所以便事也，利所以济物也。二者非以为盗，而盗贼不得则不行，故“绝巧弃利，盗贼无有”也。</p><p>世之贵此三者，以为天下之不安，由文之不足故也。是或属之圣知，或属之仁义，或属之巧利，盖将以文治之也。然而天下益以不安，曷不反其本乎？见素抱朴，少私寡欲，而天下各复其性，虽有三者，无所用之矣。故曰“我无为而民自化，我好静而民自正，我无事而民自富，我无欲而民自朴”，此则圣智之大、仁义之至、巧利之极也。</p><p>然孔子以仁义礼乐治天下，老子绝而弃之，或者以为不同。《易》曰：“形而上者谓之道，形而下者谓之器。”孔子之虑后世也深，故示人以器而晦其道，使中人以下守其器，不为道之所眩，以不失为君子。而中人以上，自是以上达也。</p><p>老子则不然，志于明道，而急于开人心，故示人以道而薄于器，以为学者惟器之知则道隐矣，故绝仁义、弃礼乐以明道。夫道不可言，可言皆其似者也。达者因似以识真，而昧者执似以陷于伪。故后世执老子之言，以乱天下者有之，而学孔子者无大过，因老子之言以达道者不少，而求之于孔子者常苦其无所从入。二圣人者皆不得已也，全于此必略于彼矣。</p><h2 id="俗人昭昭我独昏昏">20 俗人昭昭，我独昏昏</h2><blockquote><p>王：唯之与阿，相去几何？善之与恶，相去若何？人之所畏，不可不畏。荒兮，其未央哉！众人熙熙，如享太牢，如春登台。我独泊兮，其未兆；沌沌兮，如婴儿之未孩；儽儽兮，若无所归。众人皆有余，而我独若遗。我愚人之心也哉！俗人昭昭，我独昏昏。俗人察察，我独闷闷。澹兮其若海，飂兮若无止。众人皆有以，而我独顽且鄙。我独异于人，而贵食母。</p></blockquote><ul><li>唯：是唯诺顺从，“阿”是呵斥，引申为反对的意思</li><li>熙熙：快乐的样子。</li><li>太牢：古代代帝王祭祀时丰盛的筵席（有牛、羊、猪）。</li><li>泊兮：浑朴、淡泊的意思。</li><li>兆：征兆，迹象的意思。</li><li>沌沌(dùn)：不清楚。</li><li>孩：婴儿的笑声。</li><li>儽儽(liǎo)：疲倦的样子。儽，通“累”。</li><li>察察：苛刻之意。</li><li>闷闷：昏浊，不清楚的意思。</li><li>澹（dàn）：辽阔、辽远的意思。</li><li>飂(liǎo)：狂暴的风。</li><li>以：在这里作“用”字解。也有“能耐”意。</li></ul><p>苏辙《老子解》</p><p>为学日益，为道日损，不知性命之正，而以学求益增所未闻，积之未已，而无以一之。则以圆害方，以直害曲，其中纷然不胜其忧矣。患夫学者之至此，故曰“绝学无忧”。若夫圣人，未尝不学，而以道为主，不学而不少，多学而不乱，廓然无忧，安用绝学邪？</p><p>学者溺于所闻而无以一之，则唯之为恭，阿之为慢，不可同日言矣。而况夫善恶之相反乎？夫惟圣人知万物同出于性，而皆成于妄，如画马牛，如刻虎彘，皆非其实，泯焉无是非同异之辨，孰知其相去几何哉！苟如此矣，则万物并育而不相害，道并行而不相悖，无足怪矣。</p><p>圣人均彼我，一同异，其心无所复留，然岂以是忽遗世法、犯分乱理而不顾哉？人之所畏，吾亦畏之；人之所为，吾亦为之。虽列于君臣父子之间，行于礼乐刑政之域，而天下不知其异也。其所以不撄于物者，惟心而已。人皆徇其所知，故介然不出畦畛；圣人兼涉有无，无入而不可，则“荒兮其未可央”也。</p><p>人各溺于所好，其美如享太牢，其乐如春登台，嚣然从之而不知其非。唯圣人深究其妄，遇之泊然不动，如婴儿之未能孩也。乘万物之理而不自私，故若无所归。众人守其所知，各自以为有余；圣人包举万物，而不主于一，超然其若遗也。</p><p>沌沌，若愚而非愚也。世俗以分别为智，圣人知群妄之不足辨也，故其外若昏，其中若闷。忽然若海，不见其津涯；漂然无定，不见其止宿。人各有能，故世皆得而用之；圣人才全德备，若无所施，故疑于顽鄙。道者万物之母，众人徇物忘道，而圣人脱遗万物，以道为宗。譬如婴儿，无所杂食，食于母而已。</p><h2 id="孔德之容">21 孔德之容</h2><blockquote><p>王：孔德之容，惟道是从。道之为物，惟恍惟惚。惚兮恍兮，其中有象；恍兮惚兮，其中有物。窈兮冥兮，其中有精；其精甚真，其中有信。自今及古，其名不去，以阅众甫。吾何以知众甫之状哉！以此。</p></blockquote><ul><li>孔： 大</li><li>冥(mǐng)：暗昧不清楚</li><li>精：是极细微的物质性实体。</li><li>阅：认识。</li><li>甫：同“父”。</li></ul><p>道无形也，及其运而为德，则有容矣。故德者道之见，自是推之，则众有之容，皆道之见于物者也。道非有无，故以恍惚言之，然极其运而成象，著而成物，未有不出于恍惚者也。</p><p>方无有之未定，恍惚而不可见；及夫有无之交，则见其窈冥深眇，虽未成形，而精存乎其中矣。物至于成形，则真伪杂矣。方其有精，不容伪也。真伪既杂，自一而为二，自二而为三，纷然错出，不可复信矣。方其有精，不吾欺也。古今虽异，而道则不去，故以不去名之，惟未尝去，故能以阅众有之变矣。甫，美也。虽万物之美，不免于变也。圣人之所以知万物之所以然者，以能体道而不去故也。</p><h2 id="曲则全枉则直">22 曲则全，枉则直</h2><blockquote><p>王：曲则全，枉则直，洼则盈，敝则新，少则得，多则惑。是以圣人抱一为天下式。不自见，故明；不自是，故彰；不自伐，故有功；不自矜，故长。夫唯不争，故天下莫能与之争。古之所谓“曲则全”者，岂虚言哉！诚全而归之</p></blockquote><p>①式：法则。 ②伐：夸耀。 ③矜(jīn)：自高自大的意思。 ④莫：没有谁。</p><p>苏辙《老子解》</p><p>圣人动必循理，理之所在，或直或曲，要于通而已。通故与物不迕，不迕故全也。直而非理则非直也，循理虽枉，而天下之至直也。众之所归者下也，虽欲不盈，不可得矣。昭昭、察察，非道也；闷闷若将敝矣，而日新之所自出也。道一而已，得一则无不得矣。多学而无以一之，则惑矣。</p><p>迕：wǔ， 违背，冒犯。</p><p>抱一者，复性者也。盖曲则全，枉则直，洼则盈，弊则新，少则得，多则惑，皆抱一之余也，故以抱一终之。目不自见故能见物，镜不自照故能照物。如使自见自照，则自为之不暇，而何暇及物哉！不自见、不自是、不自伐、不自矜，皆不争之余也，故以不争终之。</p><p>抱一： 守道 复性：恢复本性</p><p>世以直为是，以曲为非，将循理而行于世，则有不免于曲者矣。故终篇复言之，曰此岂虚言哉，诚全而归之。夫所谓全者，非独全身也，内以全身，外以全物，物我兼全，而复于性，则其为直也大矣。</p><h2 id="天地尚不能久而况于人乎">23 天地尚不能久，而况于人乎</h2><blockquote><p>王：希言自然。故飘风不终朝，骤雨不终日。孰为此者?天地。天地尚不能久，而况于人乎。</p></blockquote><p>以飘风骤雨为天候中「阴」「阳」不调之例子。这就隐喻到「雷厉风行」，偏执一「仁」一「义」之治事方法是不能长久的;无论在当事人看来他的「政治理想」是多么完美或吸引人。</p><p>守弱：如婴儿般的柔和与可塑。</p><p>任何属性，操性，仁则都有其正负两面，也就是阴与阳。而属性明显曰「强」，属性混沌曰「弱」。如果根据一己之经验，认为一种属性，操性，仁则只有好处，没有缺陷，而拼命发展，必致「阴」「阳」失调而进入危境。</p><h2 id="自见者不明">24 自见者不明</h2><blockquote><p>王：企者不立；跨者不行；自见者不明；自是者不彰；自伐者无功；自矜者不长。其在道也．曰：余食赘形。物或恶之，故有道者不处。</p></blockquote><ul><li>赘（zhuì）: 多余的</li></ul><p>人未有不能立且行者也，苟以立为未足，而加之以跂，以行为未足，而加之以跨，未有不丧失其行立者。彼其自见自是、自矜自伐者，亦若是矣。譬如饮食，适饱则已，有余则病。譬如四体，适完则已，有赘则累。</p><h2 id="道法自然">25 道法自然</h2><blockquote><p>王： 有物混成，先天地生。寂兮寥兮，独立而不改，周行而不殆，可以为天地母。吾不知其名，强字之日道，强为之名曰大。大曰逝，逝曰远，远曰反。故道大，天大，地大，人亦大。域中有四大，而人居其一焉。人法地，地法天，天法道，道法自然。</p></blockquote><p>夫道非清非浊，非高非下，非去非来，非善非恶，混然而成体。其于人为性，故曰“有物混成”，此未有知其生者。盖湛然常存，而天地生于其中耳。寂兮无声，寥兮无形，独立无匹，而未尝变行于群。有而未尝殆，俯以化育万物，则皆其母矣。道本无名，圣人见万物之无不由也，故字之曰道。见万物之莫能加也，故强为之名曰大。然其实则无得而称之也。</p><p>自大而求之，则逝而往矣。自往而求之，则远不及矣。虽逝虽远，然反而求之一心足矣。由道言之，则虽天地与王皆未足大也。然世之人习知三者之大，而不信道之大也，故以实告之。人不若地，地不若天，天不若道，道不若自然。然使人一日复性，则此三者，人皆足以尽之矣。</p><h2 id="轻则失臣躁则失君">26 轻则失臣，躁则失君</h2><blockquote><p>王: 重为轻根，静为躁君。是以君子终日行不离辎重。虽有荣观，燕处超然。奈何万乘之主，而以身轻天下？轻则失根，躁则失君。</p></blockquote><p>凡物轻不能载重，小不能镇大，不行者使行，不动者制动，故轻以重为根，躁以静为君。行欲轻而不离辎重，荣观虽乐，而必有燕处，重静之不可失如此。人主以身任天下，而轻其身则不足以任天下矣。轻与躁无施而可，然君轻则臣知其不足赖，臣躁则君知其志于利，故曰“轻则失臣，躁则失君”。</p><h2 id="常善救人">27 常善救人</h2><blockquote><p>王: 善行无辙迹；善言无瑕谪；善数不用筹策；善闭无关楗而不可开；善结无绳约而不可解。是以圣人常善救人，故无弃人；常善救物，故无弃物。是谓袭明。故善人者，不善人之师；不善人者，善人之资。不贵其师，不爱其资，虽智大迷，是谓要妙。</p></blockquote><ul><li>瑕（xiá）谪（zhé）</li></ul><p>乘理而行，故无迹。时然后言，故言满天下无口过。万物之数，毕陈于前，不计而知，安用筹算？全德之人，其于万物如母之于子，虽纵之而不去。故无关而能闭，无绳而能约。彼方执策以计，设关以闭，持绳以结，其力之所及者少矣。圣人之于人，非特容之，又善救之，我不弃人，而人安得不归我乎？</p><p>救人于危难之中，非救之大者也。方其流转生死，为物所蔽，而推吾至明以与之，使暗者皆明，如灯相传相袭而不绝，则谓善救人矣。圣人无心于教，故不爱其资；天下无心于学，故不贵其师。圣人非独吾忘天下，能使天下忘我故也。圣人之妙，虽智者有所不谕也。</p><h2 id="物壮则老是谓不道">33 物壮则老，是谓不道</h2><blockquote><p>王: 果而勿矜，果而勿伐，果而勿骄。果而不得已，果而勿强。物壮则老，是谓不道，不道早巳。</p></blockquote><p>人之「老」在躯体也在头脑，最大的特征在失去思想之柔韧与变通---这些都是过分发展某一属性之「果」。人会变得过于执着固定事物，或过于刚猛，或过于退怯;百象皆有，不一而足;總之，都不合道。从老子之道来看就是失去「负阴抱阳」之特性。</p><h2 id="参考">参考</h2><ol type="1"><li><a href="https://www.aisixiang.com/data/37674.html">反者道之动, 弱者道之用”之詮釋</a></li><li>帛书老子校注-高明</li><li>苏辙《老子解》</li><li>https://www.5000yan.com/81.html</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;道德经有多个版本：王弼注释/马王堆帛书等，帛书本距离老子的年代更近, 可信度更高。但是内容有缺失。&lt;/p&gt;
&lt;p&gt;得其意即可，不必咬文嚼字&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;chiechies-总结&quot;&gt;chiechie&#39;s 总结&lt;</summary>
      
    
    
    
    <category term="阅读" scheme="https://chiechie.github.io/categories/%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="道家" scheme="https://chiechie.github.io/tags/%E9%81%93%E5%AE%B6/"/>
    
    <category term="哲学" scheme="https://chiechie.github.io/tags/%E5%93%B2%E5%AD%A6/"/>
    
    <category term="老子" scheme="https://chiechie.github.io/tags/%E8%80%81%E5%AD%90/"/>
    
    <category term="道德经" scheme="https://chiechie.github.io/tags/%E9%81%93%E5%BE%B7%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>风控领域的图挖掘场景</title>
    <link href="https://chiechie.github.io/2021/05/24/reading_notes/computer/visualize-graph/"/>
    <id>https://chiechie.github.io/2021/05/24/reading_notes/computer/visualize-graph/</id>
    <published>2021-05-24T01:08:21.000Z</published>
    <updated>2021-06-07T00:17:56.791Z</updated>
    
    <content type="html"><![CDATA[<h1 id="几个场景">几个场景</h1><h2 id="攻防对抗">攻防对抗</h2><p>一般都会有下述风控规则：</p><ul><li>7天内在注册账户数超过**的设备号</li><li>1天内某IP关联超过xx个账户</li></ul><p>虽然规则简单，但由于实时性和贴近业务的特点，可以拦截不少黑产, 但也会造成一定误杀，特别是IP类的规则。</p><p>同时因为风控是攻防对抗的过程，黑产也会升级，比如通过伪造设备、LBS、频繁更换IP等手段尽可能伪装成一个真人，隐蔽聚集性等显性特征，绕过风控规则。</p><p>相应风控技术也在进化，如使用设备指纹、IP画像、验证码对抗等。</p><h2 id="基于关联关系识别团伙">基于关联关系识别团伙</h2><p>可以定义设备-账户的Graph如下：</p><ul><li>节点：账户 + 设备</li><li>边：近xx天账户与设备出现在同一事件中，则它们之间有一条边。</li></ul><p>识别方法：</p><ul><li>无监督方法：通过「连通子图算法」识别出一个个连通的社区，如果社区规模较大，可能背后业务含义是黑产控制一批账户。定义社区规模为score，通过调节阈值来控制误杀、召回。</li><li>有监督方法-传统：等价为节点分类问题，通过提取节点业务特征、拓扑特征、所属社区特征，训练一个分类器去预测。</li><li>有监督方法-图神经网络：将节点业务特征X与网络拓扑结构A作为输入学习函数，用于对未知数据的预测.相比规则来说，此类方法不仅用到了更复杂的关系，同时也考虑了节点业务和拓扑特征。故防控能力会更强一些。</li></ul><h2 id="基于相似度识别团伙">基于相似度识别团伙</h2><p>如果黑产成功避开设备指纹、聚集性规则等风控措施，把自己伪装成一个真人，如何检测？——只要作案了，总会留下蛛丝马迹。</p><ul><li>垃圾文本：比如留下了垃圾文本，那么利用文本之间相似度（Jaccard、semi-hash）构建账户之间相似关系，然后使用图分割+连通子图查找技术识别，具体可<a href="https://zhuanlan.zhihu.com/p/23385044">参考这里</a></li><li>行为相似度：facebook针对刷量的行为，通过计算账户之间行为度来构建graph，<a href="https://zhuanlan.zhihu.com/p/58334765">详见这里</a>.此类方法最大问题是, 两两节点相似度计算性能问题。一般会做下约束，如限制在某个事件场景下、限制在某段事件内以及如何分段计算+合并，并且往往是通过spark分布式计算。</li></ul><h2 id="基于共享特征识别团伙">基于共享特征识别团伙</h2><p>因为黑产控制大量的账户通过软件进行攻击，而不是手工操作，故这些账户某些共同属性上会有Pattern。</p><p>大概的解题思路是“搜集证据”，将共享的某特征/字段作为，判断证据强弱，如共享设备是强证据，可以仅凭此条直接断案。 但是像共用某品牌手机是弱证据，需要多个弱证据结合一起断案。</p><p>再抽象一点是有点像「层次社区划分算法」：</p><ol type="1"><li>定义证据：通过业务经验定义共享特征集，不通场景特征集应该是不同的。</li><li>找证据：分别对每个/每组特征进行聚类/社区划分算法，得到一个个簇.</li><li>组合证据：将2得到的簇作为节点，簇之间共有账户数作为连边，构建graph，再进一步划分得到最终的社区，每个社区中的节点共享多个特征。</li></ol><h1 id="总结">总结</h1><ol type="1"><li>上述三种类型方法的主要区别在于graph的不同，在整个图挖掘体系中最核心也最难一点在于，如何将业务经验抽象成Graph。</li><li>社区发现算法以图分割+连通子图查找为主，一方面可解释强，另外可以通过调节阈值权衡召回和误差，以满足运营人员需要。这也是 "拿算法适配业务，而不是业务适配算法"的工作准则。</li></ol><h1 id="参考">参考</h1><ol type="1"><li><a href="https://scikit-network.readthedocs.io/en/latest/">scikit-network的doc</a></li><li><a href="https://www.zhihu.com/search?type=content&amp;q=%E5%9B%BE%E6%8C%96%E6%8E%98">zhihu-风控</a></li><li><a href="https://zhuanlan.zhihu.com/p/62750137">GCN</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;几个场景&quot;&gt;几个场景&lt;/h1&gt;
&lt;h2 id=&quot;攻防对抗&quot;&gt;攻防对抗&lt;/h2&gt;
&lt;p&gt;一般都会有下述风控规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;7天内在注册账户数超过**的设备号&lt;/li&gt;
&lt;li&gt;1天内某IP关联超过xx个账户&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;虽然规则简单</summary>
      
    
    
    
    <category term="阅读" scheme="https://chiechie.github.io/categories/%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="图数据" scheme="https://chiechie.github.io/tags/%E5%9B%BE%E6%95%B0%E6%8D%AE/"/>
    
    <category term="图挖掘" scheme="https://chiechie.github.io/tags/%E5%9B%BE%E6%8C%96%E6%8E%98/"/>
    
    <category term="连通子图算法" scheme="https://chiechie.github.io/tags/%E8%BF%9E%E9%80%9A%E5%AD%90%E5%9B%BE%E7%AE%97%E6%B3%95/"/>
    
    <category term="层次社区划分算法" scheme="https://chiechie.github.io/tags/%E5%B1%82%E6%AC%A1%E7%A4%BE%E5%8C%BA%E5%88%92%E5%88%86%E7%AE%97%E6%B3%95/"/>
    
    <category term="社区发现算法" scheme="https://chiechie.github.io/tags/%E7%A4%BE%E5%8C%BA%E5%8F%91%E7%8E%B0%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>

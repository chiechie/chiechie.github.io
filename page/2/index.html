<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"chiechie.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="a reader &amp; thinker">
<meta property="og:type" content="website">
<meta property="og:title" content="Chiechie&#39;s Mini World">
<meta property="og:url" content="https://chiechie.github.io/page/2/index.html">
<meta property="og:site_name" content="Chiechie&#39;s Mini World">
<meta property="og:description" content="a reader &amp; thinker">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Chiechie">
<meta property="article:tag" content="博客, AI, 互联网">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://chiechie.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Chiechie's Mini World</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Chiechie's Mini World" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Chiechie's Mini World</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Set your course by the stars, not by the lights of passing ships. —— Omar Bradley</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chiechie.github.io/2021/07/07/AFML/AFML3-md/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chiechie">
      <meta itemprop="description" content="a reader & thinker">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chiechie's Mini World">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/07/AFML/AFML3-md/" class="post-title-link" itemprop="url">《Advances in Financial Machine Learning》读书笔记3 回测</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-07 11:08:30" itemprop="dateCreated datePublished" datetime="2021-07-07T11:08:30+08:00">2021-07-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-08 15:49:20" itemprop="dateModified" datetime="2021-07-08T15:49:20+08:00">2021-07-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AFML/" itemprop="url" rel="index"><span itemprop="name">AFML</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="chapter-10-押注大小">chapter 10 押注大小</h2>
<blockquote>
<p>即使股价预测很准，但是头寸配置的不恰当，还是有可能亏钱。</p>
</blockquote>
<ol type="1">
<li>假定三期股价为 [1, 0.5, 1.25]，仓位1: [0.5, 1, 0] &amp; 仓位2: [1, 0.5, 0]，则前者挣钱而后者亏钱。</li>
<li>我们偏好这样的下注策略：建仓时保留一些现金，如果交易信号加强（股价变为0.5），就追加投资。</li>
<li>交易信号越强，下注可以越大，因为交易信号很难变得更强了。所以预测的概率 与下注之间可以构建一种函数关系. <img src="img.png" alt="img.png" /></li>
<li>如果每次预测时，如果交易信号的微小改变就要调仓，那换手率就太高了，作者建议可以对预测结果做滑动平均，或者将下注量离散化（如下图） <img src="img_1.png" alt="img_1.png" /></li>
<li>当股票的市场价格<span class="math inline">\(p_t\)</span>和预测价格<span class="math inline">\(f_t\)</span>波动时，可用如下方法动态地确定下注量<span class="math inline">\(\hat{q}_{i, t}\)</span>： <span class="math display">\[\hat{q}_{i, t}=\operatorname{int}\left[\frac{x}{\sqrt{w+x^{2}}} \cdot Q\right]\]</span>, <span class="math inline">\(x=f_{i}-p_{t}\)</span>为预测价与当前价的差价， Q为最大持仓量。 &gt; label就是交易信号，表示买或者卖, 两个label 如果是基于相同时间段的收益率 计算出来的，就说是concurrent的.</li>
<li>基于预测概率确定BET SIZING</li>
<li>平均主动BETS</li>
<li>动态BET SIZES 和 限定价格</li>
</ol>
<h2 id="chapter-11-回测有风险">chapter 11 回测有风险</h2>
<p>回测是量化中最重要但也最容易被误用的工具，本章将介绍回测时容易犯的错误。</p>
<ol type="1">
<li>一个物理实验室可以通过控制变量来探究精确的因果关系，而回测不是实验，它并不能证明一个策略好，只能证明一个策略不好。</li>
<li>要做好回测极其困难，我们至少会面临这些问题:
<ul>
<li>幸存者偏差：只用现存的股票构建投资组合回测，殊不知过去多少公司倒闭退市了；</li>
<li>Look-ahead bias：回测时用到的数据在那一刻还没发布；</li>
<li>事后诸葛亮（各种事后分析都在编故事）；</li>
<li>手续费：要模拟手续费很难，唯一准确的方式是上实盘；</li>
<li>空头：实际交易中如何找借方、空头的成本、空头的额度都需要考虑；</li>
</ul></li>
<li>即使避免了以上问题，你的回测也可能是错的——在一个数据集上回测了成百上千次才得到的漂亮结果，大概率是假的。如第八章所述，特征重要性分析帮助我们理解 ML 发现的结果，它在回测之前进行，是一种“事前“归因。相反，回测并不能帮我们理解为什么一个策略会盈利。通过回测发现的有效“因子”如同上一期彩票的中奖号码，对下一轮抽奖无益。回测前做好数据结构化、标签、加权比回测本身更重要。</li>
<li>重复回测带来的过拟合可以认为是一种选择偏差，要避免这种偏差可能是量化中最根本的问题。</li>
<li>以下步骤可以帮我们减少这种偏差:
<ul>
<li>在多种金融资产上回测：由于金融资产的多样性，如果你发现错误 只存在于债券，那该策略很可能是错的；</li>
<li>用 bagging 减少过拟合；在完成本书章节1-10 的研究之前别回测；</li>
<li>记录得到当前结果之前回测了多少次，从而推算出过拟合的可能性；</li>
<li>假如回测结果没能得到有效的策略，从头开始。千万不要在回测结果的基础上继续研究。 &gt; Backtesting while researching is like drinking and driving. &gt; Do not research under the influence of a backtest.</li>
</ul></li>
<li>如果用标准CV回测来选择策略，一些回测路径会重复出现，导致极易过拟合。所以一些随机性非常有必要，例如基于probability of backtest overfitting (PBO) 的回测。</li>
</ol>
<h2 id="chapter-12-使用交叉验证做回测">chapter 12 使用交叉验证做回测</h2>
<p>本章将介绍三种回测方法，希望能得到更准确的回测结果。</p>
<ol type="1">
<li>回测用历史数据来检验策略的样本外表现，这些历史数据有两种用法：狭义上，模拟策略的历史表现（walk-forward / WF）；广义上，模拟策略在特定市场环境（历史上不一定发生过）中的表现。前一种方式更广为人知，但两种方式各有利弊，都应掌握。WF 模拟策略在历史市场行情中的表现，如十一章所述，要正确地进行 WF 回测极为困难，没用通用方法。</li>
<li>WF的优点：
<ol type="1">
<li>WF 有清晰的历史意义，与模拟盘的结果一致；</li>
<li>WF 的测试集在训练集之后，只要正确 purging 后就不存在信息泄露（见第七章）。</li>
</ol></li>
<li>WF的缺点： 只有一种情形得到测试（即沿历史路径回测），所以容易过拟合；WF 不足以代表未来的表现，因为回测结果可能受到特定数据的影响而产生偏差；WF 回测时数据利用率不高（“most of the information is used by only a small portion of the decisions”）</li>
<li>得到一个新策略时，投资者往往想知道这个策略在“非常时期”，如08年金融危机、15年股灾中表现如何。可以将我们希望测试的时期划为测试集，其他时期划为训练集，例如将 2008年作为测试集，2009至今作为训练集。训练集在测试集之后的划分从历史角度来看并不准确（not historically accurate），但通过 CV（cross-validation）回测的目的就是检验策略在不同市场行情（scenarios）下的表现，从而推断策略在未来的表现。</li>
</ol>
<blockquote>
<p>For each period of the backtest, we simulate the performance of a classifier that knew everything except for that period.</p>
</blockquote>
<ol start="5" type="1">
<li>CV的优点：1. 能检验不同市场行情；2. 每个决定用到的信息量相同；3. 能实现最长的样本外回测。（后两点不是特别理解 ）</li>
<li>CV的缺点：1. 和 WF 一样，只有一条回测路径（尽管不是历史路径）；2. 没有明确的历史意义；3. 由于测试集可能位于训练集之前，容易发生信息泄露。</li>
<li>combinatorial purged cross-validation (CPCV)克服了WF和CV的缺点。假定将全数据集分为 N 份，其中 k 份作为测试集，其余作为训练集，则共有<span class="math inline">\(C_N^k\)</span>种划分方案。所有回测路径数 （如下图所示） <img src="img_2.png" alt="img_2.png" /></li>
<li>Assignment of testing groups to each of the 5 paths按照划分依次在训练集上训练、测试集上测试，最后可以计算<span class="math inline">\(\varphi[N, k]\)</span>条路径分别的技术指标（如夏普率），从而更全面地考察模型表现。相比 WF、CV，CPCV 得到的结果（如夏普率）方差小，从而能减少过拟合和错误回测的可能。</li>
</ol>
<h2 id="chapter-13-在合成数据上做回测">chapter 13 在合成数据上做回测</h2>
<p>本章将探究如何合成数据并进行回测。</p>
<ol type="1">
<li>使用历史数据生成一个合成数据：先从从真实数据估计得到的分布，然后从分布中采样得到合成数据。</li>
<li>使用合成数据去做回测的好处是，可以测试很多次，在unseen的情况下，因此可以减少得到一个过拟合策略的概率。</li>
<li>利用合成数据回测能减少过拟合，但合成金融数据是一个很大的课题，我们先考察一下交易规则（trading rules）。交易策略假定市场不是有效的，它们用基本面 / 技术面分析试图找到套利机会。交易策略千变万化，但交易规则大同小异：比如策略的信号强于阈值则买入，达到盈利或止损点则卖出，这里的阈值、盈利止损点就是交易规则。如果用合成数据回测来确定交易规则，则过拟合的风险将大大减小。</li>
<li>用离散OU过程（discrete O-U process）对资产价格建模，给定资产i当前价格和未来预测价格，其在 t 次交易后的盈亏<span class="math inline">\(\pi_{i,t}\)</span>服从正态分布。可以此为依据模拟价格走势进行实验，得到最佳交易规则，而无需用真实历史数据回测。</li>
<li>作者在原文中给出了详细步骤以及图文分析，这里试举一例：下图是采取不同盈利、止损点进行模拟数据回测得到的夏普率热力图。对于中性市场（上图），最好的策略是设定较宽的止损空间和较窄的盈利点；对于走高市场（下图），最好的策略是采取较宽的盈利点，而止损点的设定可以比较宽泛。</li>
<li>总而言之，通过探究引导价格波动的随机过程，而不是在真实历史数据上回测，我们得到的最佳交易规则不会在特定数据上过拟合。尽管这样得到的交易规则可能不是最优的，但也远好于过拟合的结果。本章仅以 OU 过程为例，也可以尝试其它建模方式。</li>
</ol>
<h2 id="chapter-14-回测统计">chapter 14 回测统计</h2>
<ol type="1">
<li>回测的三种范式：
<ul>
<li>历史模拟，向前游走</li>
<li>情景模拟：交叉验证</li>
<li>在模拟数据上做simulation</li>
</ul></li>
<li>回测统计量（Backtest statistics）应该帮助揭露策略的弊端（如可能的风险）、帮助投资者比较不同策略。</li>
<li>一般统计量（general characteristics）能告诉我们回测的大致特性：时间范围（回测起讫时间）、资产规模（Average AUM） ，策略的资金容量（Capacity）、杠杆率（Leverage）、平均持仓时间（Average holding period）、换手率（Annualized turnover），Maximum dollar position size/Ratio of longs/Frequency of bets</li>
<li>衡量策略表现（performance）的统计量包括：盈亏（PnL, Profit and Loss）、多头盈亏（PnL from long positions）、年化回报率（Annualized rate of return）、命中率（hit ratio）、命中回报率（Average return from hits）、失误回报率（Average return from misses）……</li>
<li>策略的回报率往往在一段时间内连续为正 / 负，称之为“周期”（Runs）。周期的存在增加了策略回撤的风险，所以需要一些统计量来衡量，包括：Returns Concentration（衡量回报的集中程度）、drawdown（回撤）、time under water。</li>
<li>某些策略错误地估计交易费用导致失败，这些需要考虑的统计量包括：Broker fees per turnover、Average slippage per turnover……</li>
<li>一些考虑到风险的统计量包括：夏普比率（Sharpe Ratio/ SR）、PSR（Probabilistic SR）、DSR（Deflated SR）、信息率（Information ratio）…… &gt; 夏普值，衡量的是一项投资在对其调整风险后，相对于无风险资产的表现。它的定义是投资收益与无风险收益之差的期望值，再除以投资标准差（即其波动性）。它代表投资者额外承受的每一单位风险所获得的额外收益。</li>
</ol>
<blockquote>
<p>Every backtest result must be reported in conjunction with all the trials involved in its production. Absent that information, it is impossible to assess the backtest’s “false discovery“ probability. —— MARCOS’ THIRD LAW OF BACKTESTING</p>
</blockquote>
<ol start="8" type="1">
<li>基金经理往往希望对模型的收益进行归因（performance attribution），可以参考多因子模型（Barra’s multi-factor method）。</li>
</ol>
<h2 id="chapter-15-了解策略风险">chapter 15 了解策略风险</h2>
<p>本章的目的是帮助你检验策略风险。</p>
<ol type="1">
<li>几乎所有策略都有盈利点和止损点，所以我们可以对策略的收益建模，检验策略对一些参数的敏感程度。</li>
<li>假定一个策略每年进行 n次 IID 决策，每一次有p的概率盈利<span class="math inline">\(\pi\)</span>，1-p的概率盈利<span class="math inline">\(-\pi\)</span>，则该策略的年化夏普比率 。（盈亏额不对称的情形可做类似讨论）</li>
<li>如果交易频率不高（ 不大），则需要较大的 才能达到高夏普比率。但即使 略大于 0.5，只要 足够大，夏普比率也可以很大，这是高频交易的思路。另一方面， 很大时， 的小幅波动会带来 的较大改变，很可能 降低 1% 就会抹去所有盈利——我们称之为策略风险（Strategy risk）。</li>
<li>策略风险不同于资产组合风险（portfolio risk）：假定 为依照上面公式计算得到的盈亏平衡点，策略风险指 ；而资产组合风险是市场中存在的风险，由首席风险官监控。策略风险过大时，即使投资标的的风险不大，这个策略也有较大概率无法超过业绩标准。所以策略研发者需要想办法减小 ，比如调节 。</li>
</ol>
<h2 id="chapter-16-基于机器学习资产配置">chapter 16 基于机器学习资产配置</h2>
<p>本章提出了基于图模型的层次风险平价方法（Hierarchical Risk Parity / HRP），其在统计性能上优于传统的资产组合优化方法。</p>
<p>资产组合可谓金融中最历久弥新的问题了。60多年前，马科维茨提出了Critical Line Algorithm（CLA）用于不等式约束下的二次规划问题，尤其是资产组合优化问题。CLA 的缺点是鲁棒性不高，因为二次规划需要对资产间协方差矩阵取逆，当该矩阵条件数很大时会带来较大误差。</p>
<p>资产组合中相关资产（多重共线性）越多，资产间协方差矩阵的条件数越大，结果越不稳定，这便是 Markowitz’s curse。此外资产越多，用于估计协方差矩阵的数据也越多，这些历史久远的数据也会造成误差。</p>
<p>作者认为，二次规划试图构建全连接图（fully connected graph），其中每个节点可能替代其他节点。当有50支资产时，一个全连接图有1225条边，这种复杂结构造成二次规划结果的不稳定。很自然地，我们会希望减少不必要的边.</p>
<p>当我们决定投资摩根大通时，下一步我们更可能考虑增/减持高盛的股票而不是一家地产公司的股票，因为摩根和高盛同属金融企业。依照这种思路，我们可以利用 ML 中的聚类算法，根据资产的特性 / 资产间相关性将所有资产建构成树状图，如下图所示。这被称为层次风险平价方法（HRP）</p>
<p>实验中 HRP 构建的投资组合比 CLA 更分散，风险也更低，同时 HRP 的样本外夏普比率更高。考虑到 HRP 不需要计算逆矩阵，其适应性和鲁棒性也更强。</p>
<p>HRP 不仅可以用于在不同资产上配置资金，还可用于在不同策略上配置资金。</p>
<h2 id="参考">参考</h2>
<ol type="1">
<li>《Advances in Financial Machine Learning》</li>
<li>https://blog.csdn.net/weixin_38753422/article/details/100179559</li>
<li>https://zhuanlan.zhihu.com/p/29208399</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chiechie.github.io/2021/07/06/AFML/AFML1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chiechie">
      <meta itemprop="description" content="a reader & thinker">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chiechie's Mini World">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/06/AFML/AFML1/" class="post-title-link" itemprop="url">《Advances in Financial Machine Learning》读书笔记1 数据分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-06 19:50:44" itemprop="dateCreated datePublished" datetime="2021-07-06T19:50:44+08:00">2021-07-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-08 10:55:20" itemprop="dateModified" datetime="2021-07-08T10:55:20+08:00">2021-07-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AFML/" itemprop="url" rel="index"><span itemprop="name">AFML</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="chapter-2-金融数据结构">chapter 2 金融数据结构</h2>
<ol type="1">
<li><p>金融数据经常分为4类，基本面数据，市场交易数据，分析数据，另类数据（Alternative） <img src="image.png" alt="img.png" /></p></li>
<li><p>基本面数据包括公司每个季度发布的会计报告，要注意发布时间和统计时间段的区别。</p></li>
<li><p>另类数据（Alternative）包括个人数据，商业过程数据，卫星，天气数据。</p></li>
<li><p>数据处理，为了让ml方法可用，需要将原始数据处理为表数据（bars）。两种处理方法，标准bar methods和信息驱动的方法。第二种在实践中用的多。</p></li>
<li><p>标准bars方法：将不等间隔处理成等间隔数据，很多数据厂商都是提供这种格式。标准bars方法包括Time Bars，Tick Bars，Volume Bars，Dollar Bars</p>
<blockquote>
<p>一个tick表示一次成交事件</p>
</blockquote></li>
<li><p>【Tick Bars】每隔多少笔交易采样一次，属于一种基于信息的采样方法，其理论依据是：固定时间内的价格变化服从方差无限大的Paretian分布；固定交易笔数内的价格变化服从高斯分布。</p>
<blockquote>
<p>Price changes over a fixed number of transactions may have a Gaussian distribution. Price changes over a fixed time period may follow a stable Paretian distribution, whose variance is infinite. Since the number of transactions in any time period is random, the above statements are not necessarily in disagreement --Mandelbrot and Taylor</p>
</blockquote></li>
<li><p>上面的假设很重要，因为很多统计方法的依赖于假设--样本来自IID高斯过程。</p></li>
<li><p>【Tick Bars】构造tick bars要留意异常点，很多交易所在看盘前和收盘后都有竞价（auction），这段时间，order book 积累 bids 和 offers单，并不撮合（match）。当竞价结束，有一笔数量很大的交易会公开，这一笔交易可等价于成千上万个ticks，虽然现实的是一个tick。</p></li>
<li><p>【Volume Bars】tick bars的缺陷在于，真实情况下，我们下的一笔单子会被拆分成多笔交易去成交。因此看到的tick比我们实际下的tick变多了。Volume bars可以解决这个问题，他是按照一定证券价值变动的时间段，进行抽样。举个例子，we could sample prices every time a futures contract exchanges 1,000 units, regardless of the number of ticks involved.</p></li>
<li><p>【Dollar Bars】每隔一段时间，市场上交易价值达到某个给定值（bar size），就进行抽样，the bar size could be adjusted dynamically as a function of the free-floating market capitalization of a company (in the case of stocks), or the outstanding amount of issued debt (in the case of fixed-income securities)</p></li>
<li><p>tick bars， volumn bars， dollar bars 三者对比： If you compute tick bars and volume bars on E-mini S&amp;P 500 futures for a given bar size, the number of bars per day will vary wildly over the years. That range and speed of variation will be reduced once you compute the number of dollar bars per day over the years, for a constant bar size. 结论是前面两者每天的变动范围和变动速度，要远高于dollar bars <img src="./img_1.png" alt="img_1.png" /></p></li>
<li><p>信息驱动的bars，目的在于，当有信息到达时，采样更频繁。信息驱动bars有几种方法：Tick Imbalance Bars，Volume/Dollar Imbalance Bars，Tick Runs Bars，Volume/Dollar Runs Bars</p></li>
<li><p>【Tick Imbalance Bars】背后的想法是只要tick数据超过我们的期望，就去采样。这样设置index，累计的交易信号超过某个阈值，没看懂</p></li>
<li><p>【Volume/Dollar Imbalance Bars】？</p></li>
<li><p>【Tick Runs Bars】？</p></li>
<li><p>【Volume/Dollar Runs Bars】？</p></li>
<li><p>处理多产品序列：The ETF Trick、PCA Weights，Single Future Roll <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pcaWeights</span>(<span class="params">cov,riskDist=<span class="literal">None</span>,riskTarget=<span class="number">1.</span></span>):</span></span><br><span class="line">    <span class="comment"># Following the riskAlloc distribution, match riskTarget</span></span><br><span class="line">    eVal,eVec = np.linalg.eigh(cov) <span class="comment"># must be Hermitian              </span></span><br><span class="line">    indices = eVal.argsort()[::-<span class="number">1</span>] <span class="comment"># arguments for sorting eVal desc</span></span><br><span class="line">    eVal,eVec=eVal[indices],eVec[:,indices]</span><br><span class="line">    <span class="keyword">if</span> riskDist <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        riskDist=np.zeros(cov.shape[<span class="number">0</span>])</span><br><span class="line">        riskDist[-<span class="number">1</span>]=<span class="number">1.</span> </span><br><span class="line">    loads=riskTarget*(riskDist/eVal)**<span class="number">.5</span> </span><br><span class="line">    wghts=np.dot(eVec,np.reshape(loads,(-<span class="number">1</span>,<span class="number">1</span>))) </span><br><span class="line">    <span class="comment">#ctr= (loads/riskTarget)**2*eVal # verify riskDist </span></span><br><span class="line"><span class="comment"># return wghts</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>直接让ml预测涨跌很难， after certain catalytic conditions算法会更容易表现好。</p></li>
<li><p>对特征进行采样的方法-Event-Based Sampling，其中一种方法叫The CUSUM Filter，利用CUSUM可以构造交易策略（Fama and Blume [1966]的filter trading strategy），同事也可以用来采样：当累计收益<span class="math inline">\(S_t\)</span>超过某个阈值时，进行采样，并将<span class="math inline">\(S\)</span>置为0，</p></li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getTEvents</span>(<span class="params">gRaw,h</span>):</span> </span><br><span class="line">    <span class="comment"># gRaw： raw time series</span></span><br><span class="line">    <span class="comment"># h: thresh</span></span><br><span class="line">    tEvents,sPos,sNeg=[],<span class="number">0</span>,<span class="number">0</span> </span><br><span class="line">    diff=gRaw.diff()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> diff.index[<span class="number">1</span>:]:</span><br><span class="line">        sPos,sNeg=<span class="built_in">max</span>(<span class="number">0</span>,sPos+diff.loc[i]),<span class="built_in">min</span>(<span class="number">0</span>,sNeg+diff.loc[i]) </span><br><span class="line">        <span class="keyword">if</span> sNeg&lt;-h:</span><br><span class="line">            sNeg=<span class="number">0</span></span><br><span class="line">            tEvents.append(i) </span><br><span class="line">        <span class="keyword">elif</span> sPos&gt;h:</span><br><span class="line">            sPos=<span class="number">0</span></span><br><span class="line">            Events.append(i) </span><br><span class="line">    <span class="keyword">return</span> pd.DatetimeIndex(tEvents)</span><br></pre></td></tr></table></figure>
<ol start="19" type="1">
<li><span class="math inline">\(S_t\)</span>可以是structural break statistics, entropy, or market microstructure measurement。比如，我们可以定义一个时间，之哟啊r SADF远离之前的取值足够远。</li>
<li>使用event-based的方法获得了一个子集之后，可以让ml算法来分析，这些特殊事件有没有蕴含一些有值得决策的信息。</li>
</ol>
<h2 id="chapter-3-标记">chapter 3 标记</h2>
<p>在监督学习中，需要输入label，那么在金融领域，如何定义label？ 固定时间范围方法不够准确（可用动态阈值来改进），同时未考虑价格变化的路径，更好的方法是三边界法；此外，元标签能结合各种先验知识，是基金公司做模型、裁员工必备工具。</p>
<h3 id="固定时间段方法">固定时间段方法</h3>
<ol type="1">
<li>大部分论文都是采用的这个方法，即固定的一段时间收益率是否超过/低于某个取值。 <img src="./img_2.png" alt="img_2.png" /></li>
<li>虽然大部分人这么用，但是这个方法跟固定时间段采样有一样的毛病，就是固定时间段内的样本并不服从gaussian分布。第二个缺陷是，这个阈值是固定的，无视当前市场波动率的变化，可能会导致错失很多有价值的正样本。</li>
<li>有更优的标记方法：动态阈值（类似异常检测）和 volume /dollar bars（波动率更固定），</li>
<li>即使改进了fixed time 和 fixed thresh，还有一个很显现实的问题就是，要考虑到价格路径，如果在半路触发margin call，那么预测得再准也没有用。</li>
</ol>
<h3 id="三边界方法the-triple-barrier-method">三边界方法（THE TRIPLE-BARRIER METHOD）</h3>
<ol type="1">
<li>简单说，固定一个窗口，价格先达到上沿就标记1，先达到下沿就标记-1，到窗口结束都被碰到就标记0。</li>
<li>具体说，首先设置2个水平障碍和1个垂直障碍。2个水平障碍是基于变动的日波动率算出来的，1个垂直障碍是说，离上一次position take，经过了bars的个数。</li>
<li>如果upper障碍最先触发，返回1；如果lower障碍最先触发，返回-1；如果垂直的障碍触发，返回-1/+1，或者0，具体情况具体分析.三重障碍方法是路径依赖的标记方法。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">applyPtSlOnT1</span>(<span class="params">close,events,ptSl,molecule</span>):</span></span><br><span class="line">    <span class="comment"># apply stop loss/profit taking, if it takes place before t1 (end of event)</span></span><br><span class="line">    events_=events.loc[molecule] </span><br><span class="line">    out=events_[[<span class="string">&#x27;t1&#x27;</span>]].copy(deep=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">if</span> ptSl[<span class="number">0</span>]&gt;<span class="number">0</span>:</span><br><span class="line">        pt=ptSl[<span class="number">0</span>]*events_[<span class="string">&#x27;trgt&#x27;</span>] </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        pt=pd.Series(index=events.index) <span class="comment"># NaNs</span></span><br><span class="line">    <span class="keyword">if</span> ptSl[<span class="number">1</span>]&gt;<span class="number">0</span>:</span><br><span class="line">        sl=-ptSl[<span class="number">1</span>]*events_[<span class="string">&#x27;trgt&#x27;</span>] </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        sl=pd.Series(index=events.index) <span class="comment"># NaNs</span></span><br><span class="line">    <span class="keyword">for</span> loc,t1 <span class="keyword">in</span> events_[<span class="string">&#x27;t1&#x27;</span>].fillna(close.index[-<span class="number">1</span>]).iteritems():</span><br><span class="line">        df0=close[loc:t1] <span class="comment"># path prices df0=(df0/close[loc]-1)*events_.at[loc,&#x27;side&#x27;] # path returns out.loc[loc,&#x27;sl&#x27;]=df0[df0&lt;sl[loc]].index.min() # earliest stop loss. out.loc[loc,&#x27;pt&#x27;]=df0[df0&gt;pt[loc]].index.min() # earliest profit taking.</span></span><br><span class="line">    <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure> 3 根据需要，三边界方法也可以有其他合理变体：下边界+右边界：我们会在一定时间后平仓，除非触发止损点提前平仓；上边界+下边界：如果没有触发盈利点和止损点，则一直持有股票；（见下图） <img src="img_4.png" alt="img_4.png" /> 这部分讨论了三边界方法的代码实现，即如何给样本打标签使得 ML 算法可以同时学习到一笔交易的方向和规模</li>
</ol>
<h3 id="同时学习方向和规模learning-side-and-size">同时学习方向和规模（LEARNING SIDE AND SIZE）</h3>
<ol type="1">
<li>这种标记可以让ml算法从side和size中学习到一些信息</li>
<li>如果没有side信息，我们没法区分profit-taking 障碍 和 stop-loss 障碍。</li>
</ol>
<h3 id="meta-labeling">META-LABELING</h3>
<p>假设你有个模型能决定交易方向，你只需要确定交易的规模（包括不交易，即规模为0）。这是金融从业者经常需要考虑的问题，我们确定要买或者卖，唯一的问题是这笔交易值得冒多大风险；同时，我们不需要 ML 模型学习交易方向，只需要它告诉我们合适的交易规模是多少。</p>
<p>假如有一个基于金融理论的模型，告诉我们交易方向，那我们的标签就变成了 [公式] （ML模型只需要决定是否执行这个操作），而不是 [公式] （ML模型同时决定交易方向和规模）</p>
<blockquote>
<p>元标签的含义:</p>
<p>金融中用ML的另一常见错误是同时学习仓位的方向和规模（据我所知很多论文仅对买/卖方向做决策，每笔交易的金额/股数是固定的）。具体而言，方向决策（买/卖）是最基本的决策，规模决策（size decision）是风险管理决策，即我们的风险承受能力有多大，以及对于方向决策有多大信心。我们没必要用一个模型处理两种决策，更好的做法是分别构建两个模型：第一个模型来做方向决策，第二个模型来预测第一个模型预测的准确度。很多ML模型表现出高精确度（precision）和低召回率（recall），这意味着这些模型过于保守，大量交易机会被错过。F1-score 综合考虑了精确度和召回率，是更好的衡量指标，元标签（META-LABELING）有助于构建高 F1-score 模型。首先（用专家知识）构建一个高召回率的基础模型，即对交易机会宁可错杀一千，不可放过一个。随后构建一个ML模型，用于决定我们是否应该执行基础模型给出的决策。元标签+ML有以下4个优势：1. 大家批评ML是黑箱，而元标签+ML则是在白箱（基础模型）的基础上构建的，具有更好的可解释性；2. 元标签+ML减少了过拟合的可能性，即ML模型仅对交易规模决策不对交易方向决策，避免一个ML模型对全部决策进行控制；3. 元标签+ML的处理方式允许更复杂的策略架构，例如：当基础模型判断应该多头，用ML模型来决定多头规模；当基础模型判断应该空头，用另一个ML模型来决定空头规模；4. 赢小输大会得不偿失，所以单独构建ML模型对规模决策是有必要的</p>
</blockquote>
<h3 id="量化-基本面方法">量化 + 基本面方法</h3>
<p>THE QUANTAMENTAL WAY</p>
<p>很多对冲基金——包括一些老牌基金——正在拥抱量化方法。元标签正是这些公司需要的：假设你有了一系列有预测力的特征，你既可以同时预测交易方向和规模；也可以用元标签方法。元标签方法中确定方向的基础模型可以是 ML模型、计量公式、交易规则、基本面分析，也可以是人类基于直觉的预测结果，可见元标签方法的普适性。</p>
<p>举个例子，元标签方法可能会发现基金经理能及时预测市场风格转换，但无法在疲倦、压力下准确预测。由于基金经理必然会受生理心理等因素影响，元标签方法能评价基金经理的预测能力。综上所述，元标签方法为基金公司的量化之路指明了方向（做模型 &amp; 评价基金经理），它应该成为基金公司的基本工具。</p>
<h3 id="丢掉不必要的label">丢掉不必要的label</h3>
<p>it is preferable to drop extremely rare labels and focus on the more common outcomes. 当标签很多且类别不均衡（imbalance）时，一些ML模型表现不好。这种情况下，最好丢掉非常罕见的标签并专注于更常见的结果。这样做有另一个原因，即用bagging方法时罕见的标签可能无法采集到，这是 sklearn 的一个bug，短期难以解决，建议读者写自己的 class，扩展 sklearn的功能。</p>
<h2 id="chapter-4-样本权重">chapter 4 样本权重</h2>
<p>训练ML 模型需要抽取样本，本章我们会考虑抽样时如何给样本加权，以更好地训练模型。</p>
<ol type="1">
<li><p>大部分ML算法都是基于IID假设，而金融时序不是IID的，所以大部分ml应用直接套用到金融场景会失败。</p></li>
<li><p>很多时候数据难免出现交叉（如三标签方法一段数据结束时间不确定），当两段数据出现交叉，标签序列就不再是IID了。这种场景经常出现在非time bars中。 <img src="img_3.png" alt="img_3.png" /></p></li>
<li><p>对此我们有三种解决方案：一是丢弃重复数据，这会造成信息损失，不推荐；二是根据独特性加权抽样——一段数据与其他数据交叉越少，独特性越高，应该给予更多权重；三是 Sequential Bootstrap，即序列有放回抽样，每抽出一个样本，相应地减少与该样本有重叠的样本被抽取的概率，这样抽取的样本比普通 Bootstrap 更接近 IID。</p></li>
<li><p>此外，绝对收益率（absolute return）大的样本应该给予更多权重，原因是对 ML 算法来说，绝对收益率小的样本不好预测，作为训练样本价值不大。</p>
<blockquote>
<p>The “neutral” case is unnecessary, as it can be implied by a “−1” or “1” prediction with low confidence.</p>
</blockquote></li>
<li><p>市场是常为新的，越新的数据与当前市场相关度越高，价值越大。</p>
<blockquote>
<p>Markets are adaptive systems (Lo [2017]). As markets evolve, older examples are less relevant than the newer ones.</p>
</blockquote></li>
<li><p>最后，我们还应该考虑类别权重。金融中不均衡数据集很常见，而且这些罕见的标签往往非常重要。在 sklearn 等科学计算包中可以设置为 class_weight='balanced' 。</p></li>
<li><p>label表示 买/卖 信号, 两个label 如果是基于相同时间段的收益率 计算出来的，就说是 concurrent的.</p></li>
<li><p>对样本使用bootstrap方法抽样，以期得到iid样本。</p></li>
<li><p>基于uniqueness和absolute return对样本赋予权重。绝对收益高的的labels应该被给予更高的权重；收益取值越unique的也要给予更高的权重</p></li>
<li><p>市场是演化着的，所以我们希望给新忘本更多的权重，给老样本更少的权重。</p></li>
<li><p>怎么量化这个事件衰减效应？设计一个时间衰减因子（所有元素加起来为1），用这个因子乘以样本权重，</p></li>
<li><p>使用机器学习做分类时，有的稀有事件（比如金融危机）出现次数很少，为了保证ml算法能重视这类事件，可以调整sample_weight</p></li>
<li><p>具体来说，在scikit learn中，设置class_weight='balanced'，或者在bagging trees中设置class_weight='balanced_subsample'，小心<a target="_blank" rel="noopener" href="https://github.com/scikit-learn/scikit-learn/issues/4324">bug</a></p></li>
</ol>
<h2 id="chapter-5-分数差分">chapter 5 分数差分</h2>
<p>分数差分--Fractionally Differentiated Features</p>
<p>如何兼顾平稳性（adf）和 记忆性（跟price的相关性）？--分数差分</p>
<h3 id="stationarity-vs.-memory的两难问题">STATIONARITY VS. MEMORY的两难问题</h3>
<ol type="1">
<li>金融序列大部分非平稳，且有很低信噪比，标准的平稳变换，例如差分变换，会丢失信息。</li>
<li>价格序列有记忆，但是差分后的序列没有记忆了。</li>
<li>接下来理论家们会从剩下的残差信号中使用各种fancy的工具去提取信息。</li>
<li>金融序列不平稳的原因是，它有很长的记忆.所以要使用传统的方法的话要做invariant processes，例如看价格的收益率或者取对数差，波动性变化</li>
<li>在信号处理中，我们是不希望所有的记忆都被抹除的，因为记忆是信号模型的basis。例如，均衡平稳模型需要一些记忆，来获取截止目前为止，结果偏离长期预测值多远，来预测。矛盾在于，收益是平稳的，但是没有记忆。价格有记忆，但是不是平稳的。 那么问题就来了：最小的差分阶数是什么？既能满足一个价格序列平稳，又能保留尽可能多的信息？</li>
<li>协整（cointergration）方法可以使用记忆来建模。</li>
<li>平稳性只是ml算法的必要不充分条件，但是通过差分变换的方法虽然获得了平稳性却丢失了记忆性，会导致ml基本上没有什么记忆能力。</li>
</ol>
<p>下面会介绍一些转换方法，在保留记忆的同时，又能实现平稳变换。</p>
<h3 id="分数差分方法">分数差分方法</h3>
<ol type="1">
<li>如何解决平稳和记忆两难的问题？Hosking [1981]提出了分数差分的方法。 <img src="fd.png" alt="img.png" /></li>
<li>使用迭代法计算权重向量 <img src="fd1.png" alt="img.png" /> <img src="fd2.png" alt="img_1.png" /></li>
<li>在SP500上面做实验，当差分d=0.35时，跟原始价格序列的相关性仍然很高, 0.995，d=1时候，相关性只有0.03, 基本上丢失了记忆。从adf上看，d=0.35时, 序列的黏稠度也不高，adf约等于 –2.8623， 原始的adf是–0.3387,d=1对应的adf是–46.9114。</li>
<li>Expanding Window 和 固定宽度窗口分数差分方法(Fixed-Width Window Fracdiff)</li>
</ol>
<h2 id="参考">参考</h2>
<ol type="1">
<li>《Advances in Financial Machine Learning》</li>
<li>https://blog.csdn.net/weixin_38753422/article/details/100179559</li>
<li>https://zhuanlan.zhihu.com/p/69231390</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/94/">94</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Chiechie</p>
  <div class="site-description" itemprop="description">a reader & thinker</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">188</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">203</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/chiechie" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;chiechie" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:328499034@qq.com" title="E-Mail → mailto:328499034@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/chiechie" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;chiechie" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chiechie</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>

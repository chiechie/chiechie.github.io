---
title: CauseInfer论文笔记
author: chiechie
date: 2021-03-02 14:41:39
tags:
- AIOps
- 根因分析
- 论文笔记
---

## 核心技术点

整个故障定位框架是这样：
在离线阶段构建因果图（causality graph）
在实时节点，使用因果图（causality graph）来做根因推断，得到可能的原因列表。

![图1-根因分析框架](img.png)


重点想知道因果图是怎么构建 以及，构建好了之后，如果做因果推断的
- 构建两个图：服务依赖图（Service Dependency Graph）和 指标因果图（Metric Causality Graph）
  服务依赖图是什么？
  这里有2个假设：
  a. 所有服务都是使用TCP作为传输层的协议，
  b. 本文的方法依赖网络统计工具，和kprobe来探测系统调用（system call）.
  （
    根据观察，大部分应用都是采用TCP协议来通信，如mysql，tomcat等；
   几乎所有主流的操作系统-linux-都已经跟网络统计工具集成了，例如netstat，tcpdump 和 kprobe
    ）
  c. 利用流量延迟，来决定服务依赖图中的依赖的方向，而不是用分析结果来确定图的结构，
  这一部分可以大大减少错误风险， 以及减少计算复杂度。 

  本文用一个tuple来表示一个服务，即 (ip, service name)， 
  chiechie： 为什么作者能抽象出来，我抽象不出来啊？

  有的文章是用 三元组three-tuple表示的 (ip, port, proto)，

  本文考虑到 一个服务可能占用多个端口，所以使用服务名称 来做聚合了。

  举一个例子，在一个三层的系统中，一个web server可以通过任意一个端口访问 application server的。
  如果，我们使用端口作为唯一服务的属性，这个服务依赖图，就会变得非常之大，即使所有请求都是由同一个服务发起的。
  
  在分布式系统中，IP表示一个唯一的主机，服务名称表示 运行在该主机上的 唯一的服务。

  我们对服务依赖的定义：如果服务A需要服务B提供特定功能，来满足 客户端的请求。就说A->B. 箭头表示「依赖」的意思。
  举个例子，一个web service需要获取一些数据库的内容，就依赖db服务，就可以说web服务->db服务。
  本文只考虑client-server类型的应用（还有什么类型的应用）

  方法的第一步就是：使用服务见的连接信息来构建 服务依赖图 的骨架（skeleton），
  通过运行工具-netstat（有点像一个采集器，类似istatus，小米手环），
  在一个主机中，我们可以拿到关于一个网络连接的 一堆信息，包括协议，来源，目的地，连接状态。
  提取来源和目的地信息，每一个连接可以表示为这个形式：
  source_ip:port -> desination_ip:port. 
  这一组信息叫一个channel。
  channel类似，服务依赖pair，除了一点：
  channel不包含服务名称，只包含port，
  接下来还有一些琐碎工作，把一个服务的端口映射为一个服务的名称，很简单，通过查询端口信息就可以获取本地的服务名称
  命令是
  "lsof -wni tcp:4000"
  但是对于一个remote端口，需要传输一个查询请求给remote的主机
  
将端口映射为服务名之后，一个本地主机的服务依赖图的架子就搭好了。
(kyoka说，每台机器只能自己监听自己的端口，别人访问这个端口)

由于client和server是双向传递的，即，在不同的主机中观察时，我们可能拿到一个反向的服务依赖。

举个例子：

- 当在192.168.1.117中观察时，我们可以获取一个连接：
(192.168.1.117, httpd) → (192.168.1.115, tomcat)，即httpd调用了tomcat。
- 但是在 主机192.168.1.115中观察时，我们又能得到这个连接
(192.168.1.115, tomcat) → (192.168.1.117, httpd), 即tomcat调用了 httpd。

为了解决这个问题，我们使用和improve了流量延迟的假设。


  什么是指标因果图？

  




- 因果推断： 当前端的服务可用性指标（SLO）出现异常，就会触发根因分析。
    首先，使用指标因果图 推断 本地服务性能问题的根因。
    如果根因位于它依赖的服务的SLO（注意，用到了调用链关系），这个推断就会传播到远程的依赖的服务。
    一直追本溯源，一直到最底层的被调用方，即物理层。
    
    如何定位一个节点上哪个指标的是故障根因？使用了DFS算法--深度优先搜索，对指标因果图进行遍历。
    当遍历到了一个点，就是用一个异常检测算法（cusum）来检测它是否异常。
    
    如果异常，继续访问他的后继（descendants）节点，
    如果正常，就去访问的邻居节点。
  
    如果一个异常节点没有后继节点，或者它的后继节点都正常时，他就是根因。

    ![推断.png](inference.png)

如果SLO异常，从SLO节点开始推断，有两个推断路径
路径1： 检测M1，如果M1正常的，就访问M1的邻居M2，如果M2异常，就是根因。
路径2.：接下来M3如果异常，我们就去检测M2，因为M2是异常的，所以我们就输出根因M2。

最后，我们只找到了一个根因M2，虽然M2和M3都是异常的。

然而，在某些情况下，因为多个因果路径存在，可能得到一系列的潜在根因集合。
因此，必须把这些根因进行排序，然后输出概率最大的根因。
本文用了z-score的方法去评价 属于根因的概率。



## 参考文献

1. [2014INFOCOM_CauseInfer](https://netman.aiops.org/~peidan/ANM2016/RootCauseAnalysis/ReadingLists/2014INFOCOM_CauseInfer.pdf)